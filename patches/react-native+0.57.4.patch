patch-package
deleted file mode 100644
--- a/node_modules/react-native/Libraries/Renderer/REVISION
+++ /dev/null
@@ -1 +0,0 @@
-d83601080a7c913cedcfbad86044702d008039c7
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/node_modules/react-native/Libraries/Renderer/fb/ReactFeatureFlags.js
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @format
+ * @flow
+ */
+
+'use strict';
+
+const ReactFeatureFlags = {
+  debugRenderPhaseSideEffects: false,
+  debugRenderPhaseSideEffectsForStrictMode: false,
+  warnAboutDeprecatedLifecycles: true,
+};
+
+module.exports = ReactFeatureFlags;
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-dev.js
@@ -27,6 +27,7 @@ var TextInputState = require("TextInputState");
 var FabricUIManager = require("FabricUIManager");
 var checkPropTypes = require("prop-types/checkPropTypes");
 var tracing = require("scheduler/tracing");
+var scheduler = require("scheduler");
 var ExceptionsManager = require("ExceptionsManager");
 
 /**
@@ -627,67 +628,26 @@ var warningWithoutStack = function() {};
       return;
     }
     if (typeof console !== "undefined") {
-      var _args$map = args.map(function(item) {
-          return "" + item;
-        }),
-        a = _args$map[0],
-        b = _args$map[1],
-        c = _args$map[2],
-        d = _args$map[3],
-        e = _args$map[4],
-        f = _args$map[5],
-        g = _args$map[6],
-        h = _args$map[7];
-
-      var message = "Warning: " + format;
-
-      // We intentionally don't use spread (or .apply) because it breaks IE9:
-      // https://github.com/facebook/react/issues/13610
-      switch (args.length) {
-        case 0:
-          console.error(message);
-          break;
-        case 1:
-          console.error(message, a);
-          break;
-        case 2:
-          console.error(message, a, b);
-          break;
-        case 3:
-          console.error(message, a, b, c);
-          break;
-        case 4:
-          console.error(message, a, b, c, d);
-          break;
-        case 5:
-          console.error(message, a, b, c, d, e);
-          break;
-        case 6:
-          console.error(message, a, b, c, d, e, f);
-          break;
-        case 7:
-          console.error(message, a, b, c, d, e, f, g);
-          break;
-        case 8:
-          console.error(message, a, b, c, d, e, f, g, h);
-          break;
-        default:
-          throw new Error(
-            "warningWithoutStack() currently supports at most 8 arguments."
-          );
-      }
+      var argsWithFormat = args.map(function(item) {
+        return "" + item;
+      });
+      argsWithFormat.unshift("Warning: " + format);
+
+      // We intentionally don't use spread (or .apply) directly because it
+      // breaks IE9: https://github.com/facebook/react/issues/13610
+      Function.prototype.apply.call(console.error, console, argsWithFormat);
     }
     try {
       // --- Welcome to debugging React ---
       // This error was thrown as a convenience so that you can use this stack
       // to find the callsite that caused this warning to fire.
       var argIndex = 0;
-      var _message =
+      var message =
         "Warning: " +
         format.replace(/%s/g, function() {
           return args[argIndex++];
         });
-      throw new Error(_message);
+      throw new Error(message);
     } catch (x) {}
   };
 }
@@ -746,11 +706,10 @@ var validateEventDispatches = void 0;
 /**
  * Dispatch the event to the listener.
  * @param {SyntheticEvent} event SyntheticEvent to handle
- * @param {boolean} simulated If the event is simulated (changes exn behavior)
  * @param {function} listener Application-level callback
  * @param {*} inst Internal component instance
  */
-function executeDispatch(event, simulated, listener, inst) {
+function executeDispatch(event, listener, inst) {
   var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
   invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
@@ -760,7 +719,7 @@ function executeDispatch(event, simulated, listener, inst) {
 /**
  * Standard/simple iteration through an event's collected dispatches.
  */
-function executeDispatchesInOrder(event, simulated) {
+function executeDispatchesInOrder(event) {
   var dispatchListeners = event._dispatchListeners;
   var dispatchInstances = event._dispatchInstances;
   {
@@ -772,15 +731,10 @@ function executeDispatchesInOrder(event, simulated) {
         break;
       }
       // Listeners and Instances are two parallel arrays that are always in sync.
-      executeDispatch(
-        event,
-        simulated,
-        dispatchListeners[i],
-        dispatchInstances[i]
-      );
+      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
     }
   } else if (dispatchListeners) {
-    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
+    executeDispatch(event, dispatchListeners, dispatchInstances);
   }
   event._dispatchListeners = null;
   event._dispatchInstances = null;
@@ -933,23 +887,19 @@ var eventQueue = null;
  * Dispatches an event and releases it back into the pool, unless persistent.
  *
  * @param {?object} event Synthetic event to be dispatched.
- * @param {boolean} simulated If the event is simulated (changes exn behavior)
  * @private
  */
-var executeDispatchesAndRelease = function(event, simulated) {
+var executeDispatchesAndRelease = function(event) {
   if (event) {
-    executeDispatchesInOrder(event, simulated);
+    executeDispatchesInOrder(event);
 
     if (!event.isPersistent()) {
       event.constructor.release(event);
     }
   }
 };
-var executeDispatchesAndReleaseSimulated = function(e) {
-  return executeDispatchesAndRelease(e, true);
-};
 var executeDispatchesAndReleaseTopLevel = function(e) {
-  return executeDispatchesAndRelease(e, false);
+  return executeDispatchesAndRelease(e);
 };
 
 function isInteractive(tag) {
@@ -1083,7 +1033,7 @@ function extractEvents(
   return events;
 }
 
-function runEventsInBatch(events, simulated) {
+function runEventsInBatch(events) {
   if (events !== null) {
     eventQueue = accumulateInto(eventQueue, events);
   }
@@ -1097,17 +1047,7 @@ function runEventsInBatch(events, simulated) {
     return;
   }
 
-  if (simulated) {
-    forEachAccumulated(
-      processingEventQueue,
-      executeDispatchesAndReleaseSimulated
-    );
-  } else {
-    forEachAccumulated(
-      processingEventQueue,
-      executeDispatchesAndReleaseTopLevel
-    );
-  }
+  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
   invariant(
     !eventQueue,
     "processEventQueue(): Additional events were enqueued while processing " +
@@ -1129,28 +1069,27 @@ function runExtractedEventsInBatch(
     nativeEvent,
     nativeEventTarget
   );
-  runEventsInBatch(events, false);
+  runEventsInBatch(events);
 }
 
 var FunctionComponent = 0;
-var FunctionComponentLazy = 1;
-var ClassComponent = 2;
-var ClassComponentLazy = 3;
-var IndeterminateComponent = 4; // Before we know whether it is function or class
-var HostRoot = 5; // Root of a host tree. Could be nested inside another node.
-var HostPortal = 6; // A subtree. Could be an entry point to a different renderer.
-var HostComponent = 7;
-var HostText = 8;
-var Fragment = 9;
-var Mode = 10;
-var ContextConsumer = 11;
-var ContextProvider = 12;
-var ForwardRef = 13;
-var ForwardRefLazy = 14;
-var Profiler = 15;
-var PlaceholderComponent = 16;
-var PureComponent = 17;
-var PureComponentLazy = 18;
+var ClassComponent = 1;
+var IndeterminateComponent = 2; // Before we know whether it is function or class
+var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
+var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
+var HostComponent = 5;
+var HostText = 6;
+var Fragment = 7;
+var Mode = 8;
+var ContextConsumer = 9;
+var ContextProvider = 10;
+var ForwardRef = 11;
+var Profiler = 12;
+var SuspenseComponent = 13;
+var MemoComponent = 14;
+var SimpleMemoComponent = 15;
+var LazyComponent = 16;
+var IncompleteClassComponent = 17;
 
 function getParent(inst) {
   do {
@@ -2650,16 +2589,16 @@ var REACT_STRICT_MODE_TYPE = hasSymbol
 var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
 var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
 var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace;
+
 var REACT_CONCURRENT_MODE_TYPE = hasSymbol
   ? Symbol.for("react.concurrent_mode")
   : 0xeacf;
 var REACT_FORWARD_REF_TYPE = hasSymbol
   ? Symbol.for("react.forward_ref")
   : 0xead0;
-var REACT_PLACEHOLDER_TYPE = hasSymbol
-  ? Symbol.for("react.placeholder")
-  : 0xead1;
-var REACT_PURE_TYPE = hasSymbol ? Symbol.for("react.pure") : 0xead3;
+var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
+var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
+var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
 
 var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
 var FAUX_ITERATOR_SYMBOL = "@@iterator";
@@ -2681,12 +2620,16 @@ var Pending = 0;
 var Resolved = 1;
 var Rejected = 2;
 
-function getResultFromResolvedThenable(thenable) {
-  return thenable._reactResult;
+function refineResolvedLazyComponent(lazyComponent) {
+  return lazyComponent._status === Resolved ? lazyComponent._result : null;
 }
 
-function refineResolvedThenable(thenable) {
-  return thenable._reactStatus === Resolved ? thenable._reactResult : null;
+function getWrappedName(outerType, innerType, wrapperName) {
+  var functionName = innerType.displayName || innerType.name || "";
+  return (
+    outerType.displayName ||
+    (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName)
+  );
 }
 
 function getComponentName(type) {
@@ -2720,8 +2663,8 @@ function getComponentName(type) {
       return "Profiler";
     case REACT_STRICT_MODE_TYPE:
       return "StrictMode";
-    case REACT_PLACEHOLDER_TYPE:
-      return "Placeholder";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
   }
   if (typeof type === "object") {
     switch (type.$$typeof) {
@@ -2730,20 +2673,15 @@ function getComponentName(type) {
       case REACT_PROVIDER_TYPE:
         return "Context.Provider";
       case REACT_FORWARD_REF_TYPE:
-        var renderFn = type.render;
-        var functionName = renderFn.displayName || renderFn.name || "";
-        return (
-          type.displayName ||
-          (functionName !== ""
-            ? "ForwardRef(" + functionName + ")"
-            : "ForwardRef")
-        );
-    }
-    if (typeof type.then === "function") {
-      var thenable = type;
-      var resolvedThenable = refineResolvedThenable(thenable);
-      if (resolvedThenable) {
-        return getComponentName(resolvedThenable);
+        return getWrappedName(type, type.render, "ForwardRef");
+      case REACT_MEMO_TYPE:
+        return getComponentName(type.type);
+      case REACT_LAZY_TYPE: {
+        var thenable = type;
+        var resolvedThenable = refineResolvedLazyComponent(thenable);
+        if (resolvedThenable) {
+          return getComponentName(resolvedThenable);
+        }
       }
     }
   }
@@ -2764,15 +2702,16 @@ var Callback = /*              */ 32;
 var DidCapture = /*            */ 64;
 var Ref = /*                   */ 128;
 var Snapshot = /*              */ 256;
+var Passive = /*               */ 512;
 
-// Update & Callback & Ref & Snapshot
-var LifecycleEffectMask = /*   */ 420;
+// Passive & Update & Callback & Ref & Snapshot
+var LifecycleEffectMask = /*   */ 932;
 
 // Union of all host effects
-var HostEffectMask = /*        */ 511;
+var HostEffectMask = /*        */ 1023;
 
-var Incomplete = /*            */ 512;
-var ShouldCapture = /*         */ 1024;
+var Incomplete = /*            */ 1024;
+var ShouldCapture = /*         */ 2048;
 
 var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
 
@@ -2816,10 +2755,7 @@ function isFiberMounted(fiber) {
 function isMounted(component) {
   {
     var owner = ReactCurrentOwner$1.current;
-    if (
-      owner !== null &&
-      (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)
-    ) {
+    if (owner !== null && owner.tag === ClassComponent) {
       var ownerFiber = owner;
       var instance = ownerFiber.stateNode;
       !instance._warnedAboutRefsInRender
@@ -3529,13 +3465,6 @@ var now$1 = hasNativePerformanceNow
 var scheduledCallback = null;
 var frameDeadline = 0;
 
-var frameDeadlineObject = {
-  timeRemaining: function() {
-    return frameDeadline - now$1();
-  },
-  didTimeout: false
-};
-
 function setTimeoutCallback() {
   // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.
   // React API probably changing to boolean rather than time remaining.
@@ -3546,7 +3475,7 @@ function setTimeoutCallback() {
   var callback = scheduledCallback;
   scheduledCallback = null;
   if (callback !== null) {
-    callback(frameDeadlineObject);
+    callback();
   }
 }
 
@@ -3565,6 +3494,10 @@ function cancelDeferredCallback$1(callbackID) {
   clearTimeout(callbackID); // Timeouts are always numbers on RN
 }
 
+function shouldYield$1() {
+  return frameDeadline <= now$1();
+}
+
 // Use to restore controlled state after a change event has fired.
 
 var restoreImpl = null;
@@ -3695,6 +3628,10 @@ var insertInContainerBefore = shim;
 var removeChild = shim;
 var removeChildFromContainer = shim;
 var resetTextContent = shim;
+var hideInstance = shim;
+var hideTextInstance = shim;
+var unhideInstance = shim;
+var unhideTextInstance = shim;
 
 // Renderers that don't support hydration
 // can re-export everything from this module.
@@ -3702,7 +3639,7 @@ var resetTextContent = shim;
 function shim$1() {
   invariant(
     false,
-    "The current renderer does not support hyration. " +
+    "The current renderer does not support hydration. " +
       "This error is likely caused by a bug in React. " +
       "Please file an issue."
   );
@@ -3972,6 +3909,7 @@ var isPrimaryRenderer = false;
 var now = now$1;
 var scheduleDeferredCallback = scheduleDeferredCallback$1;
 var cancelDeferredCallback = cancelDeferredCallback$1;
+var shouldYield = shouldYield$1;
 
 var scheduleTimeout = setTimeout;
 var cancelTimeout = clearTimeout;
@@ -4017,6 +3955,42 @@ function cloneInstance(
   };
 }
 
+function cloneHiddenInstance(instance, type, props, internalInstanceHandle) {
+  var viewConfig = instance.canonical.viewConfig;
+  var node = instance.node;
+  var updatePayload = create(
+    { style: { display: "none" } },
+    viewConfig.validAttributes
+  );
+  return {
+    node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
+    canonical: instance.canonical
+  };
+}
+
+function cloneUnhiddenInstance(instance, type, props, internalInstanceHandle) {
+  var viewConfig = instance.canonical.viewConfig;
+  var node = instance.node;
+  var updatePayload = diff(
+    Object.assign({}, props, { style: [props.style, { display: "none" }] }),
+    props,
+    viewConfig.validAttributes
+  );
+  return {
+    node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
+    canonical: instance.canonical
+  };
+}
+
+function createHiddenTextInstance(
+  text,
+  rootContainerInstance,
+  hostContext,
+  internalInstanceHandle
+) {
+  throw new Error("Not yet implemented.");
+}
+
 function createContainerChildSet(container) {
   return FabricUIManager.createChildSet(container);
 }
@@ -4062,12 +4036,12 @@ var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
 function describeFiber(fiber) {
   switch (fiber.tag) {
     case IndeterminateComponent:
+    case LazyComponent:
     case FunctionComponent:
-    case FunctionComponentLazy:
     case ClassComponent:
-    case ClassComponentLazy:
     case HostComponent:
     case Mode:
+    case SuspenseComponent:
       var owner = fiber._debugOwner;
       var source = fiber._debugSource;
       var name = getComponentName(fiber.type);
@@ -4144,7 +4118,7 @@ function setCurrentPhase(lifeCyclePhase) {
 var debugRenderPhaseSideEffects = false;
 var debugRenderPhaseSideEffectsForStrictMode = false;
 var enableUserTimingAPI = true;
-var enableSuspense = false;
+var enableHooks = true;
 var warnAboutDeprecatedLifecycles = false;
 var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
 var enableProfilerTimer = true;
@@ -4422,7 +4396,10 @@ function stopFailedWorkTimer(fiber) {
       return;
     }
     fiber._debugIsCurrentlyTiming = false;
-    var warning = "An error was thrown inside this error boundary";
+    var warning =
+      fiber.tag === SuspenseComponent
+        ? "Rendering was suspended"
+        : "An error was thrown inside this error boundary";
     endFiberMark(fiber, null, warning);
   }
 }
@@ -4913,8 +4890,7 @@ function findCurrentUnmaskedContext(fiber) {
   // Currently this is only used with renderSubtreeIntoContainer; not sure if it
   // makes sense elsewhere
   invariant(
-    isFiberMounted(fiber) &&
-      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy),
+    isFiberMounted(fiber) && fiber.tag === ClassComponent,
     "Expected subtree parent to be a mounted class component. " +
       "This error is likely caused by a bug in React. Please file an issue."
   );
@@ -4931,13 +4907,6 @@ function findCurrentUnmaskedContext(fiber) {
         }
         break;
       }
-      case ClassComponentLazy: {
-        var _Component = getResultFromResolvedThenable(node.type);
-        if (isContextProvider(_Component)) {
-          return node.stateNode.__reactInternalMemoizedMergedChildContext;
-        }
-        break;
-      }
     }
     node = node.return;
   } while (node !== null);
@@ -5036,20 +5005,20 @@ function onCommitUnmount(fiber) {
 var maxSigned31BitInt = 1073741823;
 
 var NoWork = 0;
-var Sync = 1;
-var Never = maxSigned31BitInt;
+var Never = 1;
+var Sync = maxSigned31BitInt;
 
 var UNIT_SIZE = 10;
-var MAGIC_NUMBER_OFFSET = 2;
+var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;
 
 // 1 unit of expiration time represents 10ms.
 function msToExpirationTime(ms) {
   // Always add an offset so that we don't clash with the magic number for NoWork.
-  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;
+  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
 }
 
 function expirationTimeToMs(expirationTime) {
-  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
+  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
 }
 
 function ceiling(num, precision) {
@@ -5058,9 +5027,9 @@ function ceiling(num, precision) {
 
 function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
   return (
-    MAGIC_NUMBER_OFFSET +
+    MAGIC_NUMBER_OFFSET -
     ceiling(
-      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,
+      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
       bucketSizeMs / UNIT_SIZE
     )
   );
@@ -5136,6 +5105,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   // Instance
   this.tag = tag;
   this.key = key;
+  this.elementType = null;
   this.type = null;
   this.stateNode = null;
 
@@ -5208,18 +5178,24 @@ function shouldConstruct(Component) {
   return !!(prototype && prototype.isReactComponent);
 }
 
-function resolveLazyComponentTag(fiber, Component) {
+function isSimpleFunctionComponent(type) {
+  return (
+    typeof type === "function" &&
+    !shouldConstruct(type) &&
+    type.defaultProps === undefined
+  );
+}
+
+function resolveLazyComponentTag(Component) {
   if (typeof Component === "function") {
-    return shouldConstruct(Component)
-      ? ClassComponentLazy
-      : FunctionComponentLazy;
+    return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
   } else if (Component !== undefined && Component !== null) {
     var $$typeof = Component.$$typeof;
     if ($$typeof === REACT_FORWARD_REF_TYPE) {
-      return ForwardRefLazy;
+      return ForwardRef;
     }
-    if ($$typeof === REACT_PURE_TYPE) {
-      return PureComponentLazy;
+    if ($$typeof === REACT_MEMO_TYPE) {
+      return MemoComponent;
     }
   }
   return IndeterminateComponent;
@@ -5240,6 +5216,7 @@ function createWorkInProgress(current, pendingProps, expirationTime) {
       current.key,
       current.mode
     );
+    workInProgress.elementType = current.elementType;
     workInProgress.type = current.type;
     workInProgress.stateNode = current.stateNode;
 
@@ -5309,20 +5286,23 @@ function createHostRootFiber(isConcurrent) {
   return createFiber(HostRoot, null, null, mode);
 }
 
-function createFiberFromElement(element, mode, expirationTime) {
-  var owner = null;
-  {
-    owner = element._owner;
-  }
-
+function createFiberFromTypeAndProps(
+  type, // React$ElementType
+  key,
+  pendingProps,
+  owner,
+  mode,
+  expirationTime
+) {
   var fiber = void 0;
-  var type = element.type;
-  var key = element.key;
-  var pendingProps = element.props;
 
-  var fiberTag = void 0;
+  var fiberTag = IndeterminateComponent;
+  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
+  var resolvedType = type;
   if (typeof type === "function") {
-    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;
+    if (shouldConstruct(type)) {
+      fiberTag = ClassComponent;
+    }
   } else if (typeof type === "string") {
     fiberTag = HostComponent;
   } else {
@@ -5335,18 +5315,23 @@ function createFiberFromElement(element, mode, expirationTime) {
           key
         );
       case REACT_CONCURRENT_MODE_TYPE:
-        fiberTag = Mode;
-        mode |= ConcurrentMode | StrictMode;
-        break;
+        return createFiberFromMode(
+          pendingProps,
+          mode | ConcurrentMode | StrictMode,
+          expirationTime,
+          key
+        );
       case REACT_STRICT_MODE_TYPE:
-        fiberTag = Mode;
-        mode |= StrictMode;
-        break;
+        return createFiberFromMode(
+          pendingProps,
+          mode | StrictMode,
+          expirationTime,
+          key
+        );
       case REACT_PROFILER_TYPE:
         return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
-      case REACT_PLACEHOLDER_TYPE:
-        fiberTag = PlaceholderComponent;
-        break;
+      case REACT_SUSPENSE_TYPE:
+        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
       default: {
         if (typeof type === "object" && type !== null) {
           switch (type.$$typeof) {
@@ -5360,15 +5345,13 @@ function createFiberFromElement(element, mode, expirationTime) {
             case REACT_FORWARD_REF_TYPE:
               fiberTag = ForwardRef;
               break getTag;
-            case REACT_PURE_TYPE:
-              fiberTag = PureComponent;
+            case REACT_MEMO_TYPE:
+              fiberTag = MemoComponent;
+              break getTag;
+            case REACT_LAZY_TYPE:
+              fiberTag = LazyComponent;
+              resolvedType = null;
               break getTag;
-            default: {
-              if (typeof type.then === "function") {
-                fiberTag = IndeterminateComponent;
-                break getTag;
-              }
-            }
           }
         }
         var info = "";
@@ -5402,14 +5385,33 @@ function createFiberFromElement(element, mode, expirationTime) {
   }
 
   fiber = createFiber(fiberTag, pendingProps, key, mode);
-  fiber.type = type;
+  fiber.elementType = type;
+  fiber.type = resolvedType;
   fiber.expirationTime = expirationTime;
 
+  return fiber;
+}
+
+function createFiberFromElement(element, mode, expirationTime) {
+  var owner = null;
+  {
+    owner = element._owner;
+  }
+  var type = element.type;
+  var key = element.key;
+  var pendingProps = element.props;
+  var fiber = createFiberFromTypeAndProps(
+    type,
+    key,
+    pendingProps,
+    owner,
+    mode,
+    expirationTime
+  );
   {
     fiber._debugSource = element._source;
     fiber._debugOwner = element._owner;
   }
-
   return fiber;
 }
 
@@ -5433,12 +5435,41 @@ function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
   }
 
   var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
+  // TODO: The Profiler fiber shouldn't have a type. It has a tag.
+  fiber.elementType = REACT_PROFILER_TYPE;
   fiber.type = REACT_PROFILER_TYPE;
   fiber.expirationTime = expirationTime;
 
   return fiber;
 }
 
+function createFiberFromMode(pendingProps, mode, expirationTime, key) {
+  var fiber = createFiber(Mode, pendingProps, key, mode);
+
+  // TODO: The Mode fiber shouldn't have a type. It has a tag.
+  var type =
+    (mode & ConcurrentMode) === NoContext
+      ? REACT_STRICT_MODE_TYPE
+      : REACT_CONCURRENT_MODE_TYPE;
+  fiber.elementType = type;
+  fiber.type = type;
+
+  fiber.expirationTime = expirationTime;
+  return fiber;
+}
+
+function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
+  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
+
+  // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
+  var type = REACT_SUSPENSE_TYPE;
+  fiber.elementType = type;
+  fiber.type = type;
+
+  fiber.expirationTime = expirationTime;
+  return fiber;
+}
+
 function createFiberFromText(content, mode, expirationTime) {
   var fiber = createFiber(HostText, content, null, mode);
   fiber.expirationTime = expirationTime;
@@ -5447,6 +5478,8 @@ function createFiberFromText(content, mode, expirationTime) {
 
 function createFiberFromHostInstanceForDeletion() {
   var fiber = createFiber(HostComponent, null, null, NoContext);
+  // TODO: These should not need a type.
+  fiber.elementType = "DELETED";
   fiber.type = "DELETED";
   return fiber;
 }
@@ -5479,6 +5512,7 @@ function assignFiberPropertiesInDEV(target, source) {
 
   target.tag = source.tag;
   target.key = source.key;
+  target.elementType = source.elementType;
   target.type = source.type;
   target.stateNode = source.stateNode;
   target.return = source.return;
@@ -6021,12 +6055,12 @@ function markPendingPriorityLevel(root, expirationTime) {
     // No other pending updates.
     root.earliestPendingTime = root.latestPendingTime = expirationTime;
   } else {
-    if (earliestPendingTime > expirationTime) {
+    if (earliestPendingTime < expirationTime) {
       // This is the earliest pending update.
       root.earliestPendingTime = expirationTime;
     } else {
       var latestPendingTime = root.latestPendingTime;
-      if (latestPendingTime < expirationTime) {
+      if (latestPendingTime > expirationTime) {
         // This is the latest pending update
         root.latestPendingTime = expirationTime;
       }
@@ -6052,12 +6086,12 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
   // Let's see if the previous latest known pending level was just flushed.
   var latestPendingTime = root.latestPendingTime;
   if (latestPendingTime !== NoWork) {
-    if (latestPendingTime < earliestRemainingTime) {
+    if (latestPendingTime > earliestRemainingTime) {
       // We've flushed all the known pending levels.
       root.earliestPendingTime = root.latestPendingTime = NoWork;
     } else {
       var earliestPendingTime = root.earliestPendingTime;
-      if (earliestPendingTime < earliestRemainingTime) {
+      if (earliestPendingTime > earliestRemainingTime) {
         // We've flushed the earliest known pending level. Set this to the
         // latest pending time.
         root.earliestPendingTime = root.latestPendingTime;
@@ -6079,7 +6113,7 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
   }
 
   var latestSuspendedTime = root.latestSuspendedTime;
-  if (earliestRemainingTime > latestSuspendedTime) {
+  if (earliestRemainingTime < latestSuspendedTime) {
     // The earliest remaining level is later than all the suspended work. That
     // means we've flushed all the suspended work.
     root.earliestSuspendedTime = NoWork;
@@ -6093,7 +6127,7 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
     return;
   }
 
-  if (earliestRemainingTime < earliestSuspendedTime) {
+  if (earliestRemainingTime > earliestSuspendedTime) {
     // The earliest remaining time is earlier than all the suspended work.
     // Treat it as a pending update.
     markPendingPriorityLevel(root, earliestRemainingTime);
@@ -6112,10 +6146,10 @@ function hasLowerPriorityWork(root, erroredExpirationTime) {
   var latestPingedTime = root.latestPingedTime;
   return (
     (latestPendingTime !== NoWork &&
-      latestPendingTime > erroredExpirationTime) ||
+      latestPendingTime < erroredExpirationTime) ||
     (latestSuspendedTime !== NoWork &&
-      latestSuspendedTime > erroredExpirationTime) ||
-    (latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime)
+      latestSuspendedTime < erroredExpirationTime) ||
+    (latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime)
   );
 }
 
@@ -6124,8 +6158,8 @@ function isPriorityLevelSuspended(root, expirationTime) {
   var latestSuspendedTime = root.latestSuspendedTime;
   return (
     earliestSuspendedTime !== NoWork &&
-    expirationTime >= earliestSuspendedTime &&
-    expirationTime <= latestSuspendedTime
+    expirationTime <= earliestSuspendedTime &&
+    expirationTime >= latestSuspendedTime
   );
 }
 
@@ -6158,10 +6192,10 @@ function markSuspendedPriorityLevel(root, suspendedTime) {
     // No other suspended levels.
     root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
   } else {
-    if (earliestSuspendedTime > suspendedTime) {
+    if (earliestSuspendedTime < suspendedTime) {
       // This is the earliest suspended level.
       root.earliestSuspendedTime = suspendedTime;
-    } else if (latestSuspendedTime < suspendedTime) {
+    } else if (latestSuspendedTime > suspendedTime) {
       // This is the latest suspended level
       root.latestSuspendedTime = suspendedTime;
     }
@@ -6177,7 +6211,7 @@ function markPingedPriorityLevel(root, pingedTime) {
   // is thrown out and not reused during the restarted render. One way to
   // invalidate the progressed work is to restart at expirationTime + 1.
   var latestPingedTime = root.latestPingedTime;
-  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {
+  if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
     root.latestPingedTime = pingedTime;
   }
   findNextExpirationTimeToWorkOn(pingedTime, root);
@@ -6187,7 +6221,7 @@ function clearPing(root, completedTime) {
   // TODO: Track whether the root was pinged during the render phase. If so,
   // we need to make sure we don't lose track of it.
   var latestPingedTime = root.latestPingedTime;
-  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {
+  if (latestPingedTime !== NoWork && latestPingedTime >= completedTime) {
     root.latestPingedTime = NoWork;
   }
 }
@@ -6197,18 +6231,10 @@ function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
 
   var earliestPendingTime = root.earliestPendingTime;
   var earliestSuspendedTime = root.earliestSuspendedTime;
-  if (
-    earliestExpirationTime === NoWork ||
-    (earliestPendingTime !== NoWork &&
-      earliestPendingTime < earliestExpirationTime)
-  ) {
+  if (earliestPendingTime > earliestExpirationTime) {
     earliestExpirationTime = earliestPendingTime;
   }
-  if (
-    earliestExpirationTime === NoWork ||
-    (earliestSuspendedTime !== NoWork &&
-      earliestSuspendedTime < earliestExpirationTime)
-  ) {
+  if (earliestSuspendedTime > earliestExpirationTime) {
     earliestExpirationTime = earliestSuspendedTime;
   }
   return earliestExpirationTime;
@@ -6216,7 +6242,7 @@ function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
 
 function didExpireAtExpirationTime(root, currentTime) {
   var expirationTime = root.expirationTime;
-  if (expirationTime !== NoWork && currentTime >= expirationTime) {
+  if (expirationTime !== NoWork && currentTime <= expirationTime) {
     // The root has expired. Flush all work up to the current time.
     root.nextExpirationTimeToWorkOn = currentTime;
   }
@@ -6238,7 +6264,7 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   if (
     nextExpirationTimeToWorkOn === NoWork &&
     (completedExpirationTime === NoWork ||
-      latestSuspendedTime > completedExpirationTime)
+      latestSuspendedTime < completedExpirationTime)
   ) {
     // The lowest priority suspended work is the work most likely to be
     // committed next. Let's start rendering it again, so that if it times out,
@@ -6247,11 +6273,7 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   }
 
   var expirationTime = nextExpirationTimeToWorkOn;
-  if (
-    expirationTime !== NoWork &&
-    earliestSuspendedTime !== NoWork &&
-    earliestSuspendedTime < expirationTime
-  ) {
+  if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
     // Expire using the earliest known expiration time.
     expirationTime = earliestSuspendedTime;
   }
@@ -6475,7 +6497,7 @@ function enqueueUpdate(fiber, update) {
 
   {
     if (
-      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &&
+      fiber.tag === ClassComponent &&
       (currentlyProcessingQueue === queue1 ||
         (queue2 !== null && currentlyProcessingQueue === queue2)) &&
       !didWarnUpdateInsideUpdate
@@ -6623,7 +6645,7 @@ function processUpdateQueue(
   var resultState = newBaseState;
   while (update !== null) {
     var updateExpirationTime = update.expirationTime;
-    if (updateExpirationTime > renderExpirationTime) {
+    if (updateExpirationTime < renderExpirationTime) {
       // This update does not have sufficient priority. Skip it.
       if (newFirstUpdate === null) {
         // This is the first skipped update. It will be the first update in
@@ -6635,10 +6657,7 @@ function processUpdateQueue(
       }
       // Since this update will remain in the list, update the remaining
       // expiration time.
-      if (
-        newExpirationTime === NoWork ||
-        newExpirationTime > updateExpirationTime
-      ) {
+      if (newExpirationTime < updateExpirationTime) {
         newExpirationTime = updateExpirationTime;
       }
     } else {
@@ -6674,7 +6693,7 @@ function processUpdateQueue(
   update = queue.firstCapturedUpdate;
   while (update !== null) {
     var _updateExpirationTime = update.expirationTime;
-    if (_updateExpirationTime > renderExpirationTime) {
+    if (_updateExpirationTime < renderExpirationTime) {
       // This update does not have sufficient priority. Skip it.
       if (newFirstCapturedUpdate === null) {
         // This is the first skipped captured update. It will be the first
@@ -6688,10 +6707,7 @@ function processUpdateQueue(
       }
       // Since this update will remain in the list, update the remaining
       // expiration time.
-      if (
-        newExpirationTime === NoWork ||
-        newExpirationTime > _updateExpirationTime
-      ) {
+      if (newExpirationTime < _updateExpirationTime) {
         newExpirationTime = _updateExpirationTime;
       }
     } else {
@@ -6989,10 +7005,7 @@ function propagateContextChange(
         ) {
           // Match! Schedule an update on this fiber.
 
-          if (
-            fiber.tag === ClassComponent ||
-            fiber.tag === ClassComponentLazy
-          ) {
+          if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
             var update = createUpdate(renderExpirationTime);
             update.tag = ForceUpdate;
@@ -7003,17 +7016,13 @@ function propagateContextChange(
             enqueueUpdate(fiber, update);
           }
 
-          if (
-            fiber.expirationTime === NoWork ||
-            fiber.expirationTime > renderExpirationTime
-          ) {
+          if (fiber.expirationTime < renderExpirationTime) {
             fiber.expirationTime = renderExpirationTime;
           }
           var alternate = fiber.alternate;
           if (
             alternate !== null &&
-            (alternate.expirationTime === NoWork ||
-              alternate.expirationTime > renderExpirationTime)
+            alternate.expirationTime < renderExpirationTime
           ) {
             alternate.expirationTime = renderExpirationTime;
           }
@@ -7022,22 +7031,17 @@ function propagateContextChange(
           var node = fiber.return;
           while (node !== null) {
             alternate = node.alternate;
-            if (
-              node.childExpirationTime === NoWork ||
-              node.childExpirationTime > renderExpirationTime
-            ) {
+            if (node.childExpirationTime < renderExpirationTime) {
               node.childExpirationTime = renderExpirationTime;
               if (
                 alternate !== null &&
-                (alternate.childExpirationTime === NoWork ||
-                  alternate.childExpirationTime > renderExpirationTime)
+                alternate.childExpirationTime < renderExpirationTime
               ) {
                 alternate.childExpirationTime = renderExpirationTime;
               }
             } else if (
               alternate !== null &&
-              (alternate.childExpirationTime === NoWork ||
-                alternate.childExpirationTime > renderExpirationTime)
+              alternate.childExpirationTime < renderExpirationTime
             ) {
               alternate.childExpirationTime = renderExpirationTime;
             } else {
@@ -7122,7 +7126,7 @@ function readContext(context, observedBits) {
     if (lastContextDependency === null) {
       invariant(
         currentlyRenderingFiber !== null,
-        "Context.unstable_read(): Context can only be read while React is " +
+        "Context can only be read while React is " +
           "rendering, e.g. inside the render method or getDerivedStateFromProps."
       );
       // This is the first dependency in the list
@@ -7135,138 +7139,780 @@ function readContext(context, observedBits) {
   return isPrimaryRenderer ? context._currentValue : context._currentValue2;
 }
 
-var NO_CONTEXT = {};
+var NoEffect$1 = /*             */ 0;
+var UnmountSnapshot = /*      */ 2;
+var UnmountMutation = /*      */ 4;
+var MountMutation = /*        */ 8;
+var UnmountLayout = /*        */ 16;
+var MountLayout = /*          */ 32;
+var MountPassive = /*         */ 64;
+var UnmountPassive = /*       */ 128;
 
-var contextStackCursor$1 = createCursor(NO_CONTEXT);
-var contextFiberStackCursor = createCursor(NO_CONTEXT);
-var rootInstanceStackCursor = createCursor(NO_CONTEXT);
+function areHookInputsEqual(arr1, arr2) {
+  // Don't bother comparing lengths in prod because these arrays should be
+  // passed inline.
+  {
+    !(arr1.length === arr2.length)
+      ? warning$1(
+          false,
+          "Detected a variable number of hook dependencies. The length of the " +
+            "dependencies array should be constant between renders.\n\n" +
+            "Previous: %s\n" +
+            "Incoming: %s",
+          arr1.join(", "),
+          arr2.join(", ")
+        )
+      : void 0;
+  }
+  for (var i = 0; i < arr1.length; i++) {
+    // Inlined Object.is polyfill.
+    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+    var val1 = arr1[i];
+    var val2 = arr2[i];
+    if (
+      (val1 === val2 && (val1 !== 0 || 1 / val1 === 1 / val2)) ||
+      (val1 !== val1 && val2 !== val2) // eslint-disable-line no-self-compare
+    ) {
+      continue;
+    }
+    return false;
+  }
+  return true;
+}
 
-function requiredContext(c) {
+// These are set right before calling the component.
+var renderExpirationTime = NoWork;
+// The work-in-progress fiber. I've named it differently to distinguish it from
+// the work-in-progress hook.
+var currentlyRenderingFiber$1 = null;
+
+// Hooks are stored as a linked list on the fiber's memoizedState field. The
+// current hook list is the list that belongs to the current fiber. The
+// work-in-progress hook list is a new list that will be added to the
+// work-in-progress fiber.
+var firstCurrentHook = null;
+var currentHook = null;
+var firstWorkInProgressHook = null;
+var workInProgressHook = null;
+
+var remainingExpirationTime = NoWork;
+var componentUpdateQueue = null;
+
+// Updates scheduled during render will trigger an immediate re-render at the
+// end of the current pass. We can't store these updates on the normal queue,
+// because if the work is aborted, they should be discarded. Because this is
+// a relatively rare case, we also don't want to add an additional field to
+// either the hook or queue object types. So we store them in a lazily create
+// map of queue -> render-phase updates, which are discarded once the component
+// completes without re-rendering.
+
+// Whether the work-in-progress hook is a re-rendered hook
+var isReRender = false;
+// Whether an update was scheduled during the currently executing render pass.
+var didScheduleRenderPhaseUpdate = false;
+// Lazily created map of render-phase updates
+var renderPhaseUpdates = null;
+// Counter to prevent infinite loops.
+var numberOfReRenders = 0;
+var RE_RENDER_LIMIT = 25;
+
+function resolveCurrentlyRenderingFiber() {
   invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug " +
-      "in React. Please file an issue."
+    currentlyRenderingFiber$1 !== null,
+    "Hooks can only be called inside the body of a function component."
   );
-  return c;
+  return currentlyRenderingFiber$1;
 }
 
-function getRootHostContainer() {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  return rootInstance;
-}
+function prepareToUseHooks(current, workInProgress, nextRenderExpirationTime) {
+  if (!enableHooks) {
+    return;
+  }
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = current !== null ? current.memoizedState : null;
 
-function pushHostContainer(fiber, nextRootInstance) {
-  // Push current root instance onto the stack;
-  // This allows us to reset root when portals are popped.
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
+  // The following should have already been reset
+  // currentHook = null;
+  // workInProgressHook = null;
 
-  // Finally, we need to push the host context to the stack.
-  // However, we can't just call getRootHostContext() and push it because
-  // we'd have a different number of entries on the stack depending on
-  // whether getRootHostContext() throws somewhere in renderer code or not.
-  // So we push an empty value first. This lets us safely unwind on errors.
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  var nextRootContext = getRootHostContext(nextRootInstance);
-  // Now that we know this function doesn't throw, replace it.
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, nextRootContext, fiber);
-}
+  // remainingExpirationTime = NoWork;
+  // componentUpdateQueue = null;
 
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
+  // isReRender = false;
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = 0;
 }
 
-function getHostContext() {
-  var context = requiredContext(contextStackCursor$1.current);
-  return context;
-}
+function finishHooks(Component, props, children, refOrContext) {
+  if (!enableHooks) {
+    return children;
+  }
 
-function pushHostContext(fiber) {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+  // This must be called after every function component to prevent hooks from
+  // being used in classes.
 
-  // Don't push this Fiber's context unless it's unique.
-  if (context === nextContext) {
-    return;
-  }
+  while (didScheduleRenderPhaseUpdate) {
+    // Updates were scheduled during the render phase. They are stored in
+    // the `renderPhaseUpdates` map. Call the component again, reusing the
+    // work-in-progress hooks and applying the additional updates on top. Keep
+    // restarting until no more updates are scheduled.
+    didScheduleRenderPhaseUpdate = false;
+    numberOfReRenders += 1;
 
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, nextContext, fiber);
-}
+    // Start over from the beginning of the list
+    currentHook = null;
+    workInProgressHook = null;
+    componentUpdateQueue = null;
 
-function popHostContext(fiber) {
-  // Do not pop unless this Fiber provided the current context.
-  // pushHostContext() only pushes Fibers that provide unique contexts.
-  if (contextFiberStackCursor.current !== fiber) {
-    return;
+    children = Component(props, refOrContext);
   }
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
 
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-}
+  var renderedWork = currentlyRenderingFiber$1;
 
-var commitTime = 0;
-var profilerStartTime = -1;
+  renderedWork.memoizedState = firstWorkInProgressHook;
+  renderedWork.expirationTime = remainingExpirationTime;
+  renderedWork.updateQueue = componentUpdateQueue;
 
-function getCommitTime() {
-  return commitTime;
-}
+  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
 
-function recordCommitTime() {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  commitTime = now();
-}
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-function startProfilerTimer(fiber) {
-  if (!enableProfilerTimer) {
-    return;
-  }
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-  profilerStartTime = now();
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-  if (fiber.actualStartTime < 0) {
-    fiber.actualStartTime = now();
-  }
-}
+  // Always set during createWorkInProgress
+  // isReRender = false;
 
-function stopProfilerTimerIfRunning(fiber) {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  profilerStartTime = -1;
+  // These were reset above
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = 0;
+
+  invariant(
+    !didRenderTooFewHooks,
+    "Rendered fewer hooks than expected. This may be caused by an accidental " +
+      "early return statement."
+  );
+
+  return children;
 }
 
-function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
-  if (!enableProfilerTimer) {
+function resetHooks() {
+  if (!enableHooks) {
     return;
   }
 
-  if (profilerStartTime >= 0) {
-    var elapsedTime = now() - profilerStartTime;
-    fiber.actualDuration += elapsedTime;
-    if (overrideBaseTime) {
-      fiber.selfBaseDuration = elapsedTime;
-    }
-    profilerStartTime = -1;
-  }
-}
+  // This is called instead of `finishHooks` if the component throws. It's also
+  // called inside mountIndeterminateComponent if we determine the component
+  // is a module-style component.
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-/*eslint-disable no-self-compare */
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-var hasOwnProperty = Object.prototype.hasOwnProperty;
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-/**
- * inlined Object.is polyfill to avoid requiring consumers ship their own
+  // Always set during createWorkInProgress
+  // isReRender = false;
+
+  didScheduleRenderPhaseUpdate = false;
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+}
+
+function createHook() {
+  return {
+    memoizedState: null,
+
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+
+    next: null
+  };
+}
+
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+
+    baseState: hook.memoizedState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+
+    next: null
+  };
+}
+
+function createWorkInProgressHook() {
+  if (workInProgressHook === null) {
+    // This is the first hook in the list
+    if (firstWorkInProgressHook === null) {
+      isReRender = false;
+      currentHook = firstCurrentHook;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        workInProgressHook = createHook();
+      } else {
+        // Clone the current hook.
+        workInProgressHook = cloneHook(currentHook);
+      }
+      firstWorkInProgressHook = workInProgressHook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      isReRender = true;
+      currentHook = firstCurrentHook;
+      workInProgressHook = firstWorkInProgressHook;
+    }
+  } else {
+    if (workInProgressHook.next === null) {
+      isReRender = false;
+      var hook = void 0;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        hook = createHook();
+      } else {
+        currentHook = currentHook.next;
+        if (currentHook === null) {
+          // This is a newly mounted hook
+          hook = createHook();
+        } else {
+          // Clone the current hook.
+          hook = cloneHook(currentHook);
+        }
+      }
+      // Append to the end of the list
+      workInProgressHook = workInProgressHook.next = hook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      isReRender = true;
+      workInProgressHook = workInProgressHook.next;
+      currentHook = currentHook !== null ? currentHook.next : null;
+    }
+  }
+  return workInProgressHook;
+}
+
+function createFunctionComponentUpdateQueue() {
+  return {
+    lastEffect: null
+  };
+}
+
+function basicStateReducer(state, action) {
+  return typeof action === "function" ? action(state) : action;
+}
+
+function useContext(context, observedBits) {
+  // Ensure we're in a function component (class components support only the
+  // .unstable_read() form)
+  resolveCurrentlyRenderingFiber();
+  return readContext(context, observedBits);
+}
+
+function useState(initialState) {
+  return useReducer(
+    basicStateReducer,
+    // useReducer has a special case to support lazy useState initializers
+    initialState
+  );
+}
+
+function useReducer(reducer, initialState, initialAction) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (queue !== null) {
+    // Already have a queue, so this is an update.
+    if (isReRender) {
+      // This is a re-render. Apply the new render phase updates to the previous
+      var _dispatch2 = queue.dispatch;
+      if (renderPhaseUpdates !== null) {
+        // Render phase updates are stored in a map of queue -> linked list
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (firstRenderPhaseUpdate !== undefined) {
+          renderPhaseUpdates.delete(queue);
+          var newState = workInProgressHook.memoizedState;
+          var update = firstRenderPhaseUpdate;
+          do {
+            // Process this render phase update. We don't have to check the
+            // priority because it will always be the same as the current
+            // render's.
+            var _action = update.action;
+            newState = reducer(newState, _action);
+            update = update.next;
+          } while (update !== null);
+
+          workInProgressHook.memoizedState = newState;
+
+          // Don't persist the state accumlated from the render phase updates to
+          // the base state unless the queue is empty.
+          // TODO: Not sure if this is the desired semantics, but it's what we
+          // do for gDSFP. I can't remember why.
+          if (workInProgressHook.baseUpdate === queue.last) {
+            workInProgressHook.baseState = newState;
+          }
+
+          return [newState, _dispatch2];
+        }
+      }
+      return [workInProgressHook.memoizedState, _dispatch2];
+    }
+
+    // The last update in the entire queue
+    var _last = queue.last;
+    // The last update that is part of the base state.
+    var _baseUpdate = workInProgressHook.baseUpdate;
+
+    // Find the first unprocessed update.
+    var first = void 0;
+    if (_baseUpdate !== null) {
+      if (_last !== null) {
+        // For the first update, the queue is a circular linked list where
+        // `queue.last.next = queue.first`. Once the first update commits, and
+        // the `baseUpdate` is no longer empty, we can unravel the list.
+        _last.next = null;
+      }
+      first = _baseUpdate.next;
+    } else {
+      first = _last !== null ? _last.next : null;
+    }
+    if (first !== null) {
+      var _newState = workInProgressHook.baseState;
+      var newBaseState = null;
+      var newBaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      var _update = first;
+      var didSkip = false;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        if (updateExpirationTime < renderExpirationTime) {
+          // Priority is insufficient. Skip this update. If this is the first
+          // skipped update, the previous update/state is the new base
+          // update/state.
+          if (!didSkip) {
+            didSkip = true;
+            newBaseUpdate = prevUpdate;
+            newBaseState = _newState;
+          }
+          // Update the remaining priority in the queue.
+          if (updateExpirationTime > remainingExpirationTime) {
+            remainingExpirationTime = updateExpirationTime;
+          }
+        } else {
+          // Process this update.
+          var _action2 = _update.action;
+          _newState = reducer(_newState, _action2);
+        }
+        prevUpdate = _update;
+        _update = _update.next;
+      } while (_update !== null && _update !== first);
+
+      if (!didSkip) {
+        newBaseUpdate = prevUpdate;
+        newBaseState = _newState;
+      }
+
+      workInProgressHook.memoizedState = _newState;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = newBaseState;
+    }
+
+    var _dispatch = queue.dispatch;
+    return [workInProgressHook.memoizedState, _dispatch];
+  }
+
+  // There's no existing queue, so this is the initial render.
+  if (reducer === basicStateReducer) {
+    // Special case for `useState`.
+    if (typeof initialState === "function") {
+      initialState = initialState();
+    }
+  } else if (initialAction !== undefined && initialAction !== null) {
+    initialState = reducer(initialState, initialAction);
+  }
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null
+  };
+  var dispatch = (queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  ));
+  return [workInProgressHook.memoizedState, dispatch];
+}
+
+function pushEffect(tag, create, destroy, inputs) {
+  var effect = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    inputs: inputs,
+    // Circular
+    next: null
+  };
+  if (componentUpdateQueue === null) {
+    componentUpdateQueue = createFunctionComponentUpdateQueue();
+    componentUpdateQueue.lastEffect = effect.next = effect;
+  } else {
+    var _lastEffect = componentUpdateQueue.lastEffect;
+    if (_lastEffect === null) {
+      componentUpdateQueue.lastEffect = effect.next = effect;
+    } else {
+      var firstEffect = _lastEffect.next;
+      _lastEffect.next = effect;
+      effect.next = firstEffect;
+      componentUpdateQueue.lastEffect = effect;
+    }
+  }
+  return effect;
+}
+
+function useRef(initialValue) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var ref = void 0;
+
+  if (workInProgressHook.memoizedState === null) {
+    ref = { current: initialValue };
+    {
+      Object.seal(ref);
+    }
+    workInProgressHook.memoizedState = ref;
+  } else {
+    ref = workInProgressHook.memoizedState;
+  }
+  return ref;
+}
+
+function useMutationEffect(create, inputs) {
+  useEffectImpl(
+    Snapshot | Update,
+    UnmountSnapshot | MountMutation,
+    create,
+    inputs
+  );
+}
+
+function useLayoutEffect(create, inputs) {
+  useEffectImpl(Update, UnmountMutation | MountLayout, create, inputs);
+}
+
+function useEffect(create, inputs) {
+  useEffectImpl(
+    Update | Passive,
+    UnmountPassive | MountPassive,
+    create,
+    inputs
+  );
+}
+
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextInputs = inputs !== undefined && inputs !== null ? inputs : [create];
+  var destroy = null;
+  if (currentHook !== null) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (areHookInputsEqual(nextInputs, prevEffect.inputs)) {
+      pushEffect(NoEffect$1, create, destroy, nextInputs);
+      return;
+    }
+  }
+
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    nextInputs
+  );
+}
+
+function useImperativeMethods(ref, create, inputs) {
+  // TODO: If inputs are provided, should we skip comparing the ref itself?
+  var nextInputs =
+    inputs !== null && inputs !== undefined
+      ? inputs.concat([ref])
+      : [ref, create];
+
+  // TODO: I've implemented this on top of useEffect because it's almost the
+  // same thing, and it would require an equal amount of code. It doesn't seem
+  // like a common enough use case to justify the additional size.
+  useEffectImpl(
+    Update,
+    UnmountMutation | MountLayout,
+    function() {
+      if (typeof ref === "function") {
+        var refCallback = ref;
+        var _inst = create();
+        refCallback(_inst);
+        return function() {
+          return refCallback(null);
+        };
+      } else if (ref !== null && ref !== undefined) {
+        var refObject = ref;
+        var _inst2 = create();
+        refObject.current = _inst2;
+        return function() {
+          refObject.current = null;
+        };
+      }
+    },
+    nextInputs
+  );
+}
+
+function useCallback(callback, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextInputs =
+    inputs !== undefined && inputs !== null ? inputs : [callback];
+
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    var prevInputs = prevState[1];
+    if (areHookInputsEqual(nextInputs, prevInputs)) {
+      return prevState[0];
+    }
+  }
+  workInProgressHook.memoizedState = [callback, nextInputs];
+  return callback;
+}
+
+function useMemo(nextCreate, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextInputs =
+    inputs !== undefined && inputs !== null ? inputs : [nextCreate];
+
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    var prevInputs = prevState[1];
+    if (areHookInputsEqual(nextInputs, prevInputs)) {
+      return prevState[0];
+    }
+  }
+
+  var nextValue = nextCreate();
+  workInProgressHook.memoizedState = [nextValue, nextInputs];
+  return nextValue;
+}
+
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    numberOfReRenders < RE_RENDER_LIMIT,
+    "Too many re-renders. React limits the number of renders to prevent " +
+      "an infinite loop."
+  );
+
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (alternate !== null && alternate === currentlyRenderingFiber$1)
+  ) {
+    // This is a render phase update. Stash it in a lazily-created map of
+    // queue -> linked list of updates. After this render pass, we'll restart
+    // and apply the stashed updates on top of the work-in-progress hook.
+    didScheduleRenderPhaseUpdate = true;
+    var update = {
+      expirationTime: renderExpirationTime,
+      action: action,
+      next: null
+    };
+    if (renderPhaseUpdates === null) {
+      renderPhaseUpdates = new Map();
+    }
+    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+    if (firstRenderPhaseUpdate === undefined) {
+      renderPhaseUpdates.set(queue, update);
+    } else {
+      // Append the update to the end of the list.
+      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
+      while (lastRenderPhaseUpdate.next !== null) {
+        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
+      }
+      lastRenderPhaseUpdate.next = update;
+    }
+  } else {
+    var currentTime = requestCurrentTime();
+    var _expirationTime = computeExpirationForFiber(currentTime, fiber);
+    var _update2 = {
+      expirationTime: _expirationTime,
+      action: action,
+      next: null
+    };
+    flushPassiveEffects();
+    // Append the update to the end of the list.
+    var _last2 = queue.last;
+    if (_last2 === null) {
+      // This is the first update. Create a circular list.
+      _update2.next = _update2;
+    } else {
+      var first = _last2.next;
+      if (first !== null) {
+        // Still circular.
+        _update2.next = first;
+      }
+      _last2.next = _update2;
+    }
+    queue.last = _update2;
+    scheduleWork(fiber, _expirationTime);
+  }
+}
+
+var NO_CONTEXT = {};
+
+var contextStackCursor$1 = createCursor(NO_CONTEXT);
+var contextFiberStackCursor = createCursor(NO_CONTEXT);
+var rootInstanceStackCursor = createCursor(NO_CONTEXT);
+
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug " +
+      "in React. Please file an issue."
+  );
+  return c;
+}
+
+function getRootHostContainer() {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  return rootInstance;
+}
+
+function pushHostContainer(fiber, nextRootInstance) {
+  // Push current root instance onto the stack;
+  // This allows us to reset root when portals are popped.
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+
+  // Finally, we need to push the host context to the stack.
+  // However, we can't just call getRootHostContext() and push it because
+  // we'd have a different number of entries on the stack depending on
+  // whether getRootHostContext() throws somewhere in renderer code or not.
+  // So we push an empty value first. This lets us safely unwind on errors.
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  var nextRootContext = getRootHostContext(nextRootInstance);
+  // Now that we know this function doesn't throw, replace it.
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, nextRootContext, fiber);
+}
+
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+
+function getHostContext() {
+  var context = requiredContext(contextStackCursor$1.current);
+  return context;
+}
+
+function pushHostContext(fiber) {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+
+  // Don't push this Fiber's context unless it's unique.
+  if (context === nextContext) {
+    return;
+  }
+
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, nextContext, fiber);
+}
+
+function popHostContext(fiber) {
+  // Do not pop unless this Fiber provided the current context.
+  // pushHostContext() only pushes Fibers that provide unique contexts.
+  if (contextFiberStackCursor.current !== fiber) {
+    return;
+  }
+
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+}
+
+var commitTime = 0;
+var profilerStartTime = -1;
+
+function getCommitTime() {
+  return commitTime;
+}
+
+function recordCommitTime() {
+  if (!enableProfilerTimer) {
+    return;
+  }
+  commitTime = now();
+}
+
+function startProfilerTimer(fiber) {
+  if (!enableProfilerTimer) {
+    return;
+  }
+
+  profilerStartTime = now();
+
+  if (fiber.actualStartTime < 0) {
+    fiber.actualStartTime = now();
+  }
+}
+
+function stopProfilerTimerIfRunning(fiber) {
+  if (!enableProfilerTimer) {
+    return;
+  }
+  profilerStartTime = -1;
+}
+
+function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
+  if (!enableProfilerTimer) {
+    return;
+  }
+
+  if (profilerStartTime >= 0) {
+    var elapsedTime = now() - profilerStartTime;
+    fiber.actualDuration += elapsedTime;
+    if (overrideBaseTime) {
+      fiber.selfBaseDuration = elapsedTime;
+    }
+    profilerStartTime = -1;
+  }
+}
+
+/*eslint-disable no-self-compare */
+
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+/**
+ * inlined Object.is polyfill to avoid requiring consumers ship their own
  * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  */
 function is(x, y) {
@@ -7318,7 +7964,81 @@ function shallowEqual(objA, objB) {
     }
   }
 
-  return true;
+  return true;
+}
+
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    // Resolve default props. Taken from ReactElement
+    var props = Object.assign({}, baseProps);
+    var defaultProps = Component.defaultProps;
+    for (var propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props;
+  }
+  return baseProps;
+}
+
+function readLazyComponentType(lazyComponent) {
+  var status = lazyComponent._status;
+  var result = lazyComponent._result;
+  switch (status) {
+    case Resolved: {
+      var Component = result;
+      return Component;
+    }
+    case Rejected: {
+      var error = result;
+      throw error;
+    }
+    case Pending: {
+      var thenable = result;
+      throw thenable;
+    }
+    default: {
+      lazyComponent._status = Pending;
+      var ctor = lazyComponent._ctor;
+      var _thenable = ctor();
+      _thenable.then(
+        function(moduleObject) {
+          if (lazyComponent._status === Pending) {
+            var defaultExport = moduleObject.default;
+            {
+              if (defaultExport === undefined) {
+                warning$1(
+                  false,
+                  "lazy: Expected the result of a dynamic import() call. " +
+                    "Instead received: %s\n\nYour code should look like: \n  " +
+                    "const MyComponent = lazy(() => import('./MyComponent'))",
+                  moduleObject
+                );
+              }
+            }
+            lazyComponent._status = Resolved;
+            lazyComponent._result = defaultExport;
+          }
+        },
+        function(error) {
+          if (lazyComponent._status === Pending) {
+            lazyComponent._status = Rejected;
+            lazyComponent._result = error;
+          }
+        }
+      );
+      lazyComponent._result = _thenable;
+      throw _thenable;
+    }
+  }
+}
+
+var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner;
+
+function readContext$1(contextType) {
+  var dispatcher = ReactCurrentOwner$4.currentDispatcher;
+  return dispatcher.readContext(contextType);
 }
 
 var fakeInternalInstance = {};
@@ -7460,6 +8180,7 @@ var classComponentUpdater = {
       update.callback = callback;
     }
 
+    flushPassiveEffects();
     enqueueUpdate(fiber, update);
     scheduleWork(fiber, expirationTime);
   },
@@ -7479,6 +8200,7 @@ var classComponentUpdater = {
       update.callback = callback;
     }
 
+    flushPassiveEffects();
     enqueueUpdate(fiber, update);
     scheduleWork(fiber, expirationTime);
   },
@@ -7497,6 +8219,7 @@ var classComponentUpdater = {
       update.callback = callback;
     }
 
+    flushPassiveEffects();
     enqueueUpdate(fiber, update);
     scheduleWork(fiber, expirationTime);
   }
@@ -7813,7 +8536,7 @@ function constructClassInstance(
   if (typeof contextType === "object" && contextType !== null) {
     {
       if (
-        typeof contextType.unstable_read !== "function" &&
+        contextType.$$typeof !== REACT_CONTEXT_TYPE &&
         !didWarnAboutInvalidateContextType.has(ctor)
       ) {
         didWarnAboutInvalidateContextType.add(ctor);
@@ -7827,7 +8550,7 @@ function constructClassInstance(
       }
     }
 
-    context = contextType.unstable_read();
+    context = readContext$1(contextType);
   } else {
     unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
     var contextTypes = ctor.contextTypes;
@@ -8029,7 +8752,7 @@ function mountClassInstance(
 
   var contextType = ctor.contextType;
   if (typeof contextType === "object" && contextType !== null) {
-    instance.context = contextType.unstable_read();
+    instance.context = readContext$1(contextType);
   } else {
     var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
     instance.context = getMaskedContext(workInProgress, unmaskedContext);
@@ -8137,7 +8860,7 @@ function resumeMountClassInstance(
   var contextType = ctor.contextType;
   var nextContext = void 0;
   if (typeof contextType === "object" && contextType !== null) {
-    nextContext = contextType.unstable_read();
+    nextContext = readContext$1(contextType);
   } else {
     var nextLegacyUnmaskedContext = getUnmaskedContext(
       workInProgress,
@@ -8277,13 +9000,16 @@ function updateClassInstance(
   var instance = workInProgress.stateNode;
 
   var oldProps = workInProgress.memoizedProps;
-  instance.props = oldProps;
+  instance.props =
+    workInProgress.type === workInProgress.elementType
+      ? oldProps
+      : resolveDefaultProps(workInProgress.type, oldProps);
 
   var oldContext = instance.context;
   var contextType = ctor.contextType;
   var nextContext = void 0;
   if (typeof contextType === "object" && contextType !== null) {
-    nextContext = contextType.unstable_read();
+    nextContext = readContext$1(contextType);
   } else {
     var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
     nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
@@ -8526,8 +9252,7 @@ function coerceRef(returnFiber, current$$1, element) {
       if (owner) {
         var ownerFiber = owner;
         invariant(
-          ownerFiber.tag === ClassComponent ||
-            ownerFiber.tag === ClassComponentLazy,
+          ownerFiber.tag === ClassComponent,
           "Function components cannot have refs."
         );
         inst = ownerFiber.stateNode;
@@ -8747,7 +9472,7 @@ function ChildReconciler(shouldTrackSideEffects) {
   }
 
   function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (current$$1 !== null && current$$1.type === element.type) {
+    if (current$$1 !== null && current$$1.elementType === element.type) {
       // Move based on index
       var existing = useFiber(current$$1, element.props, expirationTime);
       existing.ref = coerceRef(returnFiber, current$$1, element);
@@ -9485,7 +10210,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         if (
           child.tag === Fragment
             ? element.type === REACT_FRAGMENT_TYPE
-            : child.type === element.type
+            : child.elementType === element.type
         ) {
           deleteRemainingChildren(returnFiber, child.sibling);
           var existing = useFiber(
@@ -9668,8 +10393,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       // component, throw an error. If Fiber return types are disabled,
       // we already threw above.
       switch (returnFiber.tag) {
-        case ClassComponent:
-        case ClassComponentLazy: {
+        case ClassComponent: {
           {
             var instance = returnFiber.stateNode;
             if (instance.render._isMockFunction) {
@@ -10052,49 +10776,6 @@ function resetHydrationState() {
   isHydrating = false;
 }
 
-function readLazyComponentType(thenable) {
-  var status = thenable._reactStatus;
-  switch (status) {
-    case Resolved:
-      var Component = thenable._reactResult;
-      return Component;
-    case Rejected:
-      throw thenable._reactResult;
-    case Pending:
-      throw thenable;
-    default: {
-      thenable._reactStatus = Pending;
-      thenable.then(
-        function(resolvedValue) {
-          if (thenable._reactStatus === Pending) {
-            thenable._reactStatus = Resolved;
-            if (typeof resolvedValue === "object" && resolvedValue !== null) {
-              // If the `default` property is not empty, assume it's the result
-              // of an async import() and use that. Otherwise, use the
-              // resolved value itself.
-              var defaultExport = resolvedValue.default;
-              resolvedValue =
-                defaultExport !== undefined && defaultExport !== null
-                  ? defaultExport
-                  : resolvedValue;
-            } else {
-              resolvedValue = resolvedValue;
-            }
-            thenable._reactResult = resolvedValue;
-          }
-        },
-        function(error) {
-          if (thenable._reactStatus === Pending) {
-            thenable._reactStatus = Rejected;
-            thenable._reactResult = error;
-          }
-        }
-      );
-      throw thenable;
-    }
-  }
-}
-
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 
 var didWarnAboutBadClass = void 0;
@@ -10177,45 +10858,37 @@ function forceUnmountCurrentAndReconcile(
 function updateForwardRef(
   current$$1,
   workInProgress,
-  type,
+  Component,
   nextProps,
   renderExpirationTime
 ) {
-  var render = type.render;
+  var render = Component.render;
   var ref = workInProgress.ref;
-  if (hasContextChanged()) {
-    // Normally we can bail out on props equality but if context has changed
-    // we don't do the bailout and we have to reuse existing props instead.
-  } else if (workInProgress.memoizedProps === nextProps) {
-    var currentRef = current$$1 !== null ? current$$1.ref : null;
-    if (ref === currentRef) {
-      return bailoutOnAlreadyFinishedWork(
-        current$$1,
-        workInProgress,
-        renderExpirationTime
-      );
-    }
-  }
 
+  // The rest is a fork of updateFunctionComponent
   var nextChildren = void 0;
+  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
     nextChildren = render(nextProps, ref);
     setCurrentPhase(null);
   }
+  nextChildren = finishHooks(render, nextProps, nextChildren, ref);
 
+  // React DevTools reads this flag.
+  workInProgress.effectTag |= PerformedWork;
   reconcileChildren(
     current$$1,
     workInProgress,
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
-function updatePureComponent(
+function updateMemoComponent(
   current$$1,
   workInProgress,
   Component,
@@ -10223,18 +10896,51 @@ function updatePureComponent(
   updateExpirationTime,
   renderExpirationTime
 ) {
-  var render = Component.render;
-
-  if (
-    current$$1 !== null &&
-    (updateExpirationTime === NoWork ||
-      updateExpirationTime > renderExpirationTime)
-  ) {
-    var prevProps = current$$1.memoizedProps;
+  if (current$$1 === null) {
+    var type = Component.type;
+    if (isSimpleFunctionComponent(type) && Component.compare === null) {
+      // If this is a plain function component without default props,
+      // and with only the default shallow comparison, we upgrade it
+      // to a SimpleMemoComponent to allow fast path updates.
+      workInProgress.tag = SimpleMemoComponent;
+      workInProgress.type = type;
+      {
+        validateFunctionComponentInDev(workInProgress, type);
+      }
+      return updateSimpleMemoComponent(
+        current$$1,
+        workInProgress,
+        type,
+        nextProps,
+        updateExpirationTime,
+        renderExpirationTime
+      );
+    }
+    var child = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      null,
+      workInProgress.mode,
+      renderExpirationTime
+    );
+    child.ref = workInProgress.ref;
+    child.return = workInProgress;
+    workInProgress.child = child;
+    return child;
+  }
+  var currentChild = current$$1.child; // This is always exactly one child
+  if (updateExpirationTime < renderExpirationTime) {
+    // This will be the props with resolved defaultProps,
+    // unlike current.memoizedProps which will be the unresolved ones.
+    var prevProps = currentChild.memoizedProps;
     // Default to shallow comparison
     var compare = Component.compare;
     compare = compare !== null ? compare : shallowEqual;
-    if (compare(prevProps, nextProps)) {
+    if (
+      compare(prevProps, nextProps) &&
+      current$$1.ref === workInProgress.ref
+    ) {
       return bailoutOnAlreadyFinishedWork(
         current$$1,
         workInProgress,
@@ -10242,27 +10948,47 @@ function updatePureComponent(
       );
     }
   }
-
-  // The rest is a fork of updateFunctionComponent
-  var nextChildren = void 0;
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  {
-    ReactCurrentOwner$3.current = workInProgress;
-    setCurrentPhase("render");
-    nextChildren = render(nextProps);
-    setCurrentPhase(null);
-  }
-
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(
+  var newChild = createWorkInProgress(
+    currentChild,
+    nextProps,
+    renderExpirationTime
+  );
+  newChild.ref = workInProgress.ref;
+  newChild.return = workInProgress;
+  workInProgress.child = newChild;
+  return newChild;
+}
+
+function updateSimpleMemoComponent(
+  current$$1,
+  workInProgress,
+  Component,
+  nextProps,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  if (current$$1 !== null && updateExpirationTime < renderExpirationTime) {
+    var prevProps = current$$1.memoizedProps;
+    if (
+      shallowEqual(prevProps, nextProps) &&
+      current$$1.ref === workInProgress.ref
+    ) {
+      return bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      );
+    }
+  }
+  return updateFunctionComponent(
     current$$1,
     workInProgress,
-    nextChildren,
+    Component,
+    nextProps,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
-  return workInProgress.child;
 }
 
 function updateFragment(current$$1, workInProgress, renderExpirationTime) {
@@ -10273,7 +10999,6 @@ function updateFragment(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextChildren);
   return workInProgress.child;
 }
 
@@ -10285,7 +11010,6 @@ function updateMode(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextChildren);
   return workInProgress.child;
 }
 
@@ -10301,7 +11025,6 @@ function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
@@ -10328,12 +11051,14 @@ function updateFunctionComponent(
 
   var nextChildren = void 0;
   prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
     nextChildren = Component(nextProps, context);
     setCurrentPhase(null);
   }
+  nextChildren = finishHooks(Component, nextProps, nextChildren, context);
 
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -10343,7 +11068,6 @@ function updateFunctionComponent(
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
@@ -10366,32 +11090,41 @@ function updateClassComponent(
   }
   prepareToReadContext(workInProgress, renderExpirationTime);
 
+  var instance = workInProgress.stateNode;
   var shouldUpdate = void 0;
-  if (current$$1 === null) {
-    if (workInProgress.stateNode === null) {
-      // In the initial pass we might need to construct the instance.
-      constructClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      );
-      mountClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      );
-      shouldUpdate = true;
-    } else {
-      // In a resume, we'll already have an instance we can reuse.
-      shouldUpdate = resumeMountClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      );
-    }
+  if (instance === null) {
+    if (current$$1 !== null) {
+      // An class component without an instance only mounts if it suspended
+      // inside a non- concurrent tree, in an inconsistent state. We want to
+      // tree it like a new mount, even though an empty version of it already
+      // committed. Disconnect the alternate pointers.
+      current$$1.alternate = null;
+      workInProgress.alternate = null;
+      // Since this is conceptually a new fiber, schedule a Placement effect
+      workInProgress.effectTag |= Placement;
+    }
+    // In the initial pass we might need to construct the instance.
+    constructClassInstance(
+      workInProgress,
+      Component,
+      nextProps,
+      renderExpirationTime
+    );
+    mountClassInstance(
+      workInProgress,
+      Component,
+      nextProps,
+      renderExpirationTime
+    );
+    shouldUpdate = true;
+  } else if (current$$1 === null) {
+    // In a resume, we'll already have an instance we can reuse.
+    shouldUpdate = resumeMountClassInstance(
+      workInProgress,
+      Component,
+      nextProps,
+      renderExpirationTime
+    );
   } else {
     shouldUpdate = updateClassInstance(
       current$$1,
@@ -10493,10 +11226,9 @@ function finishClassComponent(
     );
   }
 
-  // Memoize props and state using the values we just used to render.
+  // Memoize state using the values we just used to render.
   // TODO: Restructure so we never read values from the instance.
-  memoizeState(workInProgress, instance.state);
-  memoizeProps(workInProgress, instance.props);
+  workInProgress.memoizedState = instance.state;
 
   // The context might have changed so we need to recalculate it.
   if (hasContext) {
@@ -10630,7 +11362,6 @@ function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
   ) {
     // Schedule this fiber to re-render at offscreen priority. Then bailout.
     workInProgress.expirationTime = Never;
-    workInProgress.memoizedProps = nextProps;
     return null;
   }
 
@@ -10640,7 +11371,6 @@ function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
@@ -10648,116 +11378,178 @@ function updateHostText(current$$1, workInProgress) {
   if (current$$1 === null) {
     tryToClaimNextHydratableInstance(workInProgress);
   }
-  var nextProps = workInProgress.pendingProps;
-  memoizeProps(workInProgress, nextProps);
   // Nothing to do here. This is terminal. We'll do the completion step
   // immediately after.
   return null;
 }
 
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
-    var props = Object.assign({}, baseProps);
-    var defaultProps = Component.defaultProps;
-    for (var propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
-      }
+function mountLazyComponent(
+  _current,
+  workInProgress,
+  elementType,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  if (_current !== null) {
+    // An lazy component only mounts if it suspended inside a non-
+    // concurrent tree, in an inconsistent state. We want to treat it like
+    // a new mount, even though an empty version of it already committed.
+    // Disconnect the alternate pointers.
+    _current.alternate = null;
+    workInProgress.alternate = null;
+    // Since this is conceptually a new fiber, schedule a Placement effect
+    workInProgress.effectTag |= Placement;
+  }
+
+  var props = workInProgress.pendingProps;
+  // We can't start a User Timing measurement with correct label yet.
+  // Cancel and resume right after we know the tag.
+  cancelWorkTimer(workInProgress);
+  var Component = readLazyComponentType(elementType);
+  // Store the unwrapped component in the type.
+  workInProgress.type = Component;
+  var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));
+  startWorkTimer(workInProgress);
+  var resolvedProps = resolveDefaultProps(Component, props);
+  var child = void 0;
+  switch (resolvedTag) {
+    case FunctionComponent: {
+      child = updateFunctionComponent(
+        null,
+        workInProgress,
+        Component,
+        resolvedProps,
+        renderExpirationTime
+      );
+      break;
+    }
+    case ClassComponent: {
+      child = updateClassComponent(
+        null,
+        workInProgress,
+        Component,
+        resolvedProps,
+        renderExpirationTime
+      );
+      break;
+    }
+    case ForwardRef: {
+      child = updateForwardRef(
+        null,
+        workInProgress,
+        Component,
+        resolvedProps,
+        renderExpirationTime
+      );
+      break;
+    }
+    case MemoComponent: {
+      child = updateMemoComponent(
+        null,
+        workInProgress,
+        Component,
+        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
+        updateExpirationTime,
+        renderExpirationTime
+      );
+      break;
+    }
+    default: {
+      // This message intentionally doesn't mention ForwardRef or MemoComponent
+      // because the fact that it's a separate type of work is an
+      // implementation detail.
+      invariant(
+        false,
+        "Element type is invalid. Received a promise that resolves to: %s. " +
+          "Promise elements must resolve to a class or function.",
+        Component
+      );
     }
-    return props;
   }
-  return baseProps;
+  return child;
 }
 
-function mountIndeterminateComponent(
-  current$$1,
+function mountIncompleteClassComponent(
+  _current,
   workInProgress,
   Component,
-  updateExpirationTime,
+  nextProps,
   renderExpirationTime
 ) {
-  invariant(
-    current$$1 === null,
-    "An indeterminate component should never have mounted. This error is " +
-      "likely caused by a bug in React. Please file an issue."
-  );
+  if (_current !== null) {
+    // An incomplete component only mounts if it suspended inside a non-
+    // concurrent tree, in an inconsistent state. We want to treat it like
+    // a new mount, even though an empty version of it already committed.
+    // Disconnect the alternate pointers.
+    _current.alternate = null;
+    workInProgress.alternate = null;
+    // Since this is conceptually a new fiber, schedule a Placement effect
+    workInProgress.effectTag |= Placement;
+  }
 
-  var props = workInProgress.pendingProps;
-  if (
-    typeof Component === "object" &&
-    Component !== null &&
-    typeof Component.then === "function"
-  ) {
-    Component = readLazyComponentType(Component);
-    var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(
-      workInProgress,
-      Component
-    ));
-    var resolvedProps = resolveDefaultProps(Component, props);
-    var child = void 0;
-    switch (resolvedTag) {
-      case FunctionComponentLazy: {
-        child = updateFunctionComponent(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          renderExpirationTime
-        );
-        break;
-      }
-      case ClassComponentLazy: {
-        child = updateClassComponent(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          renderExpirationTime
-        );
-        break;
-      }
-      case ForwardRefLazy: {
-        child = updateForwardRef(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          renderExpirationTime
-        );
-        break;
-      }
-      case PureComponentLazy: {
-        child = updatePureComponent(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          updateExpirationTime,
-          renderExpirationTime
-        );
-        break;
-      }
-      default: {
-        // This message intentionally doesn't metion ForwardRef or PureComponent
-        // because the fact that it's a separate type of work is an
-        // implementation detail.
-        invariant(
-          false,
-          "Element type is invalid. Received a promise that resolves to: %s. " +
-            "Promise elements must resolve to a class or function.",
-          Component
-        );
-      }
-    }
-    workInProgress.memoizedProps = props;
-    return child;
+  // Promote the fiber to a class and try rendering again.
+  workInProgress.tag = ClassComponent;
+
+  // The rest of this function is a fork of `updateClassComponent`
+
+  // Push context providers early to prevent context stack mismatches.
+  // During mounting we don't know the child context yet as the instance doesn't exist.
+  // We will invalidate the child context in finishClassComponent() right after rendering.
+  var hasContext = void 0;
+  if (isContextProvider(Component)) {
+    hasContext = true;
+    pushContextProvider(workInProgress);
+  } else {
+    hasContext = false;
+  }
+  prepareToReadContext(workInProgress, renderExpirationTime);
+
+  constructClassInstance(
+    workInProgress,
+    Component,
+    nextProps,
+    renderExpirationTime
+  );
+  mountClassInstance(
+    workInProgress,
+    Component,
+    nextProps,
+    renderExpirationTime
+  );
+
+  return finishClassComponent(
+    null,
+    workInProgress,
+    Component,
+    true,
+    hasContext,
+    renderExpirationTime
+  );
+}
+
+function mountIndeterminateComponent(
+  _current,
+  workInProgress,
+  Component,
+  renderExpirationTime
+) {
+  if (_current !== null) {
+    // An indeterminate component only mounts if it suspended inside a non-
+    // concurrent tree, in an inconsistent state. We want to treat it like
+    // a new mount, even though an empty version of it already committed.
+    // Disconnect the alternate pointers.
+    _current.alternate = null;
+    workInProgress.alternate = null;
+    // Since this is conceptually a new fiber, schedule a Placement effect
+    workInProgress.effectTag |= Placement;
   }
 
+  var props = workInProgress.pendingProps;
   var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
   var context = getMaskedContext(workInProgress, unmaskedContext);
 
   prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToUseHooks(null, workInProgress, renderExpirationTime);
 
   var value = void 0;
 
@@ -10799,6 +11591,9 @@ function mountIndeterminateComponent(
     // Proceed under the assumption that this is a class instance
     workInProgress.tag = ClassComponent;
 
+    // Throw out any hooks that were used.
+    resetHooks();
+
     // Push context providers early to prevent context stack mismatches.
     // During mounting we don't know the child context yet as the instance doesn't exist.
     // We will invalidate the child context in finishClassComponent() right after rendering.
@@ -10826,7 +11621,7 @@ function mountIndeterminateComponent(
     adoptClassInstance(workInProgress, value);
     mountClassInstance(workInProgress, Component, props, renderExpirationTime);
     return finishClassComponent(
-      current$$1,
+      null,
       workInProgress,
       Component,
       true,
@@ -10836,147 +11631,336 @@ function mountIndeterminateComponent(
   } else {
     // Proceed under the assumption that this is a function component
     workInProgress.tag = FunctionComponent;
+    value = finishHooks(Component, props, value, context);
+    reconcileChildren(null, workInProgress, value, renderExpirationTime);
     {
-      if (Component) {
-        !!Component.childContextTypes
-          ? warningWithoutStack$1(
-              false,
-              "%s(...): childContextTypes cannot be defined on a function component.",
-              Component.displayName || Component.name || "Component"
-            )
-          : void 0;
-      }
-      if (workInProgress.ref !== null) {
-        var info = "";
-        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
-        if (ownerName) {
-          info += "\n\nCheck the render method of `" + ownerName + "`.";
-        }
+      validateFunctionComponentInDev(workInProgress, Component);
+    }
+    return workInProgress.child;
+  }
+}
 
-        var warningKey = ownerName || workInProgress._debugID || "";
-        var debugSource = workInProgress._debugSource;
-        if (debugSource) {
-          warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
-        }
-        if (!didWarnAboutFunctionRefs[warningKey]) {
-          didWarnAboutFunctionRefs[warningKey] = true;
-          warning$1(
-            false,
-            "Function components cannot be given refs. " +
-              "Attempts to access this ref will fail.%s",
-            info
-          );
-        }
-      }
+function validateFunctionComponentInDev(workInProgress, Component) {
+  if (Component) {
+    !!Component.childContextTypes
+      ? warningWithoutStack$1(
+          false,
+          "%s(...): childContextTypes cannot be defined on a function component.",
+          Component.displayName || Component.name || "Component"
+        )
+      : void 0;
+  }
+  if (workInProgress.ref !== null) {
+    var info = "";
+    var ownerName = getCurrentFiberOwnerNameInDevOrNull();
+    if (ownerName) {
+      info += "\n\nCheck the render method of `" + ownerName + "`.";
+    }
 
-      if (typeof Component.getDerivedStateFromProps === "function") {
-        var _componentName = getComponentName(Component) || "Unknown";
+    var warningKey = ownerName || workInProgress._debugID || "";
+    var debugSource = workInProgress._debugSource;
+    if (debugSource) {
+      warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
+    }
+    if (!didWarnAboutFunctionRefs[warningKey]) {
+      didWarnAboutFunctionRefs[warningKey] = true;
+      warning$1(
+        false,
+        "Function components cannot be given refs. " +
+          "Attempts to access this ref will fail.%s",
+        info
+      );
+    }
+  }
 
-        if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName]) {
-          warningWithoutStack$1(
-            false,
-            "%s: Function components do not support getDerivedStateFromProps.",
-            _componentName
-          );
-          didWarnAboutGetDerivedStateOnFunctionComponent[_componentName] = true;
-        }
-      }
+  if (typeof Component.getDerivedStateFromProps === "function") {
+    var componentName = getComponentName(Component) || "Unknown";
 
-      if (
-        typeof Component.contextType === "object" &&
-        Component.contextType !== null
-      ) {
-        var _componentName2 = getComponentName(Component) || "Unknown";
+    if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {
+      warningWithoutStack$1(
+        false,
+        "%s: Function components do not support getDerivedStateFromProps.",
+        componentName
+      );
+      didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;
+    }
+  }
 
-        if (!didWarnAboutContextTypeOnFunctionComponent[_componentName2]) {
-          warningWithoutStack$1(
-            false,
-            "%s: Function components do not support contextType.",
-            _componentName2
-          );
-          didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true;
-        }
-      }
+  if (
+    typeof Component.contextType === "object" &&
+    Component.contextType !== null
+  ) {
+    var _componentName = getComponentName(Component) || "Unknown";
+
+    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName]) {
+      warningWithoutStack$1(
+        false,
+        "%s: Function components do not support contextType.",
+        _componentName
+      );
+      didWarnAboutContextTypeOnFunctionComponent[_componentName] = true;
     }
-    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);
-    memoizeProps(workInProgress, props);
-    return workInProgress.child;
   }
 }
 
-function updatePlaceholderComponent(
+function updateSuspenseComponent(
   current$$1,
   workInProgress,
   renderExpirationTime
 ) {
-  if (enableSuspense) {
-    var nextProps = workInProgress.pendingProps;
-
-    // Check if we already attempted to render the normal state. If we did,
-    // and we timed out, render the placeholder state.
-    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;
-
-    var nextDidTimeout = void 0;
-    if (current$$1 !== null && workInProgress.updateQueue !== null) {
-      // We're outside strict mode. Something inside this Placeholder boundary
-      // suspended during the last commit. Switch to the placholder.
-      workInProgress.updateQueue = null;
-      nextDidTimeout = true;
-    } else {
-      nextDidTimeout = !alreadyCaptured;
-    }
+  var mode = workInProgress.mode;
+  var nextProps = workInProgress.pendingProps;
 
-    if ((workInProgress.mode & StrictMode) !== NoEffect) {
-      if (nextDidTimeout) {
-        // If the timed-out view commits, schedule an update effect to record
-        // the committed time.
-        workInProgress.effectTag |= Update;
-      } else {
-        // The state node points to the time at which placeholder timed out.
-        // We can clear it once we switch back to the normal children.
-        workInProgress.stateNode = null;
-      }
-    }
+  // We should attempt to render the primary children unless this boundary
+  // already suspended during this render (`alreadyCaptured` is true).
+  var nextState = workInProgress.memoizedState;
 
-    // If the `children` prop is a function, treat it like a render prop.
-    // TODO: This is temporary until we finalize a lower level API.
-    var children = nextProps.children;
-    var nextChildren = void 0;
-    if (typeof children === "function") {
-      nextChildren = children(nextDidTimeout);
-    } else {
-      nextChildren = nextDidTimeout ? nextProps.fallback : children;
-    }
+  var nextDidTimeout = void 0;
+  if ((workInProgress.effectTag & DidCapture) === NoEffect) {
+    // This is the first attempt.
+    nextState = null;
+    nextDidTimeout = false;
+  } else {
+    // Something in this boundary's subtree already suspended. Switch to
+    // rendering the fallback children.
+    nextState = {
+      timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
+    };
+    nextDidTimeout = true;
+    workInProgress.effectTag &= ~DidCapture;
+  }
+
+  // This next part is a bit confusing. If the children timeout, we switch to
+  // showing the fallback children in place of the "primary" children.
+  // However, we don't want to delete the primary children because then their
+  // state will be lost (both the React state and the host state, e.g.
+  // uncontrolled form inputs). Instead we keep them mounted and hide them.
+  // Both the fallback children AND the primary children are rendered at the
+  // same time. Once the primary children are un-suspended, we can delete
+  // the fallback children — don't need to preserve their state.
+  //
+  // The two sets of children are siblings in the host environment, but
+  // semantically, for purposes of reconciliation, they are two separate sets.
+  // So we store them using two fragment fibers.
+  //
+  // However, we want to avoid allocating extra fibers for every placeholder.
+  // They're only necessary when the children time out, because that's the
+  // only time when both sets are mounted.
+  //
+  // So, the extra fragment fibers are only used if the children time out.
+  // Otherwise, we render the primary children directly. This requires some
+  // custom reconciliation logic to preserve the state of the primary
+  // children. It's essentially a very basic form of re-parenting.
+
+  // `child` points to the child fiber. In the normal case, this is the first
+  // fiber of the primary children set. In the timed-out case, it's a
+  // a fragment fiber containing the primary children.
+  var child = void 0;
+  // `next` points to the next fiber React should render. In the normal case,
+  // it's the same as `child`: the first fiber of the primary children set.
+  // In the timed-out case, it's a fragment fiber containing the *fallback*
+  // children -- we skip over the primary children entirely.
+  var next = void 0;
+  if (current$$1 === null) {
+    // This is the initial mount. This branch is pretty simple because there's
+    // no previous state that needs to be preserved.
+    if (nextDidTimeout) {
+      // Mount separate fragments for primary and fallback children.
+      var nextFallbackChildren = nextProps.fallback;
+      var primaryChildFragment = createFiberFromFragment(
+        null,
+        mode,
+        NoWork,
+        null
+      );
 
-    if (
-      current$$1 !== null &&
-      nextDidTimeout !== workInProgress.memoizedState
-    ) {
-      // We're about to switch from the placeholder children to the normal
-      // children, or vice versa. These are two different conceptual sets that
-      // happen to be stored in the same set. Call this special function to
-      // force the new set not to match with the current set.
-      // TODO: The proper way to model this is by storing each set separately.
-      forceUnmountCurrentAndReconcile(
-        current$$1,
-        workInProgress,
-        nextChildren,
-        renderExpirationTime
+      if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+        // Outside of concurrent mode, we commit the effects from the
+        var progressedState = workInProgress.memoizedState;
+        var progressedPrimaryChild =
+          progressedState !== null
+            ? workInProgress.child.child
+            : workInProgress.child;
+        primaryChildFragment.child = progressedPrimaryChild;
+      }
+
+      var fallbackChildFragment = createFiberFromFragment(
+        nextFallbackChildren,
+        mode,
+        renderExpirationTime,
+        null
       );
+      primaryChildFragment.sibling = fallbackChildFragment;
+      child = primaryChildFragment;
+      // Skip the primary children, and continue working on the
+      // fallback children.
+      next = fallbackChildFragment;
+      child.return = next.return = workInProgress;
     } else {
-      reconcileChildren(
-        current$$1,
+      // Mount the primary children without an intermediate fragment fiber.
+      var nextPrimaryChildren = nextProps.children;
+      child = next = mountChildFibers(
         workInProgress,
-        nextChildren,
+        null,
+        nextPrimaryChildren,
         renderExpirationTime
       );
     }
-    workInProgress.memoizedProps = nextProps;
-    workInProgress.memoizedState = nextDidTimeout;
-    return workInProgress.child;
   } else {
-    return null;
+    // This is an update. This branch is more complicated because we need to
+    // ensure the state of the primary children is preserved.
+    var prevState = current$$1.memoizedState;
+    var prevDidTimeout = prevState !== null;
+    if (prevDidTimeout) {
+      // The current tree already timed out. That means each child set is
+      var currentPrimaryChildFragment = current$$1.child;
+      var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
+      if (nextDidTimeout) {
+        // Still timed out. Reuse the current primary children by cloning
+        // its fragment. We're going to skip over these entirely.
+        var _nextFallbackChildren = nextProps.fallback;
+        var _primaryChildFragment = createWorkInProgress(
+          currentPrimaryChildFragment,
+          currentPrimaryChildFragment.pendingProps,
+          NoWork
+        );
+
+        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+          // Outside of concurrent mode, we commit the effects from the
+          var _progressedState = workInProgress.memoizedState;
+          var _progressedPrimaryChild =
+            _progressedState !== null
+              ? workInProgress.child.child
+              : workInProgress.child;
+          if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
+            _primaryChildFragment.child = _progressedPrimaryChild;
+          }
+        }
+
+        // Because primaryChildFragment is a new fiber that we're inserting as the
+        // parent of a new tree, we need to set its treeBaseDuration.
+        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
+          // treeBaseDuration is the sum of all the child tree base durations.
+          var treeBaseDuration = 0;
+          var hiddenChild = _primaryChildFragment.child;
+          while (hiddenChild !== null) {
+            treeBaseDuration += hiddenChild.treeBaseDuration;
+            hiddenChild = hiddenChild.sibling;
+          }
+          _primaryChildFragment.treeBaseDuration = treeBaseDuration;
+        }
+
+        // Clone the fallback child fragment, too. These we'll continue
+        // working on.
+        var _fallbackChildFragment = (_primaryChildFragment.sibling = createWorkInProgress(
+          currentFallbackChildFragment,
+          _nextFallbackChildren,
+          currentFallbackChildFragment.expirationTime
+        ));
+        child = _primaryChildFragment;
+        _primaryChildFragment.childExpirationTime = NoWork;
+        // Skip the primary children, and continue working on the
+        // fallback children.
+        next = _fallbackChildFragment;
+        child.return = next.return = workInProgress;
+      } else {
+        // No longer suspended. Switch back to showing the primary children,
+        // and remove the intermediate fragment fiber.
+        var _nextPrimaryChildren = nextProps.children;
+        var currentPrimaryChild = currentPrimaryChildFragment.child;
+        var primaryChild = reconcileChildFibers(
+          workInProgress,
+          currentPrimaryChild,
+          _nextPrimaryChildren,
+          renderExpirationTime
+        );
+
+        // If this render doesn't suspend, we need to delete the fallback
+        // children. Wait until the complete phase, after we've confirmed the
+        // fallback is no longer needed.
+        // TODO: Would it be better to store the fallback fragment on
+        // the stateNode?
+
+        // Continue rendering the children, like we normally do.
+        child = next = primaryChild;
+      }
+    } else {
+      // The current tree has not already timed out. That means the primary
+      // children are not wrapped in a fragment fiber.
+      var _currentPrimaryChild = current$$1.child;
+      if (nextDidTimeout) {
+        // Timed out. Wrap the children in a fragment fiber to keep them
+        // separate from the fallback children.
+        var _nextFallbackChildren2 = nextProps.fallback;
+        var _primaryChildFragment2 = createFiberFromFragment(
+          // It shouldn't matter what the pending props are because we aren't
+          // going to render this fragment.
+          null,
+          mode,
+          NoWork,
+          null
+        );
+        _primaryChildFragment2.child = _currentPrimaryChild;
+
+        // Even though we're creating a new fiber, there are no new children,
+        // because we're reusing an already mounted tree. So we don't need to
+        // schedule a placement.
+        // primaryChildFragment.effectTag |= Placement;
+
+        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+          // Outside of concurrent mode, we commit the effects from the
+          var _progressedState2 = workInProgress.memoizedState;
+          var _progressedPrimaryChild2 =
+            _progressedState2 !== null
+              ? workInProgress.child.child
+              : workInProgress.child;
+          _primaryChildFragment2.child = _progressedPrimaryChild2;
+        }
+
+        // Because primaryChildFragment is a new fiber that we're inserting as the
+        // parent of a new tree, we need to set its treeBaseDuration.
+        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
+          // treeBaseDuration is the sum of all the child tree base durations.
+          var _treeBaseDuration = 0;
+          var _hiddenChild = _primaryChildFragment2.child;
+          while (_hiddenChild !== null) {
+            _treeBaseDuration += _hiddenChild.treeBaseDuration;
+            _hiddenChild = _hiddenChild.sibling;
+          }
+          _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
+        }
+
+        // Create a fragment from the fallback children, too.
+        var _fallbackChildFragment2 = (_primaryChildFragment2.sibling = createFiberFromFragment(
+          _nextFallbackChildren2,
+          mode,
+          renderExpirationTime,
+          null
+        ));
+        _fallbackChildFragment2.effectTag |= Placement;
+        child = _primaryChildFragment2;
+        _primaryChildFragment2.childExpirationTime = NoWork;
+        // Skip the primary children, and continue working on the
+        // fallback children.
+        next = _fallbackChildFragment2;
+        child.return = next.return = workInProgress;
+      } else {
+        // Still haven't timed out.  Continue rendering the children, like we
+        // normally do.
+        var _nextPrimaryChildren2 = nextProps.children;
+        next = child = reconcileChildFibers(
+          workInProgress,
+          _currentPrimaryChild,
+          _nextPrimaryChildren2,
+          renderExpirationTime
+        );
+      }
+    }
   }
+
+  workInProgress.memoizedState = nextState;
+  workInProgress.child = child;
+  return next;
 }
 
 function updatePortalComponent(
@@ -10998,7 +11982,6 @@ function updatePortalComponent(
       nextChildren,
       renderExpirationTime
     );
-    memoizeProps(workInProgress, nextChildren);
   } else {
     reconcileChildren(
       current$$1,
@@ -11006,7 +11989,6 @@ function updatePortalComponent(
       nextChildren,
       renderExpirationTime
     );
-    memoizeProps(workInProgress, nextChildren);
   }
   return workInProgress.child;
 }
@@ -11023,7 +12005,6 @@ function updateContextProvider(
   var oldProps = workInProgress.memoizedProps;
 
   var newValue = newProps.value;
-  workInProgress.memoizedProps = newProps;
 
   {
     var providerPropTypes = workInProgress.type.propTypes;
@@ -11075,12 +12056,40 @@ function updateContextProvider(
   return workInProgress.child;
 }
 
+var hasWarnedAboutUsingContextAsConsumer = false;
+
 function updateContextConsumer(
   current$$1,
   workInProgress,
   renderExpirationTime
 ) {
   var context = workInProgress.type;
+  // The logic below for Context differs depending on PROD or DEV mode. In
+  // DEV mode, we create a separate object for Context.Consumer that acts
+  // like a proxy to Context. This proxy object adds unnecessary code in PROD
+  // so we use the old behaviour (Context.Consumer references Context) to
+  // reduce size and overhead. The separate object references context via
+  // a property called "_context", which also gives us the ability to check
+  // in DEV mode if this property exists or not and warn if it does not.
+  {
+    if (context._context === undefined) {
+      // This may be because it's a Context (rather than a Consumer).
+      // Or it may be because it's older React where they're the same thing.
+      // We only want to warn if we're sure it's a new React.
+      if (context !== context.Consumer) {
+        if (!hasWarnedAboutUsingContextAsConsumer) {
+          hasWarnedAboutUsingContextAsConsumer = true;
+          warning$1(
+            false,
+            "Rendering <Context> directly is not supported and will be removed in " +
+              "a future major release. Did you mean to render <Context.Consumer> instead?"
+          );
+        }
+      }
+    } else {
+      context = context._context;
+    }
+  }
   var newProps = workInProgress.pendingProps;
   var render = newProps.children;
 
@@ -11114,29 +12123,9 @@ function updateContextConsumer(
     newChildren,
     renderExpirationTime
   );
-  workInProgress.memoizedProps = newProps;
   return workInProgress.child;
 }
 
-/*
-  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
-    let child = firstChild;
-    do {
-      // Ensure that the first and last effect of the parent corresponds
-      // to the children's first and last effect.
-      if (!returnFiber.firstEffect) {
-        returnFiber.firstEffect = child.firstEffect;
-      }
-      if (child.lastEffect) {
-        if (returnFiber.lastEffect) {
-          returnFiber.lastEffect.nextEffect = child.firstEffect;
-        }
-        returnFiber.lastEffect = child.lastEffect;
-      }
-    } while (child = child.sibling);
-  }
-  */
-
 function bailoutOnAlreadyFinishedWork(
   current$$1,
   workInProgress,
@@ -11156,10 +12145,7 @@ function bailoutOnAlreadyFinishedWork(
 
   // Check if the children have any pending work.
   var childExpirationTime = workInProgress.childExpirationTime;
-  if (
-    childExpirationTime === NoWork ||
-    childExpirationTime > renderExpirationTime
-  ) {
+  if (childExpirationTime < renderExpirationTime) {
     // The children don't have any work either. We can skip them.
     // TODO: Once we add back resuming, we should check if the children are
     // a work-in-progress set. If so, we need to transfer their effects.
@@ -11172,17 +12158,6 @@ function bailoutOnAlreadyFinishedWork(
   }
 }
 
-// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
-function memoizeProps(workInProgress, nextProps) {
-  workInProgress.memoizedProps = nextProps;
-}
-
-function memoizeState(workInProgress, nextState) {
-  workInProgress.memoizedState = nextState;
-  // Don't reset the updateQueue, in case there are pending updates. Resetting
-  // is handled by processUpdateQueue.
-}
-
 function beginWork(current$$1, workInProgress, renderExpirationTime) {
   var updateExpirationTime = workInProgress.expirationTime;
 
@@ -11192,8 +12167,7 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
     if (
       oldProps === newProps &&
       !hasContextChanged() &&
-      (updateExpirationTime === NoWork ||
-        updateExpirationTime > renderExpirationTime)
+      updateExpirationTime < renderExpirationTime
     ) {
       // This fiber does not have any pending work. Bailout without entering
       // the begin phase. There's still some bookkeeping we that needs to be done
@@ -11213,14 +12187,6 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
           }
           break;
         }
-        case ClassComponentLazy: {
-          var thenable = workInProgress.type;
-          var _Component = getResultFromResolvedThenable(thenable);
-          if (isContextProvider(_Component)) {
-            pushContextProvider(workInProgress);
-          }
-          break;
-        }
         case HostPortal:
           pushHostContainer(
             workInProgress,
@@ -11237,6 +12203,46 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
             workInProgress.effectTag |= Update;
           }
           break;
+        case SuspenseComponent: {
+          var state = workInProgress.memoizedState;
+          var didTimeout = state !== null;
+          if (didTimeout) {
+            // If this boundary is currently timed out, we need to decide
+            // whether to retry the primary children, or to skip over it and
+            // go straight to the fallback. Check the priority of the primary
+            var primaryChildFragment = workInProgress.child;
+            var primaryChildExpirationTime =
+              primaryChildFragment.childExpirationTime;
+            if (
+              primaryChildExpirationTime !== NoWork &&
+              primaryChildExpirationTime >= renderExpirationTime
+            ) {
+              // The primary children have pending work. Use the normal path
+              // to attempt to render the primary children again.
+              return updateSuspenseComponent(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+            } else {
+              // The primary children do not have pending work with sufficient
+              // priority. Bailout.
+              var child = bailoutOnAlreadyFinishedWork(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+              if (child !== null) {
+                // The fallback children have pending work. Skip over the
+                // primary children and work on the fallback.
+                return child.sibling;
+              } else {
+                return null;
+              }
+            }
+          }
+          break;
+        }
       }
       return bailoutOnAlreadyFinishedWork(
         current$$1,
@@ -11251,64 +12257,53 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
 
   switch (workInProgress.tag) {
     case IndeterminateComponent: {
-      var _Component2 = workInProgress.type;
+      var elementType = workInProgress.elementType;
       return mountIndeterminateComponent(
         current$$1,
         workInProgress,
-        _Component2,
-        updateExpirationTime,
+        elementType,
         renderExpirationTime
       );
     }
-    case FunctionComponent: {
-      var _Component3 = workInProgress.type;
-      var unresolvedProps = workInProgress.pendingProps;
-      return updateFunctionComponent(
+    case LazyComponent: {
+      var _elementType = workInProgress.elementType;
+      return mountLazyComponent(
         current$$1,
         workInProgress,
-        _Component3,
-        unresolvedProps,
+        _elementType,
+        updateExpirationTime,
         renderExpirationTime
       );
     }
-    case FunctionComponentLazy: {
-      var _thenable = workInProgress.type;
-      var _Component4 = getResultFromResolvedThenable(_thenable);
-      var _unresolvedProps = workInProgress.pendingProps;
-      var child = updateFunctionComponent(
+    case FunctionComponent: {
+      var _Component = workInProgress.type;
+      var unresolvedProps = workInProgress.pendingProps;
+      var resolvedProps =
+        workInProgress.elementType === _Component
+          ? unresolvedProps
+          : resolveDefaultProps(_Component, unresolvedProps);
+      return updateFunctionComponent(
         current$$1,
         workInProgress,
-        _Component4,
-        resolveDefaultProps(_Component4, _unresolvedProps),
+        _Component,
+        resolvedProps,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps;
-      return child;
     }
     case ClassComponent: {
-      var _Component5 = workInProgress.type;
-      var _unresolvedProps2 = workInProgress.pendingProps;
+      var _Component2 = workInProgress.type;
+      var _unresolvedProps = workInProgress.pendingProps;
+      var _resolvedProps =
+        workInProgress.elementType === _Component2
+          ? _unresolvedProps
+          : resolveDefaultProps(_Component2, _unresolvedProps);
       return updateClassComponent(
         current$$1,
         workInProgress,
-        _Component5,
-        _unresolvedProps2,
-        renderExpirationTime
-      );
-    }
-    case ClassComponentLazy: {
-      var _thenable2 = workInProgress.type;
-      var _Component6 = getResultFromResolvedThenable(_thenable2);
-      var _unresolvedProps3 = workInProgress.pendingProps;
-      var _child = updateClassComponent(
-        current$$1,
-        workInProgress,
-        _Component6,
-        resolveDefaultProps(_Component6, _unresolvedProps3),
+        _Component2,
+        _resolvedProps,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps3;
-      return _child;
     }
     case HostRoot:
       return updateHostRoot(current$$1, workInProgress, renderExpirationTime);
@@ -11320,8 +12315,8 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
     case HostText:
       return updateHostText(current$$1, workInProgress);
-    case PlaceholderComponent:
-      return updatePlaceholderComponent(
+    case SuspenseComponent:
+      return updateSuspenseComponent(
         current$$1,
         workInProgress,
         renderExpirationTime
@@ -11334,27 +12329,18 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
     case ForwardRef: {
       var type = workInProgress.type;
+      var _unresolvedProps2 = workInProgress.pendingProps;
+      var _resolvedProps2 =
+        workInProgress.elementType === type
+          ? _unresolvedProps2
+          : resolveDefaultProps(type, _unresolvedProps2);
       return updateForwardRef(
         current$$1,
         workInProgress,
         type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    }
-    case ForwardRefLazy: {
-      var _thenable3 = workInProgress.type;
-      var _Component7 = getResultFromResolvedThenable(_thenable3);
-      var _unresolvedProps4 = workInProgress.pendingProps;
-      var _child2 = updateForwardRef(
-        current$$1,
-        workInProgress,
-        _Component7,
-        resolveDefaultProps(_Component7, _unresolvedProps4),
+        _resolvedProps2,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps4;
-      return _child2;
     }
     case Fragment:
       return updateFragment(current$$1, workInProgress, renderExpirationTime);
@@ -11374,31 +12360,43 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         workInProgress,
         renderExpirationTime
       );
-    case PureComponent: {
+    case MemoComponent: {
       var _type = workInProgress.type;
-      return updatePureComponent(
+      var _unresolvedProps3 = workInProgress.pendingProps;
+      var _resolvedProps3 = resolveDefaultProps(_type.type, _unresolvedProps3);
+      return updateMemoComponent(
         current$$1,
         workInProgress,
         _type,
-        workInProgress.pendingProps,
+        _resolvedProps3,
         updateExpirationTime,
         renderExpirationTime
       );
     }
-    case PureComponentLazy: {
-      var _thenable4 = workInProgress.type;
-      var _Component8 = getResultFromResolvedThenable(_thenable4);
-      var _unresolvedProps5 = workInProgress.pendingProps;
-      var _child3 = updatePureComponent(
+    case SimpleMemoComponent: {
+      return updateSimpleMemoComponent(
         current$$1,
         workInProgress,
-        _Component8,
-        resolveDefaultProps(_Component8, _unresolvedProps5),
+        workInProgress.type,
+        workInProgress.pendingProps,
         updateExpirationTime,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps5;
-      return _child3;
+    }
+    case IncompleteClassComponent: {
+      var _Component3 = workInProgress.type;
+      var _unresolvedProps4 = workInProgress.pendingProps;
+      var _resolvedProps4 =
+        workInProgress.elementType === _Component3
+          ? _unresolvedProps4
+          : resolveDefaultProps(_Component3, _unresolvedProps4);
+      return mountIncompleteClassComponent(
+        current$$1,
+        workInProgress,
+        _Component3,
+        _resolvedProps4,
+        renderExpirationTime
+      );
     }
     default:
       invariant(
@@ -11410,51 +12408,57 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
 }
 
 function markUpdate(workInProgress) {
-  // Tag the fiber with an update effect. This turns a Placement into
-  // a PlacementAndUpdate.
-  workInProgress.effectTag |= Update;
-}
-
-function markRef$1(workInProgress) {
-  workInProgress.effectTag |= Ref;
-}
-
-function appendAllChildren(parent, workInProgress) {
-  // We only have the top Fiber that was created but we need recurse down its
-  // children to find all the terminal nodes.
-  var node = workInProgress.child;
-  while (node !== null) {
-    if (node.tag === HostComponent || node.tag === HostText) {
-      appendInitialChild(parent, node.stateNode);
-    } else if (node.tag === HostPortal) {
-      // If we have a portal child, then we don't want to traverse
-      // down its children. Instead, we'll get insertions from each child in
-      // the portal directly.
-    } else if (node.child !== null) {
-      node.child.return = node;
-      node = node.child;
-      continue;
-    }
-    if (node === workInProgress) {
-      return;
-    }
-    while (node.sibling === null) {
-      if (node.return === null || node.return === workInProgress) {
-        return;
-      }
-      node = node.return;
-    }
-    node.sibling.return = node.return;
-    node = node.sibling;
-  }
+  // Tag the fiber with an update effect. This turns a Placement into
+  // a PlacementAndUpdate.
+  workInProgress.effectTag |= Update;
+}
+
+function markRef$1(workInProgress) {
+  workInProgress.effectTag |= Ref;
 }
 
+var appendAllChildren = void 0;
 var updateHostContainer = void 0;
 var updateHostComponent$1 = void 0;
 var updateHostText$1 = void 0;
 if (supportsMutation) {
   // Mutation mode
 
+  appendAllChildren = function(
+    parent,
+    workInProgress,
+    needsVisibilityToggle,
+    isHidden
+  ) {
+    // We only have the top Fiber that was created but we need recurse down its
+    // children to find all the terminal nodes.
+    var node = workInProgress.child;
+    while (node !== null) {
+      if (node.tag === HostComponent || node.tag === HostText) {
+        appendInitialChild(parent, node.stateNode);
+      } else if (node.tag === HostPortal) {
+        // If we have a portal child, then we don't want to traverse
+        // down its children. Instead, we'll get insertions from each child in
+        // the portal directly.
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+      if (node === workInProgress) {
+        return;
+      }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === workInProgress) {
+          return;
+        }
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  };
+
   updateHostContainer = function(workInProgress) {
     // Noop
   };
@@ -11508,26 +12512,202 @@ if (supportsMutation) {
 } else if (supportsPersistence) {
   // Persistent host tree mode
 
+  appendAllChildren = function(
+    parent,
+    workInProgress,
+    needsVisibilityToggle,
+    isHidden
+  ) {
+    // We only have the top Fiber that was created but we need recurse down its
+    // children to find all the terminal nodes.
+    var node = workInProgress.child;
+    while (node !== null) {
+      // eslint-disable-next-line no-labels
+      branches: if (node.tag === HostComponent) {
+        var instance = node.stateNode;
+        if (needsVisibilityToggle) {
+          var props = node.memoizedProps;
+          var type = node.type;
+          if (isHidden) {
+            // This child is inside a timed out tree. Hide it.
+            instance = cloneHiddenInstance(instance, type, props, node);
+          } else {
+            // This child was previously inside a timed out tree. If it was not
+            // updated during this render, it may need to be unhidden. Clone
+            // again to be sure.
+            instance = cloneUnhiddenInstance(instance, type, props, node);
+          }
+          node.stateNode = instance;
+        }
+        appendInitialChild(parent, instance);
+      } else if (node.tag === HostText) {
+        var _instance = node.stateNode;
+        if (needsVisibilityToggle) {
+          var text = node.memoizedProps;
+          var rootContainerInstance = getRootHostContainer();
+          var currentHostContext = getHostContext();
+          if (isHidden) {
+            _instance = createHiddenTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          } else {
+            _instance = createTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          }
+          node.stateNode = _instance;
+        }
+        appendInitialChild(parent, _instance);
+      } else if (node.tag === HostPortal) {
+        // If we have a portal child, then we don't want to traverse
+        // down its children. Instead, we'll get insertions from each child in
+        // the portal directly.
+      } else if (node.tag === SuspenseComponent) {
+        var current = node.alternate;
+        if (current !== null) {
+          var oldState = current.memoizedState;
+          var newState = node.memoizedState;
+          var oldIsHidden = oldState !== null;
+          var newIsHidden = newState !== null;
+          if (oldIsHidden !== newIsHidden) {
+            // The placeholder either just timed out or switched back to the normal
+            // children after having previously timed out. Toggle the visibility of
+            // the direct host children.
+            var primaryChildParent = newIsHidden ? node.child : node;
+            if (primaryChildParent !== null) {
+              appendAllChildren(parent, primaryChildParent, true, newIsHidden);
+            }
+            // eslint-disable-next-line no-labels
+            break branches;
+          }
+        }
+        if (node.child !== null) {
+          // Continue traversing like normal
+          node.child.return = node;
+          node = node.child;
+          continue;
+        }
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+      // $FlowFixMe This is correct but Flow is confused by the labeled break.
+      node = node;
+      if (node === workInProgress) {
+        return;
+      }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === workInProgress) {
+          return;
+        }
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  };
+
   // An unfortunate fork of appendAllChildren because we have two different parent types.
   var appendAllChildrenToContainer = function(
     containerChildSet,
-    workInProgress
+    workInProgress,
+    needsVisibilityToggle,
+    isHidden
   ) {
     // We only have the top Fiber that was created but we need recurse down its
     // children to find all the terminal nodes.
     var node = workInProgress.child;
     while (node !== null) {
-      if (node.tag === HostComponent || node.tag === HostText) {
-        appendChildToContainerChildSet(containerChildSet, node.stateNode);
+      // eslint-disable-next-line no-labels
+      branches: if (node.tag === HostComponent) {
+        var instance = node.stateNode;
+        if (needsVisibilityToggle) {
+          var props = node.memoizedProps;
+          var type = node.type;
+          if (isHidden) {
+            // This child is inside a timed out tree. Hide it.
+            instance = cloneHiddenInstance(instance, type, props, node);
+          } else {
+            // This child was previously inside a timed out tree. If it was not
+            // updated during this render, it may need to be unhidden. Clone
+            // again to be sure.
+            instance = cloneUnhiddenInstance(instance, type, props, node);
+          }
+          node.stateNode = instance;
+        }
+        appendChildToContainerChildSet(containerChildSet, instance);
+      } else if (node.tag === HostText) {
+        var _instance2 = node.stateNode;
+        if (needsVisibilityToggle) {
+          var text = node.memoizedProps;
+          var rootContainerInstance = getRootHostContainer();
+          var currentHostContext = getHostContext();
+          if (isHidden) {
+            _instance2 = createHiddenTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          } else {
+            _instance2 = createTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          }
+          node.stateNode = _instance2;
+        }
+        appendChildToContainerChildSet(containerChildSet, _instance2);
       } else if (node.tag === HostPortal) {
         // If we have a portal child, then we don't want to traverse
         // down its children. Instead, we'll get insertions from each child in
         // the portal directly.
+      } else if (node.tag === SuspenseComponent) {
+        var current = node.alternate;
+        if (current !== null) {
+          var oldState = current.memoizedState;
+          var newState = node.memoizedState;
+          var oldIsHidden = oldState !== null;
+          var newIsHidden = newState !== null;
+          if (oldIsHidden !== newIsHidden) {
+            // The placeholder either just timed out or switched back to the normal
+            // children after having previously timed out. Toggle the visibility of
+            // the direct host children.
+            var primaryChildParent = newIsHidden ? node.child : node;
+            if (primaryChildParent !== null) {
+              appendAllChildrenToContainer(
+                containerChildSet,
+                primaryChildParent,
+                true,
+                newIsHidden
+              );
+            }
+            // eslint-disable-next-line no-labels
+            break branches;
+          }
+        }
+        if (node.child !== null) {
+          // Continue traversing like normal
+          node.child.return = node;
+          node = node.child;
+          continue;
+        }
       } else if (node.child !== null) {
         node.child.return = node;
         node = node.child;
         continue;
       }
+      // $FlowFixMe This is correct but Flow is confused by the labeled break.
+      node = node;
       if (node === workInProgress) {
         return;
       }
@@ -11550,7 +12730,7 @@ if (supportsMutation) {
       var container = portalOrRoot.containerInfo;
       var newChildSet = createContainerChildSet(container);
       // If children might have changed, we have to add them all to the set.
-      appendAllChildrenToContainer(newChildSet, workInProgress);
+      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
       portalOrRoot.pendingChildren = newChildSet;
       // Schedule an update on the container to swap out the container.
       markUpdate(workInProgress);
@@ -11623,7 +12803,7 @@ if (supportsMutation) {
       markUpdate(workInProgress);
     } else {
       // If children might have changed, we have to add them all to the set.
-      appendAllChildren(newInstance, workInProgress);
+      appendAllChildren(newInstance, workInProgress, false, false);
     }
   };
   updateHostText$1 = function(current, workInProgress, oldText, newText) {
@@ -11665,8 +12845,12 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   var newProps = workInProgress.pendingProps;
 
   switch (workInProgress.tag) {
+    case IndeterminateComponent:
+      break;
+    case LazyComponent:
+      break;
+    case SimpleMemoComponent:
     case FunctionComponent:
-    case FunctionComponentLazy:
       break;
     case ClassComponent: {
       var Component = workInProgress.type;
@@ -11675,13 +12859,6 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       }
       break;
     }
-    case ClassComponentLazy: {
-      var _Component = getResultFromResolvedThenable(workInProgress.type);
-      if (isContextProvider(_Component)) {
-        popContext(workInProgress);
-      }
-      break;
-    }
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
@@ -11757,7 +12934,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             workInProgress
           );
 
-          appendAllChildren(instance, workInProgress);
+          appendAllChildren(instance, workInProgress, false, false);
 
           // Certain renderers require commit-time effects for initial mount.
           // (eg DOM renderer supports auto-focus for certain elements).
@@ -11818,10 +12995,54 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       break;
     }
     case ForwardRef:
-    case ForwardRefLazy:
       break;
-    case PlaceholderComponent:
+    case SuspenseComponent: {
+      var nextState = workInProgress.memoizedState;
+      if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
+        // Something suspended. Re-render with the fallback children.
+        workInProgress.expirationTime = renderExpirationTime;
+        // Do not reset the effect list.
+        return workInProgress;
+      }
+
+      var nextDidTimeout = nextState !== null;
+      var prevDidTimeout = current !== null && current.memoizedState !== null;
+
+      if (current !== null && !nextDidTimeout && prevDidTimeout) {
+        // We just switched from the fallback to the normal children. Delete
+        // the fallback.
+        // TODO: Would it be better to store the fallback fragment on
+        var currentFallbackChild = current.child.sibling;
+        if (currentFallbackChild !== null) {
+          // Deletions go at the beginning of the return fiber's effect list
+          var first = workInProgress.firstEffect;
+          if (first !== null) {
+            workInProgress.firstEffect = currentFallbackChild;
+            currentFallbackChild.nextEffect = first;
+          } else {
+            workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
+            currentFallbackChild.nextEffect = null;
+          }
+          currentFallbackChild.effectTag = Deletion;
+        }
+      }
+
+      // The children either timed out after previously being visible, or
+      // were restored after previously being hidden. Schedule an effect
+      // to update their visiblity.
+      if (
+        //
+        nextDidTimeout !== prevDidTimeout ||
+        // Outside concurrent mode, the primary children commit in an
+        // inconsistent state, even if they are hidden. So if they are hidden,
+        // we need to schedule an effect to re-hide them, just in case.
+        ((workInProgress.effectTag & ConcurrentMode) === NoContext &&
+          nextDidTimeout)
+      ) {
+        workInProgress.effectTag |= Update;
+      }
       break;
+    }
     case Fragment:
       break;
     case Mode:
@@ -11838,18 +13059,17 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       break;
     case ContextConsumer:
       break;
-    case PureComponent:
-    case PureComponentLazy:
+    case MemoComponent:
       break;
-    // Error cases
-    case IndeterminateComponent:
-      invariant(
-        false,
-        "An indeterminate component should have become determinate before " +
-          "completing. This error is likely caused by a bug in React. Please " +
-          "file an issue."
-      );
-    // eslint-disable-next-line no-fallthrough
+    case IncompleteClassComponent: {
+      // Same as class component case. I put it down here so that the tags are
+      // sequential to ensure this switch is compiled to a jump table.
+      var _Component = workInProgress.type;
+      if (isContextProvider(_Component)) {
+        popContext(workInProgress);
+      }
+      break;
+    }
     default:
       invariant(
         false,
@@ -11861,6 +13081,17 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   return null;
 }
 
+function shouldCaptureSuspense(current, workInProgress) {
+  // In order to capture, the Suspense component must have a fallback prop.
+  if (workInProgress.memoizedProps.fallback === undefined) {
+    return false;
+  }
+  // If it was the primary children that just suspended, capture and render the
+  // fallback. Otherwise, don't capture and bubble to the next boundary.
+  var nextState = workInProgress.memoizedState;
+  return nextState === null;
+}
+
 // Module provided by RN:
 /**
  * Intercept lifecycle errors and ensure they are shown with the correct stack
@@ -11977,8 +13208,6 @@ function logCapturedError(capturedError) {
   }
 }
 
-var emptyObject$1 = {};
-
 var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
 {
   didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
@@ -12063,19 +13292,60 @@ function safelyDetachRef(current$$1) {
   }
 }
 
+function safelyCallDestroy(current$$1, destroy) {
+  {
+    invokeGuardedCallback(null, destroy, null);
+    if (hasCaughtError()) {
+      var error = clearCaughtError();
+      captureCommitPhaseError(current$$1, error);
+    }
+  }
+}
+
 function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case SimpleMemoComponent: {
+      commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
+      return;
+    }
+    case ClassComponent: {
       if (finishedWork.effectTag & Snapshot) {
         if (current$$1 !== null) {
           var prevProps = current$$1.memoizedProps;
           var prevState = current$$1.memoizedState;
           startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
           var instance = finishedWork.stateNode;
-          instance.props = finishedWork.memoizedProps;
-          instance.state = finishedWork.memoizedState;
-          var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
+          // We could update instance props and state here,
+          // but instead we rely on them being set during last render.
+          // TODO: revisit this when we implement resuming.
+          {
+            if (finishedWork.type === finishedWork.elementType) {
+              !(instance.props === finishedWork.memoizedProps)
+                ? warning$1(
+                    false,
+                    "Expected instance props to match memoized props before " +
+                      "getSnapshotBeforeUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+              !(instance.state === finishedWork.memoizedState)
+                ? warning$1(
+                    false,
+                    "Expected instance state to match memoized state before " +
+                      "getSnapshotBeforeUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+            }
+          }
+          var snapshot = instance.getSnapshotBeforeUpdate(
+            finishedWork.elementType === finishedWork.type
+              ? prevProps
+              : resolveDefaultProps(finishedWork.type, prevProps),
+            prevState
+          );
           {
             var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
             if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
@@ -12098,6 +13368,7 @@ function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
     case HostComponent:
     case HostText:
     case HostPortal:
+    case IncompleteClassComponent:
       // Nothing to do for these component types
       return;
     default: {
@@ -12110,6 +13381,58 @@ function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
   }
 }
 
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  if (!enableHooks) {
+    return;
+  }
+  var updateQueue = finishedWork.updateQueue;
+  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
+  if (lastEffect !== null) {
+    var firstEffect = lastEffect.next;
+    var effect = firstEffect;
+    do {
+      if ((effect.tag & unmountTag) !== NoEffect$1) {
+        // Unmount
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        if (destroy !== null) {
+          destroy();
+        }
+      }
+      if ((effect.tag & mountTag) !== NoEffect$1) {
+        // Mount
+        var create = effect.create;
+        var _destroy = create();
+        if (typeof _destroy !== "function") {
+          {
+            if (_destroy !== null && _destroy !== undefined) {
+              warningWithoutStack$1(
+                false,
+                "useEffect function must return a cleanup function or " +
+                  "nothing.%s%s",
+                typeof _destroy.then === "function"
+                  ? " Promises and useEffect(async () => ...) are not " +
+                    "supported, but you can call an async function inside an " +
+                    "effect."
+                  : "",
+                getStackByFiberInDevAndProd(finishedWork)
+              );
+            }
+          }
+          _destroy = null;
+        }
+        effect.destroy = _destroy;
+      }
+      effect = effect.next;
+    } while (effect !== firstEffect);
+  }
+}
+
+function commitPassiveHookEffects(finishedWork) {
+  commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
+  commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
+}
+
 function commitLifeCycles(
   finishedRoot,
   current$$1,
@@ -12117,22 +13440,75 @@ function commitLifeCycles(
   committedExpirationTime
 ) {
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case SimpleMemoComponent: {
+      commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
+      break;
+    }
+    case ClassComponent: {
       var instance = finishedWork.stateNode;
       if (finishedWork.effectTag & Update) {
         if (current$$1 === null) {
           startPhaseTimer(finishedWork, "componentDidMount");
-          instance.props = finishedWork.memoizedProps;
-          instance.state = finishedWork.memoizedState;
+          // We could update instance props and state here,
+          // but instead we rely on them being set during last render.
+          // TODO: revisit this when we implement resuming.
+          {
+            if (finishedWork.type === finishedWork.elementType) {
+              !(instance.props === finishedWork.memoizedProps)
+                ? warning$1(
+                    false,
+                    "Expected instance props to match memoized props before " +
+                      "componentDidMount. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+              !(instance.state === finishedWork.memoizedState)
+                ? warning$1(
+                    false,
+                    "Expected instance state to match memoized state before " +
+                      "componentDidMount. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+            }
+          }
           instance.componentDidMount();
           stopPhaseTimer();
         } else {
-          var prevProps = current$$1.memoizedProps;
+          var prevProps =
+            finishedWork.elementType === finishedWork.type
+              ? current$$1.memoizedProps
+              : resolveDefaultProps(
+                  finishedWork.type,
+                  current$$1.memoizedProps
+                );
           var prevState = current$$1.memoizedState;
           startPhaseTimer(finishedWork, "componentDidUpdate");
-          instance.props = finishedWork.memoizedProps;
-          instance.state = finishedWork.memoizedState;
+          // We could update instance props and state here,
+          // but instead we rely on them being set during last render.
+          // TODO: revisit this when we implement resuming.
+          {
+            if (finishedWork.type === finishedWork.elementType) {
+              !(instance.props === finishedWork.memoizedProps)
+                ? warning$1(
+                    false,
+                    "Expected instance props to match memoized props before " +
+                      "componentDidUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+              !(instance.state === finishedWork.memoizedState)
+                ? warning$1(
+                    false,
+                    "Expected instance state to match memoized state before " +
+                      "componentDidUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+            }
+          }
           instance.componentDidUpdate(
             prevProps,
             prevState,
@@ -12143,8 +13519,29 @@ function commitLifeCycles(
       }
       var updateQueue = finishedWork.updateQueue;
       if (updateQueue !== null) {
-        instance.props = finishedWork.memoizedProps;
-        instance.state = finishedWork.memoizedState;
+        {
+          if (finishedWork.type === finishedWork.elementType) {
+            !(instance.props === finishedWork.memoizedProps)
+              ? warning$1(
+                  false,
+                  "Expected instance props to match memoized props before " +
+                    "processing the update queue. This is likely due to a bug in React. " +
+                    "Please file an issue."
+                )
+              : void 0;
+            !(instance.state === finishedWork.memoizedState)
+              ? warning$1(
+                  false,
+                  "Expected instance state to match memoized state before " +
+                    "processing the update queue. This is likely due to a bug in React. " +
+                    "Please file an issue."
+                )
+              : void 0;
+          }
+        }
+        // We could update instance props and state here,
+        // but instead we rely on them being set during last render.
+        // TODO: revisit this when we implement resuming.
         commitUpdateQueue(
           finishedWork,
           updateQueue,
@@ -12164,7 +13561,6 @@ function commitLifeCycles(
               _instance = getPublicInstance(finishedWork.child.stateNode);
               break;
             case ClassComponent:
-            case ClassComponentLazy:
               _instance = finishedWork.child.stateNode;
               break;
           }
@@ -12228,25 +13624,10 @@ function commitLifeCycles(
       }
       return;
     }
-    case PlaceholderComponent: {
-      if (enableSuspense) {
-        if ((finishedWork.mode & StrictMode) === NoEffect) {
-          // In loose mode, a placeholder times out by scheduling a synchronous
-          // update in the commit phase. Use `updateQueue` field to signal that
-          // the Timeout needs to switch to the placeholder. We don't need an
-          // entire queue. Any non-null value works.
-          // $FlowFixMe - Intentionally using a value other than an UpdateQueue.
-          finishedWork.updateQueue = emptyObject$1;
-          scheduleWork(finishedWork, Sync);
-        } else {
-          // In strict mode, the Update effect is used to record the time at
-          // which the placeholder timed out.
-          var currentTime = requestCurrentTime();
-          finishedWork.stateNode = { timedOutAt: currentTime };
-        }
-      }
-      return;
-    }
+    case SuspenseComponent:
+      break;
+    case IncompleteClassComponent:
+      break;
     default: {
       invariant(
         false,
@@ -12257,6 +13638,54 @@ function commitLifeCycles(
   }
 }
 
+function hideOrUnhideAllChildren(finishedWork, isHidden) {
+  if (supportsMutation) {
+    // We only have the top Fiber that was inserted but we need recurse down its
+    var node = finishedWork;
+    while (true) {
+      if (node.tag === HostComponent) {
+        var instance = node.stateNode;
+        if (isHidden) {
+          hideInstance(instance);
+        } else {
+          unhideInstance(node.stateNode, node.memoizedProps);
+        }
+      } else if (node.tag === HostText) {
+        var _instance3 = node.stateNode;
+        if (isHidden) {
+          hideTextInstance(_instance3);
+        } else {
+          unhideTextInstance(_instance3, node.memoizedProps);
+        }
+      } else if (
+        node.tag === SuspenseComponent &&
+        node.memoizedState !== null
+      ) {
+        // Found a nested Suspense component that timed out. Skip over the
+        var fallbackChildFragment = node.child.sibling;
+        fallbackChildFragment.return = node;
+        node = fallbackChildFragment;
+        continue;
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+      if (node === finishedWork) {
+        return;
+      }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === finishedWork) {
+          return;
+        }
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  }
+}
+
 function commitAttachRef(finishedWork) {
   var ref = finishedWork.ref;
   if (ref !== null) {
@@ -12307,8 +13736,28 @@ function commitUnmount(current$$1) {
   onCommitUnmount(current$$1);
 
   switch (current$$1.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case MemoComponent:
+    case SimpleMemoComponent: {
+      var updateQueue = current$$1.updateQueue;
+      if (updateQueue !== null) {
+        var lastEffect = updateQueue.lastEffect;
+        if (lastEffect !== null) {
+          var firstEffect = lastEffect.next;
+          var effect = firstEffect;
+          do {
+            var destroy = effect.destroy;
+            if (destroy !== null) {
+              safelyCallDestroy(current$$1, destroy);
+            }
+            effect = effect.next;
+          } while (effect !== firstEffect);
+        }
+      }
+      break;
+    }
+    case ClassComponent: {
       safelyDetachRef(current$$1);
       var instance = current$$1.stateNode;
       if (typeof instance.componentWillUnmount === "function") {
@@ -12399,8 +13848,7 @@ function commitContainer(finishedWork) {
   }
 
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case ClassComponent: {
       return;
     }
     case HostComponent: {
@@ -12675,13 +14123,29 @@ function commitDeletion(current$$1) {
 
 function commitWork(current$$1, finishedWork) {
   if (!supportsMutation) {
+    switch (finishedWork.tag) {
+      case FunctionComponent:
+      case ForwardRef:
+      case MemoComponent:
+      case SimpleMemoComponent: {
+        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
+        return;
+      }
+    }
+
     commitContainer(finishedWork);
     return;
   }
 
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case MemoComponent:
+    case SimpleMemoComponent: {
+      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
+      return;
+    }
+    case ClassComponent: {
       return;
     }
     case HostComponent: {
@@ -12732,7 +14196,30 @@ function commitWork(current$$1, finishedWork) {
     case Profiler: {
       return;
     }
-    case PlaceholderComponent: {
+    case SuspenseComponent: {
+      var newState = finishedWork.memoizedState;
+
+      var newDidTimeout = void 0;
+      var primaryChildParent = finishedWork;
+      if (newState === null) {
+        newDidTimeout = false;
+      } else {
+        newDidTimeout = true;
+        primaryChildParent = finishedWork.child;
+        if (newState.timedOutAt === NoWork) {
+          // If the children had not already timed out, record the time.
+          // This is used to compute the elapsed time during subsequent
+          // attempts to render the children.
+          newState.timedOutAt = requestCurrentTime();
+        }
+      }
+
+      if (primaryChildParent !== null) {
+        hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
+      }
+      return;
+    }
+    case IncompleteClassComponent: {
       return;
     }
     default: {
@@ -12749,11 +14236,7 @@ function commitResetTextContent(current$$1) {
   if (!supportsMutation) {
     return;
   }
-  resetTextContent(current$$1.stateNode);
-}
-
-function NoopComponent() {
-  return null;
+  resetTextContent(current$$1.stateNode);
 }
 
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
@@ -12832,7 +14315,6 @@ function throwException(
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
   if (
-    enableSuspense &&
     value !== null &&
     typeof value === "object" &&
     typeof value.then === "function"
@@ -12849,25 +14331,20 @@ function throwException(
     var earliestTimeoutMs = -1;
     var startTimeMs = -1;
     do {
-      if (_workInProgress.tag === PlaceholderComponent) {
-        var current = _workInProgress.alternate;
-        if (
-          current !== null &&
-          current.memoizedState === true &&
-          current.stateNode !== null
-        ) {
-          // Reached a placeholder that already timed out. Each timed out
-          // placeholder acts as the root of a new suspense boundary.
-
-          // Use the time at which the placeholder timed out as the start time
-          // for the current render.
-          var timedOutAt = current.stateNode.timedOutAt;
-          startTimeMs = expirationTimeToMs(timedOutAt);
-
-          // Do not search any further.
-          break;
+      if (_workInProgress.tag === SuspenseComponent) {
+        var current$$1 = _workInProgress.alternate;
+        if (current$$1 !== null) {
+          var currentState = current$$1.memoizedState;
+          if (currentState !== null) {
+            // Reached a boundary that already timed out. Do not search
+            // any further.
+            var timedOutAt = currentState.timedOutAt;
+            startTimeMs = expirationTimeToMs(timedOutAt);
+            // Do not search any further.
+            break;
+          }
         }
-        var timeoutPropMs = _workInProgress.pendingProps.delayMs;
+        var timeoutPropMs = _workInProgress.pendingProps.maxDuration;
         if (typeof timeoutPropMs === "number") {
           if (timeoutPropMs <= 0) {
             earliestTimeoutMs = 0;
@@ -12882,132 +14359,124 @@ function throwException(
       _workInProgress = _workInProgress.return;
     } while (_workInProgress !== null);
 
-    // Schedule the nearest Placeholder to re-render the timed out view.
+    // Schedule the nearest Suspense to re-render the timed out view.
     _workInProgress = returnFiber;
     do {
-      if (_workInProgress.tag === PlaceholderComponent) {
-        var didTimeout = _workInProgress.memoizedState;
-        if (!didTimeout) {
-          // Found the nearest boundary.
-
-          // If the boundary is not in concurrent mode, we should not suspend, and
-          // likewise, when the promise resolves, we should ping synchronously.
-          var pingTime =
-            (_workInProgress.mode & ConcurrentMode) === NoEffect
-              ? Sync
-              : renderExpirationTime;
-
-          // Attach a listener to the promise to "ping" the root and retry.
-          var onResolveOrReject = retrySuspendedRoot.bind(
-            null,
-            root,
-            _workInProgress,
-            pingTime
-          );
-          if (enableSchedulerTracing) {
-            onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
-          }
-          thenable.then(onResolveOrReject, onResolveOrReject);
-
-          // If the boundary is outside of strict mode, we should *not* suspend
-          // the commit. Pretend as if the suspended component rendered null and
-          // keep rendering. In the commit phase, we'll schedule a subsequent
-          // synchronous update to re-render the Placeholder.
-          //
-          // Note: It doesn't matter whether the component that suspended was
-          // inside a strict mode tree. If the Placeholder is outside of it, we
-          // should *not* suspend the commit.
-          if ((_workInProgress.mode & StrictMode) === NoEffect) {
-            _workInProgress.effectTag |= Update;
-
-            // Unmount the source fiber's children
-            var nextChildren = null;
-            reconcileChildren(
-              sourceFiber.alternate,
-              sourceFiber,
-              nextChildren,
-              renderExpirationTime
-            );
-            sourceFiber.effectTag &= ~Incomplete;
-            if (sourceFiber.tag === IndeterminateComponent) {
-              // Let's just assume it's a function component. This fiber will
-              // be unmounted in the immediate next commit, anyway.
-              sourceFiber.tag = FunctionComponent;
+      if (
+        _workInProgress.tag === SuspenseComponent &&
+        shouldCaptureSuspense(_workInProgress.alternate, _workInProgress)
+      ) {
+        // Found the nearest boundary.
+
+        // If the boundary is not in concurrent mode, we should not suspend, and
+        // likewise, when the promise resolves, we should ping synchronously.
+        var pingTime =
+          (_workInProgress.mode & ConcurrentMode) === NoEffect
+            ? Sync
+            : renderExpirationTime;
+
+        // Attach a listener to the promise to "ping" the root and retry.
+        var onResolveOrReject = retrySuspendedRoot.bind(
+          null,
+          root,
+          _workInProgress,
+          sourceFiber,
+          pingTime
+        );
+        if (enableSchedulerTracing) {
+          onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
+        }
+        thenable.then(onResolveOrReject, onResolveOrReject);
+
+        // If the boundary is outside of concurrent mode, we should *not*
+        // suspend the commit. Pretend as if the suspended component rendered
+        // null and keep rendering. In the commit phase, we'll schedule a
+        // subsequent synchronous update to re-render the Suspense.
+        //
+        // Note: It doesn't matter whether the component that suspended was
+        // inside a concurrent mode tree. If the Suspense is outside of it, we
+        // should *not* suspend the commit.
+        if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
+          _workInProgress.effectTag |= DidCapture;
+
+          // We're going to commit this fiber even though it didn't complete.
+          // But we shouldn't call any lifecycle methods or callbacks. Remove
+          // all lifecycle effect tags.
+          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
+
+          if (sourceFiber.tag === ClassComponent) {
+            var _current = sourceFiber.alternate;
+            if (_current === null) {
+              // This is a new mount. Change the tag so it's not mistaken for a
+              // completed class component. For example, we should not call
+              // componentWillUnmount if it is deleted.
+              sourceFiber.tag = IncompleteClassComponent;
             }
+          }
 
-            if (
-              sourceFiber.tag === ClassComponent ||
-              sourceFiber.tag === ClassComponentLazy
-            ) {
-              // We're going to commit this fiber even though it didn't
-              // complete. But we shouldn't call any lifecycle methods or
-              // callbacks. Remove all lifecycle effect tags.
-              sourceFiber.effectTag &= ~LifecycleEffectMask;
-              if (sourceFiber.alternate === null) {
-                // We're about to mount a class component that doesn't have an
-                // instance. Turn this into a dummy function component instead,
-                // to prevent type errors. This is a bit weird but it's an edge
-                // case and we're about to synchronously delete this
-                // component, anyway.
-                sourceFiber.tag = FunctionComponent;
-                sourceFiber.type = NoopComponent;
-              }
-            }
+          // The source fiber did not complete. Mark it with the current
+          // render priority to indicate that it still has pending work.
+          sourceFiber.expirationTime = renderExpirationTime;
 
-            // Exit without suspending.
-            return;
-          }
+          // Exit without suspending.
+          return;
+        }
 
-          // Confirmed that the boundary is in a strict mode tree. Continue with
-          // the normal suspend path.
+        // Confirmed that the boundary is in a concurrent mode tree. Continue
+        // with the normal suspend path.
 
-          var absoluteTimeoutMs = void 0;
-          if (earliestTimeoutMs === -1) {
-            // If no explicit threshold is given, default to an abitrarily large
-            // value. The actual size doesn't matter because the threshold for the
-            // whole tree will be clamped to the expiration time.
-            absoluteTimeoutMs = maxSigned31BitInt;
-          } else {
-            if (startTimeMs === -1) {
-              // This suspend happened outside of any already timed-out
-              // placeholders. We don't know exactly when the update was scheduled,
-              // but we can infer an approximate start time from the expiration
-              // time. First, find the earliest uncommitted expiration time in the
-              // tree, including work that is suspended. Then subtract the offset
-              // used to compute an async update's expiration time. This will cause
-              // high priority (interactive) work to expire earlier than necessary,
-              // but we can account for this by adjusting for the Just Noticeable
-              // Difference.
-              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(
-                root,
-                renderExpirationTime
-              );
-              var earliestExpirationTimeMs = expirationTimeToMs(
-                earliestExpirationTime
-              );
-              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
-            }
-            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+        var absoluteTimeoutMs = void 0;
+        if (earliestTimeoutMs === -1) {
+          // If no explicit threshold is given, default to an abitrarily large
+          // value. The actual size doesn't matter because the threshold for the
+          // whole tree will be clamped to the expiration time.
+          absoluteTimeoutMs = maxSigned31BitInt;
+        } else {
+          if (startTimeMs === -1) {
+            // This suspend happened outside of any already timed-out
+            // placeholders. We don't know exactly when the update was
+            // scheduled, but we can infer an approximate start time from the
+            // expiration time. First, find the earliest uncommitted expiration
+            // time in the tree, including work that is suspended. Then subtract
+            // the offset used to compute an async update's expiration time.
+            // This will cause high priority (interactive) work to expire
+            // earlier than necessary, but we can account for this by adjusting
+            // for the Just Noticeable Difference.
+            var earliestExpirationTime = findEarliestOutstandingPriorityLevel(
+              root,
+              renderExpirationTime
+            );
+            var earliestExpirationTimeMs = expirationTimeToMs(
+              earliestExpirationTime
+            );
+            startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
           }
+          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+        }
 
-          // Mark the earliest timeout in the suspended fiber's ancestor path.
-          // After completing the root, we'll take the largest of all the
-          // suspended fiber's timeouts and use it to compute a timeout for the
-          // whole tree.
-          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
+        // Mark the earliest timeout in the suspended fiber's ancestor path.
+        // After completing the root, we'll take the largest of all the
+        // suspended fiber's timeouts and use it to compute a timeout for the
+        // whole tree.
+        renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
 
-          _workInProgress.effectTag |= ShouldCapture;
-          _workInProgress.expirationTime = renderExpirationTime;
-          return;
-        }
-        // This boundary already captured during this render. Continue to the
-        // next boundary.
+        _workInProgress.effectTag |= ShouldCapture;
+        _workInProgress.expirationTime = renderExpirationTime;
+        return;
       }
+      // This boundary already captured during this render. Continue to the next
+      // boundary.
       _workInProgress = _workInProgress.return;
     } while (_workInProgress !== null);
     // No boundary was found. Fallthrough to error mode.
+    // TODO: Use invariant so the message is stripped in prod?
     value = new Error(
-      "An update was suspended, but no placeholder UI was provided."
+      (getComponentName(sourceFiber.type) || "A React component") +
+        " suspended while rendering, but no fallback UI was specified.\n" +
+        "\n" +
+        "Add a <Suspense fallback=...> component higher in the tree to " +
+        "provide a loading indicator or placeholder to display." +
+        getStackByFiberInDevAndProd(sourceFiber)
     );
   }
 
@@ -13032,7 +14501,6 @@ function throwException(
         return;
       }
       case ClassComponent:
-      case ClassComponentLazy:
         // Capture and retry
         var errorInfo = value;
         var ctor = workInProgress.type;
@@ -13077,38 +14545,27 @@ function unwindWork(workInProgress, renderExpirationTime) {
       }
       return null;
     }
-    case ClassComponentLazy: {
-      var _Component = workInProgress.type._reactResult;
-      if (isContextProvider(_Component)) {
-        popContext(workInProgress);
-      }
-      var _effectTag = workInProgress.effectTag;
-      if (_effectTag & ShouldCapture) {
-        workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;
-        return workInProgress;
-      }
-      return null;
-    }
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
-      var _effectTag2 = workInProgress.effectTag;
+      var _effectTag = workInProgress.effectTag;
       invariant(
-        (_effectTag2 & DidCapture) === NoEffect,
+        (_effectTag & DidCapture) === NoEffect,
         "The root failed to unmount after an error. This is likely a bug in " +
           "React. Please file an issue."
       );
-      workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;
+      workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;
       return workInProgress;
     }
     case HostComponent: {
       popHostContext(workInProgress);
       return null;
     }
-    case PlaceholderComponent: {
-      var _effectTag3 = workInProgress.effectTag;
-      if (_effectTag3 & ShouldCapture) {
-        workInProgress.effectTag = (_effectTag3 & ~ShouldCapture) | DidCapture;
+    case SuspenseComponent: {
+      var _effectTag2 = workInProgress.effectTag;
+      if (_effectTag2 & ShouldCapture) {
+        workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;
+        // Captured a suspense effect. Re-render the boundary.
         return workInProgress;
       }
       return null;
@@ -13133,14 +14590,6 @@ function unwindInterruptedWork(interruptedWork) {
       }
       break;
     }
-    case ClassComponentLazy: {
-      var _childContextTypes =
-        interruptedWork.type._reactResult.childContextTypes;
-      if (_childContextTypes !== null && _childContextTypes !== undefined) {
-        popContext(interruptedWork);
-      }
-      break;
-    }
     case HostRoot: {
       popHostContainer(interruptedWork);
       popTopLevelContextObject(interruptedWork);
@@ -13162,6 +14611,19 @@ function unwindInterruptedWork(interruptedWork) {
 }
 
 var Dispatcher = {
+  readContext: readContext,
+  useCallback: useCallback,
+  useContext: useContext,
+  useEffect: useEffect,
+  useImperativeMethods: useImperativeMethods,
+  useLayoutEffect: useLayoutEffect,
+  useMemo: useMemo,
+  useMutationEffect: useMutationEffect,
+  useReducer: useReducer,
+  useRef: useRef,
+  useState: useState
+};
+var DispatcherWithoutHooks = {
   readContext: readContext
 };
 
@@ -13174,12 +14636,12 @@ var warnAboutInvalidUpdates = void 0;
 
 if (enableSchedulerTracing) {
   // Provide explicit error message when production+profiling bundle of e.g. react-dom
-  // is used with production (non-profiling) bundle of schedule/tracing
+  // is used with production (non-profiling) bundle of scheduler/tracing
   invariant(
     tracing.__interactionsRef != null &&
       tracing.__interactionsRef.current != null,
     "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " +
-      "without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. " +
+      "without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. " +
       "Your bundler might have a setting for aliasing both modules. " +
       "Learn more at http://fb.me/react-profiling"
   );
@@ -13190,19 +14652,21 @@ if (enableSchedulerTracing) {
   didWarnSetStateChildContext = false;
   var didWarnStateUpdateForUnmountedComponent = {};
 
-  warnAboutUpdateOnUnmounted = function(fiber) {
+  warnAboutUpdateOnUnmounted = function(fiber, isClass) {
     // We show the whole stack but dedupe on the top component's name because
     // the problematic code almost always lies inside that component.
-    var componentName = getComponentName(fiber.type) || "ReactClass";
+    var componentName = getComponentName(fiber.type) || "ReactComponent";
     if (didWarnStateUpdateForUnmountedComponent[componentName]) {
       return;
     }
     warningWithoutStack$1(
       false,
-      "Can't call setState (or forceUpdate) on an unmounted component. This " +
+      "Can't perform a React state update on an unmounted component. This " +
         "is a no-op, but it indicates a memory leak in your application. To " +
-        "fix, cancel all subscriptions and asynchronous tasks in the " +
-        "componentWillUnmount method.%s",
+        "fix, cancel all subscriptions and asynchronous tasks in %s.%s",
+      isClass
+        ? "the componentWillUnmount method"
+        : "a useEffect cleanup function",
       getStackByFiberInDevAndProd(fiber)
     );
     didWarnStateUpdateForUnmountedComponent[componentName] = true;
@@ -13254,6 +14718,9 @@ var nextRenderDidError = false;
 var nextEffect = null;
 
 var isCommitting$1 = false;
+var rootWithPendingPassiveEffects = null;
+var passiveEffectCallbackHandle = null;
+var passiveEffectCallback = null;
 
 var legacyErrorBoundariesThatAlreadyFailed = null;
 
@@ -13262,11 +14729,13 @@ var interruptedBy = null;
 
 var stashedWorkInProgressProperties = void 0;
 var replayUnitOfWork = void 0;
+var mayReplayFailedUnitOfWork = void 0;
 var isReplayingFailedUnitOfWork = void 0;
 var originalReplayError = void 0;
 var rethrowOriginalError = void 0;
 if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
   stashedWorkInProgressProperties = null;
+  mayReplayFailedUnitOfWork = true;
   isReplayingFailedUnitOfWork = false;
   originalReplayError = null;
   replayUnitOfWork = function(failedUnitOfWork, thrownValue, isYieldy) {
@@ -13311,13 +14780,6 @@ if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
         }
         break;
       }
-      case ClassComponentLazy: {
-        var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);
-        if (isContextProvider(_Component)) {
-          popContext(failedUnitOfWork);
-        }
-        break;
-      }
       case HostPortal:
         popHostContainer(failedUnitOfWork);
         break;
@@ -13456,8 +14918,6 @@ function commitBeforeMutationLifecycles() {
       commitBeforeMutationLifeCycles(current$$1, nextEffect);
     }
 
-    // Don't cleanup effects yet;
-    // This will be done by commitAllLifeCycles()
     nextEffect = nextEffect.nextEffect;
   }
 
@@ -13494,15 +14954,48 @@ function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
       commitAttachRef(nextEffect);
     }
 
-    var next = nextEffect.nextEffect;
-    // Ensure that we clean these up so that we don't accidentally keep them.
-    // I'm not actually sure this matters because we can't reset firstEffect
-    // and lastEffect since they're on every node, not just the effectful
-    // ones. So we have to clean everything as we reuse nodes anyway.
-    nextEffect.nextEffect = null;
-    // Ensure that we reset the effectTag here so that we can rely on effect
-    // tags to reason about the current life-cycle.
-    nextEffect = next;
+    if (enableHooks && effectTag & Passive) {
+      rootWithPendingPassiveEffects = finishedRoot;
+    }
+
+    nextEffect = nextEffect.nextEffect;
+  }
+}
+
+function commitPassiveEffects(root, firstEffect) {
+  rootWithPendingPassiveEffects = null;
+  passiveEffectCallbackHandle = null;
+  passiveEffectCallback = null;
+
+  // Set this to true to prevent re-entrancy
+  var previousIsRendering = isRendering;
+  isRendering = true;
+
+  var effect = firstEffect;
+  do {
+    if (effect.effectTag & Passive) {
+      var didError = false;
+      var error = void 0;
+      {
+        invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);
+        if (hasCaughtError()) {
+          didError = true;
+          error = clearCaughtError();
+        }
+      }
+      if (didError) {
+        captureCommitPhaseError(effect, error);
+      }
+    }
+    effect = effect.nextEffect;
+  } while (effect !== null);
+
+  isRendering = previousIsRendering;
+
+  // Check if work was scheduled by one of the effects
+  var rootExpirationTime = root.expirationTime;
+  if (rootExpirationTime !== NoWork) {
+    requestWork(root, rootExpirationTime);
   }
 }
 
@@ -13521,6 +15014,15 @@ function markLegacyErrorBoundaryAsFailed(instance) {
   }
 }
 
+function flushPassiveEffects() {
+  if (passiveEffectCallback !== null) {
+    scheduler.unstable_cancelCallback(passiveEffectCallbackHandle);
+    // We call the scheduled callback instead of commitPassiveEffects directly
+    // to ensure tracing works correctly.
+    passiveEffectCallback();
+  }
+}
+
 function commitRoot(root, finishedWork) {
   isWorking = true;
   isCommitting$1 = true;
@@ -13546,9 +15048,7 @@ function commitRoot(root, finishedWork) {
   var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
   var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
   var earliestRemainingTimeBeforeCommit =
-    updateExpirationTimeBeforeCommit === NoWork ||
-    (childExpirationTimeBeforeCommit !== NoWork &&
-      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit)
+    childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit
       ? childExpirationTimeBeforeCommit
       : updateExpirationTimeBeforeCommit;
   markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);
@@ -13690,6 +15190,26 @@ function commitRoot(root, finishedWork) {
     }
   }
 
+  if (
+    enableHooks &&
+    firstEffect !== null &&
+    rootWithPendingPassiveEffects !== null
+  ) {
+    // This commit included a passive effect. These do not need to fire until
+    // after the next paint. Schedule an callback to fire them in an async
+    // event. To ensure serial execution, the callback will be flushed early if
+    // we enter rootWithPendingPassiveEffects commit phase before then.
+    var callback = commitPassiveEffects.bind(null, root, firstEffect);
+    if (enableSchedulerTracing) {
+      // TODO: Avoid this extra callback by mutating the tracing ref directly,
+      // like we do at the beginning of commitRoot. I've opted not to do that
+      // here because that code is still in flux.
+      callback = tracing.unstable_wrap(callback);
+    }
+    passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(callback);
+    passiveEffectCallback = callback;
+  }
+
   isCommitting$1 = false;
   isWorking = false;
   stopCommitLifeCyclesTimer();
@@ -13702,9 +15222,7 @@ function commitRoot(root, finishedWork) {
   var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
   var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
   var earliestRemainingTimeAfterCommit =
-    updateExpirationTimeAfterCommit === NoWork ||
-    (childExpirationTimeAfterCommit !== NoWork &&
-      childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit)
+    childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit
       ? childExpirationTimeAfterCommit
       : updateExpirationTimeAfterCommit;
   if (earliestRemainingTimeAfterCommit === NoWork) {
@@ -13747,10 +15265,7 @@ function commitRoot(root, finishedWork) {
         // Only decrement the pending interaction count if we're done.
         // If there's still work at the current priority,
         // That indicates that we are waiting for suspense data.
-        if (
-          earliestRemainingTimeAfterCommit === NoWork ||
-          scheduledExpirationTime < earliestRemainingTimeAfterCommit
-        ) {
+        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
           pendingInteractionMap.delete(scheduledExpirationTime);
 
           scheduledInteractions.forEach(function(interaction) {
@@ -13806,18 +15321,10 @@ function resetChildExpirationTime(workInProgress, renderTime) {
     while (child !== null) {
       var childUpdateExpirationTime = child.expirationTime;
       var childChildExpirationTime = child.childExpirationTime;
-      if (
-        newChildExpirationTime === NoWork ||
-        (childUpdateExpirationTime !== NoWork &&
-          childUpdateExpirationTime < newChildExpirationTime)
-      ) {
+      if (childUpdateExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = childUpdateExpirationTime;
       }
-      if (
-        newChildExpirationTime === NoWork ||
-        (childChildExpirationTime !== NoWork &&
-          childChildExpirationTime < newChildExpirationTime)
-      ) {
+      if (childChildExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = childChildExpirationTime;
       }
       if (shouldBubbleActualDurations) {
@@ -13833,18 +15340,10 @@ function resetChildExpirationTime(workInProgress, renderTime) {
     while (_child !== null) {
       var _childUpdateExpirationTime = _child.expirationTime;
       var _childChildExpirationTime = _child.childExpirationTime;
-      if (
-        newChildExpirationTime === NoWork ||
-        (_childUpdateExpirationTime !== NoWork &&
-          _childUpdateExpirationTime < newChildExpirationTime)
-      ) {
+      if (_childUpdateExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = _childUpdateExpirationTime;
       }
-      if (
-        newChildExpirationTime === NoWork ||
-        (_childChildExpirationTime !== NoWork &&
-          _childChildExpirationTime < newChildExpirationTime)
-      ) {
+      if (_childChildExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = _childChildExpirationTime;
       }
       _child = _child.sibling;
@@ -13872,18 +15371,22 @@ function completeUnitOfWork(workInProgress) {
     var siblingFiber = workInProgress.sibling;
 
     if ((workInProgress.effectTag & Incomplete) === NoEffect) {
+      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
+        // Don't replay if it fails during completion phase.
+        mayReplayFailedUnitOfWork = false;
+      }
       // This fiber completed.
+      // Remember we're completing this unit so we can find a boundary if it fails.
+      nextUnitOfWork = workInProgress;
       if (enableProfilerTimer) {
         if (workInProgress.mode & ProfileMode) {
           startProfilerTimer(workInProgress);
         }
-
         nextUnitOfWork = completeWork(
           current$$1,
           workInProgress,
           nextRenderExpirationTime
         );
-
         if (workInProgress.mode & ProfileMode) {
           // Update render duration assuming we didn't error.
           stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
@@ -13895,12 +15398,21 @@ function completeUnitOfWork(workInProgress) {
           nextRenderExpirationTime
         );
       }
+      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
+        // We're out of completion phase so replaying is fine now.
+        mayReplayFailedUnitOfWork = true;
+      }
       stopWorkTimer(workInProgress);
       resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
       {
         resetCurrentFiber();
       }
 
+      if (nextUnitOfWork !== null) {
+        // Completing this fiber spawned new work. Work on that next.
+        return nextUnitOfWork;
+      }
+
       if (
         returnFiber !== null &&
         // Do not append effects to parents if a sibling failed to complete
@@ -13954,9 +15466,18 @@ function completeUnitOfWork(workInProgress) {
         return null;
       }
     } else {
-      if (workInProgress.mode & ProfileMode) {
+      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
         // Record the render duration for the fiber that errored.
         stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
+
+        // Include the time spent working on failed children before continuing.
+        var actualDuration = workInProgress.actualDuration;
+        var child = workInProgress.child;
+        while (child !== null) {
+          actualDuration += child.actualDuration;
+          child = child.sibling;
+        }
+        workInProgress.actualDuration = actualDuration;
       }
 
       // This fiber did not complete because something threw. Pop values off
@@ -13981,19 +15502,6 @@ function completeUnitOfWork(workInProgress) {
           ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
         }
 
-        if (enableProfilerTimer) {
-          // Include the time spent working on failed children before continuing.
-          if (next.mode & ProfileMode) {
-            var actualDuration = next.actualDuration;
-            var child = next.child;
-            while (child !== null) {
-              actualDuration += child.actualDuration;
-              child = child.sibling;
-            }
-            next.actualDuration = actualDuration;
-          }
-        }
-
         // If completing this work spawned new work, do that next. We'll come
         // back here again.
         // Since we're restarting, remove anything that is not a host effect
@@ -14058,6 +15566,7 @@ function performUnitOfWork(workInProgress) {
     }
 
     next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
+    workInProgress.memoizedProps = workInProgress.pendingProps;
 
     if (workInProgress.mode & ProfileMode) {
       // Record the render duration assuming we didn't bailout (or error).
@@ -14065,6 +15574,7 @@ function performUnitOfWork(workInProgress) {
     }
   } else {
     next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
+    workInProgress.memoizedProps = workInProgress.pendingProps;
   }
 
   {
@@ -14098,21 +15608,28 @@ function workLoop(isYieldy) {
       nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     }
   } else {
-    // Flush asynchronous work until the deadline runs out of time.
-    while (nextUnitOfWork !== null && !shouldYield()) {
+    // Flush asynchronous work until there's a higher priority event
+    while (nextUnitOfWork !== null && !shouldYieldToRenderer()) {
       nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     }
   }
 }
 
-function renderRoot(root, isYieldy, isExpired) {
+function renderRoot(root, isYieldy) {
   invariant(
     !isWorking,
     "renderRoot was called recursively. This error is likely caused " +
       "by a bug in React. Please file an issue."
   );
+
+  flushPassiveEffects();
+
   isWorking = true;
-  ReactCurrentOwner$2.currentDispatcher = Dispatcher;
+  if (enableHooks) {
+    ReactCurrentOwner$2.currentDispatcher = Dispatcher;
+  } else {
+    ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
+  }
 
   var expirationTime = root.nextExpirationTimeToWorkOn;
 
@@ -14142,7 +15659,7 @@ function renderRoot(root, isYieldy, isExpired) {
         scheduledInteractions,
         scheduledExpirationTime
       ) {
-        if (scheduledExpirationTime <= expirationTime) {
+        if (scheduledExpirationTime >= expirationTime) {
           scheduledInteractions.forEach(function(interaction) {
             return interactions.add(interaction);
           });
@@ -14194,20 +15711,39 @@ function renderRoot(root, isYieldy, isExpired) {
     try {
       workLoop(isYieldy);
     } catch (thrownValue) {
+      resetContextDependences();
+      resetHooks();
+
+      // Reset in case completion throws.
+      // This is only used in DEV and when replaying is on.
+      var mayReplay = void 0;
+      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
+        mayReplay = mayReplayFailedUnitOfWork;
+        mayReplayFailedUnitOfWork = true;
+      }
+
       if (nextUnitOfWork === null) {
         // This is a fatal error.
         didFatal = true;
         onUncaughtError(thrownValue);
       } else {
+        if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {
+          // Record the time spent rendering before an error was thrown.
+          // This avoids inaccurate Profiler durations in the case of a suspended render.
+          stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
+        }
+
         {
           // Reset global debug state
           // We assume this is defined in DEV
           resetCurrentlyProcessingQueue();
         }
 
-        var failedUnitOfWork = nextUnitOfWork;
         if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
-          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
+          if (mayReplay) {
+            var failedUnitOfWork = nextUnitOfWork;
+            replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
+          }
         }
 
         // TODO: we already know this isn't true in some cases.
@@ -14256,6 +15792,7 @@ function renderRoot(root, isYieldy, isExpired) {
   isWorking = false;
   ReactCurrentOwner$2.currentDispatcher = null;
   resetContextDependences();
+  resetHooks();
 
   // Yield back to main thread.
   if (didFatal) {
@@ -14327,7 +15864,7 @@ function renderRoot(root, isYieldy, isExpired) {
       // similar to a suspend, but without a timeout because we're not waiting
       // for a promise to resolve.
       !root.didError &&
-      !isExpired
+      isYieldy
     ) {
       root.didError = true;
       var _suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime);
@@ -14343,7 +15880,7 @@ function renderRoot(root, isYieldy, isExpired) {
     }
   }
 
-  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {
+  if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
     // The tree was suspended.
     var _suspendedExpirationTime2 = expirationTime;
     markSuspendedPriorityLevel(root, _suspendedExpirationTime2);
@@ -14385,17 +15922,12 @@ function renderRoot(root, isYieldy, isExpired) {
   onComplete(root, rootWorkInProgress, expirationTime);
 }
 
-function dispatch(sourceFiber, value, expirationTime) {
-  invariant(
-    !isWorking || isCommitting$1,
-    "dispatch: Cannot dispatch during the render phase."
-  );
-
+function captureCommitPhaseError(sourceFiber, value) {
+  var expirationTime = Sync;
   var fiber = sourceFiber.return;
   while (fiber !== null) {
     switch (fiber.tag) {
       case ClassComponent:
-      case ClassComponentLazy:
         var ctor = fiber.type;
         var instance = fiber.stateNode;
         if (
@@ -14436,10 +15968,6 @@ function dispatch(sourceFiber, value, expirationTime) {
   }
 }
 
-function captureCommitPhaseError(fiber, error) {
-  return dispatch(fiber, error, Sync);
-}
-
 function computeThreadID(expirationTime, interactionThreadID) {
   // Interaction threads are unique per root and expiration time.
   return expirationTime * 1000 + interactionThreadID;
@@ -14474,7 +16002,7 @@ function computeExpirationForFiber(currentTime, fiber) {
       // If we're in the middle of rendering a tree, do not update at the same
       // expiration time that is already rendering.
       if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
-        expirationTime += 1;
+        expirationTime -= 1;
       }
     } else {
       // This is a sync update
@@ -14485,7 +16013,10 @@ function computeExpirationForFiber(currentTime, fiber) {
     // This is an interactive update. Keep track of the lowest pending
     // interactive expiration time. This allows us to synchronously flush
     // all interactive updates when needed.
-    if (expirationTime > lowestPriorityPendingInteractiveExpirationTime) {
+    if (
+      lowestPriorityPendingInteractiveExpirationTime === NoWork ||
+      expirationTime < lowestPriorityPendingInteractiveExpirationTime
+    ) {
       lowestPriorityPendingInteractiveExpirationTime = expirationTime;
     }
   }
@@ -14506,68 +16037,75 @@ function renderDidError() {
   nextRenderDidError = true;
 }
 
-function retrySuspendedRoot(root, fiber, suspendedTime) {
-  if (enableSuspense) {
-    var retryTime = void 0;
+function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
+  var retryTime = void 0;
 
-    if (isPriorityLevelSuspended(root, suspendedTime)) {
-      // Ping at the original level
-      retryTime = suspendedTime;
+  if (isPriorityLevelSuspended(root, suspendedTime)) {
+    // Ping at the original level
+    retryTime = suspendedTime;
 
-      markPingedPriorityLevel(root, retryTime);
-    } else {
-      // Placeholder already timed out. Compute a new expiration time
-      var currentTime = requestCurrentTime();
-      retryTime = computeExpirationForFiber(currentTime, fiber);
-      markPendingPriorityLevel(root, retryTime);
-    }
+    markPingedPriorityLevel(root, retryTime);
+  } else {
+    // Suspense already timed out. Compute a new expiration time
+    var currentTime = requestCurrentTime();
+    retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
+    markPendingPriorityLevel(root, retryTime);
+  }
 
-    // TODO: If the placeholder fiber has already rendered the primary children
-    // without suspending (that is, all of the promises have already resolved),
-    // we should not trigger another update here. One case this happens is when
-    // we are in sync mode and a single promise is thrown both on initial render
-    // and on update; we attach two .then(retrySuspendedRoot) callbacks and each
-    // one performs Sync work, rerendering the Placeholder.
+  // TODO: If the suspense fiber has already rendered the primary children
+  // without suspending (that is, all of the promises have already resolved),
+  // we should not trigger another update here. One case this happens is when
+  // we are in sync mode and a single promise is thrown both on initial render
+  // and on update; we attach two .then(retrySuspendedRoot) callbacks and each
+  // one performs Sync work, rerendering the Suspense.
 
-    if ((fiber.mode & ConcurrentMode) !== NoContext) {
-      if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
-        // Received a ping at the same priority level at which we're currently
-        // rendering. Restart from the root.
-        nextRoot = null;
-      }
+  if ((boundaryFiber.mode & ConcurrentMode) !== NoContext) {
+    if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
+      // Received a ping at the same priority level at which we're currently
+      // rendering. Restart from the root.
+      nextRoot = null;
     }
+  }
 
-    scheduleWorkToRoot(fiber, retryTime);
-    var rootExpirationTime = root.expirationTime;
-    if (rootExpirationTime !== NoWork) {
-      requestWork(root, rootExpirationTime);
+  scheduleWorkToRoot(boundaryFiber, retryTime);
+  if ((boundaryFiber.mode & ConcurrentMode) === NoContext) {
+    // Outside of concurrent mode, we must schedule an update on the source
+    // fiber, too, since it already committed in an inconsistent state and
+    // therefore does not have any pending work.
+    scheduleWorkToRoot(sourceFiber, retryTime);
+    var sourceTag = sourceFiber.tag;
+    if (sourceTag === ClassComponent && sourceFiber.stateNode !== null) {
+      // When we try rendering again, we should not reuse the current fiber,
+      // since it's known to be in an inconsistent state. Use a force updte to
+      // prevent a bail out.
+      var update = createUpdate(retryTime);
+      update.tag = ForceUpdate;
+      enqueueUpdate(sourceFiber, update);
     }
   }
+
+  var rootExpirationTime = root.expirationTime;
+  if (rootExpirationTime !== NoWork) {
+    requestWork(root, rootExpirationTime);
+  }
 }
 
 function scheduleWorkToRoot(fiber, expirationTime) {
   recordScheduleUpdate();
 
   {
-    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
+    if (fiber.tag === ClassComponent) {
       var instance = fiber.stateNode;
       warnAboutInvalidUpdates(instance);
     }
   }
 
   // Update the source fiber's expiration time
-  if (
-    fiber.expirationTime === NoWork ||
-    fiber.expirationTime > expirationTime
-  ) {
+  if (fiber.expirationTime < expirationTime) {
     fiber.expirationTime = expirationTime;
   }
   var alternate = fiber.alternate;
-  if (
-    alternate !== null &&
-    (alternate.expirationTime === NoWork ||
-      alternate.expirationTime > expirationTime)
-  ) {
+  if (alternate !== null && alternate.expirationTime < expirationTime) {
     alternate.expirationTime = expirationTime;
   }
   // Walk the parent path to the root and update the child expiration time.
@@ -14578,22 +16116,17 @@ function scheduleWorkToRoot(fiber, expirationTime) {
   } else {
     while (node !== null) {
       alternate = node.alternate;
-      if (
-        node.childExpirationTime === NoWork ||
-        node.childExpirationTime > expirationTime
-      ) {
+      if (node.childExpirationTime < expirationTime) {
         node.childExpirationTime = expirationTime;
         if (
           alternate !== null &&
-          (alternate.childExpirationTime === NoWork ||
-            alternate.childExpirationTime > expirationTime)
+          alternate.childExpirationTime < expirationTime
         ) {
           alternate.childExpirationTime = expirationTime;
         }
       } else if (
         alternate !== null &&
-        (alternate.childExpirationTime === NoWork ||
-          alternate.childExpirationTime > expirationTime)
+        alternate.childExpirationTime < expirationTime
       ) {
         alternate.childExpirationTime = expirationTime;
       }
@@ -14605,63 +16138,67 @@ function scheduleWorkToRoot(fiber, expirationTime) {
     }
   }
 
-  if (root === null) {
-    if (
-      true &&
-      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)
-    ) {
-      warnAboutUpdateOnUnmounted(fiber);
-    }
-    return null;
-  }
-
   if (enableSchedulerTracing) {
-    var interactions = tracing.__interactionsRef.current;
-    if (interactions.size > 0) {
-      var pendingInteractionMap = root.pendingInteractionMap;
-      var pendingInteractions = pendingInteractionMap.get(expirationTime);
-      if (pendingInteractions != null) {
-        interactions.forEach(function(interaction) {
-          if (!pendingInteractions.has(interaction)) {
-            // Update the pending async work count for previously unscheduled interaction.
-            interaction.__count++;
-          }
+    if (root !== null) {
+      var interactions = tracing.__interactionsRef.current;
+      if (interactions.size > 0) {
+        var pendingInteractionMap = root.pendingInteractionMap;
+        var pendingInteractions = pendingInteractionMap.get(expirationTime);
+        if (pendingInteractions != null) {
+          interactions.forEach(function(interaction) {
+            if (!pendingInteractions.has(interaction)) {
+              // Update the pending async work count for previously unscheduled interaction.
+              interaction.__count++;
+            }
 
-          pendingInteractions.add(interaction);
-        });
-      } else {
-        pendingInteractionMap.set(expirationTime, new Set(interactions));
+            pendingInteractions.add(interaction);
+          });
+        } else {
+          pendingInteractionMap.set(expirationTime, new Set(interactions));
 
-        // Update the pending async work count for the current interactions.
-        interactions.forEach(function(interaction) {
-          interaction.__count++;
-        });
-      }
+          // Update the pending async work count for the current interactions.
+          interactions.forEach(function(interaction) {
+            interaction.__count++;
+          });
+        }
 
-      var subscriber = tracing.__subscriberRef.current;
-      if (subscriber !== null) {
-        var threadID = computeThreadID(
-          expirationTime,
-          root.interactionThreadID
-        );
-        subscriber.onWorkScheduled(interactions, threadID);
+        var subscriber = tracing.__subscriberRef.current;
+        if (subscriber !== null) {
+          var threadID = computeThreadID(
+            expirationTime,
+            root.interactionThreadID
+          );
+          subscriber.onWorkScheduled(interactions, threadID);
+        }
       }
     }
   }
-
   return root;
 }
 
 function scheduleWork(fiber, expirationTime) {
   var root = scheduleWorkToRoot(fiber, expirationTime);
   if (root === null) {
+    {
+      switch (fiber.tag) {
+        case ClassComponent:
+          warnAboutUpdateOnUnmounted(fiber, true);
+          break;
+        case FunctionComponent:
+        case ForwardRef:
+        case MemoComponent:
+        case SimpleMemoComponent:
+          warnAboutUpdateOnUnmounted(fiber, false);
+          break;
+      }
+    }
     return;
   }
 
   if (
     !isWorking &&
     nextRenderExpirationTime !== NoWork &&
-    expirationTime < nextRenderExpirationTime
+    expirationTime > nextRenderExpirationTime
   ) {
     // This is an interruption. (Used for performance tracking.)
     interruptedBy = fiber;
@@ -14705,10 +16242,8 @@ var isRendering = false;
 var nextFlushedRoot = null;
 var nextFlushedExpirationTime = NoWork;
 var lowestPriorityPendingInteractiveExpirationTime = NoWork;
-var deadlineDidExpire = false;
 var hasUnhandledError = false;
 var unhandledError = null;
-var deadline = null;
 
 var isBatchingUpdates = false;
 var isUnbatchingUpdates = false;
@@ -14725,8 +16260,6 @@ var NESTED_UPDATE_LIMIT = 50;
 var nestedUpdateCount = 0;
 var lastCommittedRootDuringThisBatch = null;
 
-var timeHeuristicForUnitOfWork = 1;
-
 function recomputeCurrentRendererTime() {
   var currentTimeMs = now() - originalStartTimeMs;
   currentRendererTime = msToExpirationTime(currentTimeMs);
@@ -14735,7 +16268,7 @@ function recomputeCurrentRendererTime() {
 function scheduleCallbackWithExpirationTime(root, expirationTime) {
   if (callbackExpirationTime !== NoWork) {
     // A callback is already scheduled. Check its expiration time (timeout).
-    if (expirationTime > callbackExpirationTime) {
+    if (expirationTime < callbackExpirationTime) {
       // Existing callback has sufficient timeout. Exit.
       return;
     } else {
@@ -14778,7 +16311,7 @@ function onSuspend(
   msUntilTimeout
 ) {
   root.expirationTime = rootExpirationTime;
-  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {
+  if (msUntilTimeout === 0 && !shouldYieldToRenderer()) {
     // Don't wait an additional tick. Commit the tree immediately.
     root.pendingCommitExpirationTime = suspendedExpirationTime;
     root.finishedWork = finishedWork;
@@ -14796,17 +16329,15 @@ function onYield(root) {
 }
 
 function onTimeout(root, finishedWork, suspendedExpirationTime) {
-  if (enableSuspense) {
-    // The root timed out. Commit it.
-    root.pendingCommitExpirationTime = suspendedExpirationTime;
-    root.finishedWork = finishedWork;
-    // Read the current time before entering the commit phase. We can be
-    // certain this won't cause tearing related to batching of event updates
-    // because we're at the top of a timer event.
-    recomputeCurrentRendererTime();
-    currentSchedulerTime = currentRendererTime;
-    flushRoot(root, suspendedExpirationTime);
-  }
+  // The root timed out. Commit it.
+  root.pendingCommitExpirationTime = suspendedExpirationTime;
+  root.finishedWork = finishedWork;
+  // Read the current time before entering the commit phase. We can be
+  // certain this won't cause tearing related to batching of event updates
+  // because we're at the top of a timer event.
+  recomputeCurrentRendererTime();
+  currentSchedulerTime = currentRendererTime;
+  flushRoot(root, suspendedExpirationTime);
 }
 
 function onCommit(root, expirationTime) {
@@ -14875,7 +16406,7 @@ function requestWork(root, expirationTime) {
       // flush it now.
       nextFlushedRoot = root;
       nextFlushedExpirationTime = Sync;
-      performWorkOnRoot(root, Sync, true);
+      performWorkOnRoot(root, Sync, false);
     }
     return;
   }
@@ -14905,10 +16436,7 @@ function addRootToSchedule(root, expirationTime) {
   } else {
     // This root is already scheduled, but its priority may have increased.
     var remainingExpirationTime = root.expirationTime;
-    if (
-      remainingExpirationTime === NoWork ||
-      expirationTime < remainingExpirationTime
-    ) {
+    if (expirationTime > remainingExpirationTime) {
       // Update the priority.
       root.expirationTime = expirationTime;
     }
@@ -14957,10 +16485,7 @@ function findHighestPriorityRoot() {
         }
         root = previousScheduledRoot.nextScheduledRoot;
       } else {
-        if (
-          highestPriorityWork === NoWork ||
-          remainingExpirationTime < highestPriorityWork
-        ) {
+        if (remainingExpirationTime > highestPriorityWork) {
           // Update the priority, if it's higher
           highestPriorityWork = remainingExpirationTime;
           highestPriorityRoot = root;
@@ -14983,43 +16508,60 @@ function findHighestPriorityRoot() {
   nextFlushedExpirationTime = highestPriorityWork;
 }
 
-function performAsyncWork(dl) {
-  if (dl.didTimeout) {
-    // The callback timed out. That means at least one update has expired.
-    // Iterate through the root schedule. If they contain expired work, set
-    // the next render expiration time to the current time. This has the effect
-    // of flushing all expired work in a single batch, instead of flushing each
-    // level one at a time.
-    if (firstScheduledRoot !== null) {
-      recomputeCurrentRendererTime();
-      var root = firstScheduledRoot;
-      do {
-        didExpireAtExpirationTime(root, currentRendererTime);
-        // The root schedule is circular, so this is never null.
-        root = root.nextScheduledRoot;
-      } while (root !== firstScheduledRoot);
+// TODO: This wrapper exists because many of the older tests (the ones that use
+// flushDeferredPri) rely on the number of times `shouldYield` is called. We
+// should get rid of it.
+var didYield = false;
+function shouldYieldToRenderer() {
+  if (didYield) {
+    return true;
+  }
+  if (shouldYield()) {
+    didYield = true;
+    return true;
+  }
+  return false;
+}
+
+function performAsyncWork() {
+  try {
+    if (!shouldYieldToRenderer()) {
+      // The callback timed out. That means at least one update has expired.
+      // Iterate through the root schedule. If they contain expired work, set
+      // the next render expiration time to the current time. This has the effect
+      // of flushing all expired work in a single batch, instead of flushing each
+      // level one at a time.
+      if (firstScheduledRoot !== null) {
+        recomputeCurrentRendererTime();
+        var root = firstScheduledRoot;
+        do {
+          didExpireAtExpirationTime(root, currentRendererTime);
+          // The root schedule is circular, so this is never null.
+          root = root.nextScheduledRoot;
+        } while (root !== firstScheduledRoot);
+      }
     }
+    performWork(NoWork, true);
+  } finally {
+    didYield = false;
   }
-  performWork(NoWork, dl);
 }
 
 function performSyncWork() {
-  performWork(Sync, null);
+  performWork(Sync, false);
 }
 
-function performWork(minExpirationTime, dl) {
-  deadline = dl;
-
-  // Keep working on roots until there's no more work, or until we reach
-  // the deadline.
+function performWork(minExpirationTime, isYieldy) {
+  // Keep working on roots until there's no more work, or until there's a higher
+  // priority event.
   findHighestPriorityRoot();
 
-  if (deadline !== null) {
+  if (isYieldy) {
     recomputeCurrentRendererTime();
     currentSchedulerTime = currentRendererTime;
 
     if (enableUserTimingAPI) {
-      var didExpire = nextFlushedExpirationTime < currentRendererTime;
+      var didExpire = nextFlushedExpirationTime > currentRendererTime;
       var timeout = expirationTimeToMs(nextFlushedExpirationTime);
       stopRequestCallbackTimer(didExpire, timeout);
     }
@@ -15027,14 +16569,13 @@ function performWork(minExpirationTime, dl) {
     while (
       nextFlushedRoot !== null &&
       nextFlushedExpirationTime !== NoWork &&
-      (minExpirationTime === NoWork ||
-        minExpirationTime >= nextFlushedExpirationTime) &&
-      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)
+      minExpirationTime <= nextFlushedExpirationTime &&
+      !(didYield && currentRendererTime > nextFlushedExpirationTime)
     ) {
       performWorkOnRoot(
         nextFlushedRoot,
         nextFlushedExpirationTime,
-        currentRendererTime >= nextFlushedExpirationTime
+        currentRendererTime > nextFlushedExpirationTime
       );
       findHighestPriorityRoot();
       recomputeCurrentRendererTime();
@@ -15044,10 +16585,9 @@ function performWork(minExpirationTime, dl) {
     while (
       nextFlushedRoot !== null &&
       nextFlushedExpirationTime !== NoWork &&
-      (minExpirationTime === NoWork ||
-        minExpirationTime >= nextFlushedExpirationTime)
+      minExpirationTime <= nextFlushedExpirationTime
     ) {
-      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);
+      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
       findHighestPriorityRoot();
     }
   }
@@ -15056,7 +16596,7 @@ function performWork(minExpirationTime, dl) {
   // or there's no more work left with sufficient priority.
 
   // If we're inside a callback, set this to false since we just completed it.
-  if (deadline !== null) {
+  if (isYieldy) {
     callbackExpirationTime = NoWork;
     callbackID = null;
   }
@@ -15069,9 +16609,6 @@ function performWork(minExpirationTime, dl) {
   }
 
   // Clean-up.
-  deadline = null;
-  deadlineDidExpire = false;
-
   finishRendering();
 }
 
@@ -15086,7 +16623,7 @@ function flushRoot(root, expirationTime) {
   // including the given time.
   nextFlushedRoot = root;
   nextFlushedExpirationTime = expirationTime;
-  performWorkOnRoot(root, expirationTime, true);
+  performWorkOnRoot(root, expirationTime, false);
   // Flush any sync work that was scheduled by lifecycles
   performSyncWork();
 }
@@ -15119,7 +16656,7 @@ function finishRendering() {
   }
 }
 
-function performWorkOnRoot(root, expirationTime, isExpired) {
+function performWorkOnRoot(root, expirationTime, isYieldy) {
   invariant(
     !isRendering,
     "performWorkOnRoot was called recursively. This error is likely caused " +
@@ -15129,7 +16666,7 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
   isRendering = true;
 
   // Check if this is async work or sync/expired work.
-  if (deadline === null || isExpired) {
+  if (!isYieldy) {
     // Flush work without yielding.
     // TODO: Non-yieldy work does not necessarily imply expired work. A renderer
     // may want to perform some work without yielding, but also without
@@ -15144,13 +16681,12 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
       // If this root previously suspended, clear its existing timeout, since
       // we're about to try rendering again.
       var timeoutHandle = root.timeoutHandle;
-      if (enableSuspense && timeoutHandle !== noTimeout) {
+      if (timeoutHandle !== noTimeout) {
         root.timeoutHandle = noTimeout;
         // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
         cancelTimeout(timeoutHandle);
       }
-      var isYieldy = false;
-      renderRoot(root, isYieldy, isExpired);
+      renderRoot(root, isYieldy);
       finishedWork = root.finishedWork;
       if (finishedWork !== null) {
         // We've completed the root. Commit it.
@@ -15168,18 +16704,17 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
       // If this root previously suspended, clear its existing timeout, since
       // we're about to try rendering again.
       var _timeoutHandle = root.timeoutHandle;
-      if (enableSuspense && _timeoutHandle !== noTimeout) {
+      if (_timeoutHandle !== noTimeout) {
         root.timeoutHandle = noTimeout;
         // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
         cancelTimeout(_timeoutHandle);
       }
-      var _isYieldy = true;
-      renderRoot(root, _isYieldy, isExpired);
+      renderRoot(root, isYieldy);
       _finishedWork = root.finishedWork;
       if (_finishedWork !== null) {
-        // We've completed the root. Check the deadline one more time
+        // We've completed the root. Check the if we should yield one more time
         // before committing.
-        if (!shouldYield()) {
+        if (!shouldYieldToRenderer()) {
           // Still time left. Commit the root.
           completeRoot$1(root, _finishedWork, expirationTime);
         } else {
@@ -15197,7 +16732,7 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
 function completeRoot$1(root, finishedWork, expirationTime) {
   // Check if there's a batch that matches this expiration time.
   var firstBatch = root.firstBatch;
-  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {
+  if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
     if (completedBatches === null) {
       completedBatches = [firstBatch];
     } else {
@@ -15229,24 +16764,6 @@ function completeRoot$1(root, finishedWork, expirationTime) {
   commitRoot(root, finishedWork);
 }
 
-// When working on async work, the reconciler asks the renderer if it should
-// yield execution. For DOM, we implement this with requestIdleCallback.
-function shouldYield() {
-  if (deadlineDidExpire) {
-    return true;
-  }
-  if (
-    deadline === null ||
-    deadline.timeRemaining() > timeHeuristicForUnitOfWork
-  ) {
-    // Disregard deadline.didTimeout. Only expired work should be flushed
-    // during a timeout. This path is only hit for non-expired work.
-    return false;
-  }
-  deadlineDidExpire = true;
-  return true;
-}
-
 function onUncaughtError(error) {
   invariant(
     nextFlushedRoot !== null,
@@ -15291,7 +16808,7 @@ function interactiveUpdates$1(fn, a, b) {
     lowestPriorityPendingInteractiveExpirationTime !== NoWork
   ) {
     // Synchronously flush pending interactive updates.
-    performWork(lowestPriorityPendingInteractiveExpirationTime, null);
+    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
     lowestPriorityPendingInteractiveExpirationTime = NoWork;
   }
   var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
@@ -15315,7 +16832,7 @@ function flushInteractiveUpdates$1() {
     lowestPriorityPendingInteractiveExpirationTime !== NoWork
   ) {
     // Synchronously flush pending interactive updates.
-    performWork(lowestPriorityPendingInteractiveExpirationTime, null);
+    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
     lowestPriorityPendingInteractiveExpirationTime = NoWork;
   }
 }
@@ -15324,9 +16841,11 @@ function flushInteractiveUpdates$1() {
 // Might add PROFILE later.
 
 var didWarnAboutNestedUpdates = void 0;
+var didWarnAboutFindNodeInStrictMode = void 0;
 
 {
   didWarnAboutNestedUpdates = false;
+  didWarnAboutFindNodeInStrictMode = {};
 }
 
 function getContextForSubtree(parentComponent) {
@@ -15342,11 +16861,6 @@ function getContextForSubtree(parentComponent) {
     if (isContextProvider(Component)) {
       return processChildContext(fiber, Component, parentContext);
     }
-  } else if (fiber.tag === ClassComponentLazy) {
-    var _Component = getResultFromResolvedThenable(fiber.type);
-    if (isContextProvider(_Component)) {
-      return processChildContext(fiber, _Component, parentContext);
-    }
   }
 
   return parentContext;
@@ -15384,9 +16898,11 @@ function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
       : void 0;
     update.callback = callback;
   }
-  enqueueUpdate(current$$1, update);
 
+  flushPassiveEffects();
+  enqueueUpdate(current$$1, update);
   scheduleWork(current$$1, expirationTime);
+
   return expirationTime;
 }
 
@@ -15442,6 +16958,64 @@ function findHostInstance$1(component) {
   return hostFiber.stateNode;
 }
 
+function findHostInstanceWithWarning$1(component, methodName) {
+  {
+    var fiber = get$1(component);
+    if (fiber === undefined) {
+      if (typeof component.render === "function") {
+        invariant(false, "Unable to find node on an unmounted component.");
+      } else {
+        invariant(
+          false,
+          "Argument appears to not be a ReactComponent. Keys: %s",
+          Object.keys(component)
+        );
+      }
+    }
+    var hostFiber = findCurrentHostFiber(fiber);
+    if (hostFiber === null) {
+      return null;
+    }
+    if (hostFiber.mode & StrictMode) {
+      var componentName = getComponentName(fiber.type) || "Component";
+      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
+        didWarnAboutFindNodeInStrictMode[componentName] = true;
+        if (fiber.mode & StrictMode) {
+          warningWithoutStack$1(
+            false,
+            "%s is deprecated in StrictMode. " +
+              "%s was passed an instance of %s which is inside StrictMode. " +
+              "Instead, add a ref directly to the element you want to reference." +
+              "\n%s" +
+              "\n\nLearn more about using refs safely here:" +
+              "\nhttps://fb.me/react-strict-mode-find-node",
+            methodName,
+            methodName,
+            componentName,
+            getStackByFiberInDevAndProd(hostFiber)
+          );
+        } else {
+          warningWithoutStack$1(
+            false,
+            "%s is deprecated in StrictMode. " +
+              "%s was passed an instance of %s which renders StrictMode children. " +
+              "Instead, add a ref directly to the element you want to reference." +
+              "\n%s" +
+              "\n\nLearn more about using refs safely here:" +
+              "\nhttps://fb.me/react-strict-mode-find-node",
+            methodName,
+            methodName,
+            componentName,
+            getStackByFiberInDevAndProd(hostFiber)
+          );
+        }
+      }
+    }
+    return hostFiber.stateNode;
+  }
+  return findHostInstance$1(component);
+}
+
 function createContainer(containerInfo, isConcurrent, hydrate) {
   return createFiberRoot(containerInfo, isConcurrent, hydrate);
 }
@@ -15519,7 +17093,7 @@ function createPortal(
 
 // TODO: this is special because it gets imported during build.
 
-var ReactVersion = "16.5.2";
+var ReactVersion = "16.6.1";
 
 // Modules provided by RN:
 var NativeMethodsMixin = function(findNodeHandle, findHostInstance) {
@@ -15921,9 +17495,9 @@ function getInstanceFromTag(tag) {
 }
 
 // Module provided by RN:
-var emptyObject$2 = {};
+var emptyObject$1 = {};
 {
-  Object.freeze(emptyObject$2);
+  Object.freeze(emptyObject$1);
 }
 
 var getInspectorDataForViewTag = void 0;
@@ -15956,9 +17530,9 @@ var getInspectorDataForViewTag = void 0;
   var getHostProps = function(fiber) {
     var host = findCurrentHostFiber(fiber);
     if (host) {
-      return host.memoizedProps || emptyObject$2;
+      return host.memoizedProps || emptyObject$1;
     }
-    return emptyObject$2;
+    return emptyObject$1;
   };
 
   var getHostNode = function(fiber, findNodeHandle) {
@@ -16004,7 +17578,7 @@ var getInspectorDataForViewTag = void 0;
     if (!closestInstance) {
       return {
         hierarchy: [],
-        props: emptyObject$2,
+        props: emptyObject$1,
         selection: null,
         source: null
       };
@@ -16029,6 +17603,7 @@ var getInspectorDataForViewTag = void 0;
 
 var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 var findHostInstance = findHostInstance$1;
+var findHostInstanceWithWarning = findHostInstanceWithWarning$1;
 
 function findNodeHandle(componentOrHandle) {
   {
@@ -16062,7 +17637,14 @@ function findNodeHandle(componentOrHandle) {
   if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
     return componentOrHandle.canonical._nativeTag;
   }
-  var hostInstance = findHostInstance(componentOrHandle);
+  var hostInstance = void 0;
+  {
+    hostInstance = findHostInstanceWithWarning(
+      componentOrHandle,
+      "findNodeHandle"
+    );
+  }
+
   if (hostInstance == null) {
     return hostInstance;
   }
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-prod.js
@@ -19,7 +19,8 @@ var ReactNativeViewConfigRegistry = require("ReactNativeViewConfigRegistry"),
   flattenStyle = require("flattenStyle"),
   TextInputState = require("TextInputState"),
   FabricUIManager = require("FabricUIManager");
-var ExceptionsManager = require("ExceptionsManager");
+var scheduler = require("scheduler"),
+  ExceptionsManager = require("ExceptionsManager");
 function invariant(condition, format, a, b, c, d, e, f) {
   if (!condition) {
     condition = void 0;
@@ -166,10 +167,10 @@ var plugins = [],
   getFiberCurrentPropsFromNode = null,
   getInstanceFromNode = null,
   getNodeFromInstance = null;
-function executeDispatch(event, simulated, listener, inst) {
-  simulated = event.type || "unknown-event";
+function executeDispatch(event, listener, inst) {
+  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
-  invokeGuardedCallbackAndCatchFirstError(simulated, listener, void 0, event);
+  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
@@ -215,10 +216,10 @@ function executeDispatchesAndReleaseTopLevel(e) {
         i < dispatchListeners.length && !e.isPropagationStopped();
         i++
       )
-        executeDispatch(e, !1, dispatchListeners[i], dispatchInstances[i]);
+        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
     else
       dispatchListeners &&
-        executeDispatch(e, !1, dispatchListeners, dispatchInstances);
+        executeDispatch(e, dispatchListeners, dispatchInstances);
     e._dispatchListeners = null;
     e._dispatchInstances = null;
     e.isPersistent() || e.constructor.release(e);
@@ -293,7 +294,7 @@ function getListener(inst, registrationName) {
 }
 function getParent(inst) {
   do inst = inst.return;
-  while (inst && 7 !== inst.tag);
+  while (inst && 5 !== inst.tag);
   return inst ? inst : null;
 }
 function traverseTwoPhase(inst, fn, arg) {
@@ -1033,8 +1034,9 @@ var ReactSharedInternals =
     ? Symbol.for("react.concurrent_mode")
     : 60111,
   REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112,
-  REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for("react.placeholder") : 60113,
-  REACT_PURE_TYPE = hasSymbol ? Symbol.for("react.pure") : 60115,
+  REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
+  REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
+  REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
   MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
@@ -1058,29 +1060,28 @@ function getComponentName(type) {
       return "Profiler";
     case REACT_STRICT_MODE_TYPE:
       return "StrictMode";
-    case REACT_PLACEHOLDER_TYPE:
-      return "Placeholder";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
   }
-  if ("object" === typeof type) {
+  if ("object" === typeof type)
     switch (type.$$typeof) {
       case REACT_CONTEXT_TYPE:
         return "Context.Consumer";
       case REACT_PROVIDER_TYPE:
         return "Context.Provider";
       case REACT_FORWARD_REF_TYPE:
-        var renderFn = type.render;
-        renderFn = renderFn.displayName || renderFn.name || "";
+        var innerType = type.render;
+        innerType = innerType.displayName || innerType.name || "";
         return (
           type.displayName ||
-          ("" !== renderFn ? "ForwardRef(" + renderFn + ")" : "ForwardRef")
+          ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef")
         );
+      case REACT_MEMO_TYPE:
+        return getComponentName(type.type);
+      case REACT_LAZY_TYPE:
+        if ((type = 1 === type._status ? type._result : null))
+          return getComponentName(type);
     }
-    if (
-      "function" === typeof type.then &&
-      (type = 1 === type._reactStatus ? type._reactResult : null)
-    )
-      return getComponentName(type);
-  }
   return null;
 }
 function isFiberMountedImpl(fiber) {
@@ -1091,7 +1092,7 @@ function isFiberMountedImpl(fiber) {
     for (; node.return; )
       if (((node = node.return), 0 !== (node.effectTag & 2))) return 1;
   }
-  return 5 === node.tag ? 2 : 3;
+  return 3 === node.tag ? 2 : 3;
 }
 function assertIsMounted(fiber) {
   invariant(
@@ -1167,14 +1168,14 @@ function findCurrentFiberUsingSlowPath(fiber) {
       "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
     );
   }
-  invariant(5 === a.tag, "Unable to find node on an unmounted component.");
+  invariant(3 === a.tag, "Unable to find node on an unmounted component.");
   return a.stateNode.current === a ? fiber : alternate;
 }
 function findCurrentHostFiber(parent) {
   parent = findCurrentFiberUsingSlowPath(parent);
   if (!parent) return null;
   for (var node = parent; ; ) {
-    if (7 === node.tag || 8 === node.tag) return node;
+    if (5 === node.tag || 6 === node.tag) return node;
     if (node.child) (node.child.return = node), (node = node.child);
     else {
       if (node === parent) break;
@@ -1424,18 +1425,12 @@ var now$1 =
           return Date.now();
         },
   scheduledCallback = null,
-  frameDeadline = 0,
-  frameDeadlineObject = {
-    timeRemaining: function() {
-      return frameDeadline - now$1();
-    },
-    didTimeout: !1
-  };
+  frameDeadline = 0;
 function setTimeoutCallback() {
   frameDeadline = now$1() + 5;
   var callback = scheduledCallback;
   scheduledCallback = null;
-  null !== callback && callback(frameDeadlineObject);
+  null !== callback && callback();
 }
 var restoreTarget = null,
   restoreQueue = null;
@@ -1510,7 +1505,7 @@ function dispatchEvent(target, topLevelType, nativeEvent) {
 function shim$1() {
   invariant(
     !1,
-    "The current renderer does not support hyration. This error is likely caused by a bug in React. Please file an issue."
+    "The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue."
   );
 }
 var nextReactTag = 2;
@@ -1592,18 +1587,45 @@ function createTextInstance(
     )
   };
 }
+var scheduleTimeout = setTimeout,
+  cancelTimeout = clearTimeout;
+function cloneHiddenInstance(instance) {
+  var node = instance.node;
+  var updatePayload = diffProperties(
+    null,
+    emptyObject,
+    { style: { display: "none" } },
+    instance.canonical.viewConfig.validAttributes
+  );
+  return {
+    node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
+    canonical: instance.canonical
+  };
+}
+function cloneUnhiddenInstance(instance, type, props) {
+  var viewConfig = instance.canonical.viewConfig;
+  type = instance.node;
+  var prevProps = Object.assign({}, props, {
+    style: [props.style, { display: "none" }]
+  });
+  props = diffProperties(null, prevProps, props, viewConfig.validAttributes);
+  return {
+    node: FabricUIManager.cloneNodeWithNewProps(type, props),
+    canonical: instance.canonical
+  };
+}
 var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 function getStackByFiberInDevAndProd(workInProgress) {
   var info = "";
   do {
     a: switch (workInProgress.tag) {
-      case 4:
+      case 2:
+      case 16:
       case 0:
       case 1:
-      case 2:
-      case 3:
-      case 7:
-      case 10:
+      case 5:
+      case 8:
+      case 13:
         var owner = workInProgress._debugOwner,
           source = workInProgress._debugSource,
           name = getComponentName(workInProgress.type);
@@ -1754,7 +1776,7 @@ function injectInternals(internals) {
 function FiberNode(tag, pendingProps, key, mode) {
   this.tag = tag;
   this.key = key;
-  this.sibling = this.child = this.return = this.stateNode = this.type = null;
+  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
@@ -1765,29 +1787,33 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.childExpirationTime = this.expirationTime = 0;
   this.alternate = null;
 }
+function createFiber(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
 function shouldConstruct(Component) {
   Component = Component.prototype;
   return !(!Component || !Component.isReactComponent);
 }
-function resolveLazyComponentTag(fiber, Component) {
+function resolveLazyComponentTag(Component) {
   if ("function" === typeof Component)
-    return shouldConstruct(Component) ? 3 : 1;
+    return shouldConstruct(Component) ? 1 : 0;
   if (void 0 !== Component && null !== Component) {
-    fiber = Component.$$typeof;
-    if (fiber === REACT_FORWARD_REF_TYPE) return 14;
-    if (fiber === REACT_PURE_TYPE) return 18;
+    Component = Component.$$typeof;
+    if (Component === REACT_FORWARD_REF_TYPE) return 11;
+    if (Component === REACT_MEMO_TYPE) return 14;
   }
-  return 4;
+  return 2;
 }
 function createWorkInProgress(current, pendingProps) {
   var workInProgress = current.alternate;
   null === workInProgress
-    ? ((workInProgress = new FiberNode(
+    ? ((workInProgress = createFiber(
         current.tag,
         pendingProps,
         current.key,
         current.mode
       )),
+      (workInProgress.elementType = current.elementType),
       (workInProgress.type = current.type),
       (workInProgress.stateNode = current.stateNode),
       (workInProgress.alternate = current),
@@ -1809,60 +1835,66 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.ref = current.ref;
   return workInProgress;
 }
-function createFiberFromElement(element, mode, expirationTime) {
-  var type = element.type,
-    key = element.key;
-  element = element.props;
-  var fiberTag = void 0;
-  if ("function" === typeof type) fiberTag = shouldConstruct(type) ? 2 : 4;
-  else if ("string" === typeof type) fiberTag = 7;
+function createFiberFromTypeAndProps(
+  type,
+  key,
+  pendingProps,
+  owner,
+  mode,
+  expirationTime
+) {
+  var fiberTag = 2;
+  owner = type;
+  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
+  else if ("string" === typeof type) fiberTag = 5;
   else
     a: switch (type) {
       case REACT_FRAGMENT_TYPE:
         return createFiberFromFragment(
-          element.children,
+          pendingProps.children,
           mode,
           expirationTime,
           key
         );
       case REACT_CONCURRENT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 3;
-        break;
+        return createFiberFromMode(pendingProps, mode | 3, expirationTime, key);
       case REACT_STRICT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 2;
-        break;
+        return createFiberFromMode(pendingProps, mode | 2, expirationTime, key);
       case REACT_PROFILER_TYPE:
         return (
-          (type = new FiberNode(15, element, key, mode | 4)),
+          (type = createFiber(12, pendingProps, key, mode | 4)),
+          (type.elementType = REACT_PROFILER_TYPE),
           (type.type = REACT_PROFILER_TYPE),
           (type.expirationTime = expirationTime),
           type
         );
-      case REACT_PLACEHOLDER_TYPE:
-        fiberTag = 16;
-        break;
+      case REACT_SUSPENSE_TYPE:
+        return (
+          (type = createFiber(13, pendingProps, key, mode)),
+          (type.elementType = REACT_SUSPENSE_TYPE),
+          (type.type = REACT_SUSPENSE_TYPE),
+          (type.expirationTime = expirationTime),
+          type
+        );
       default:
         if ("object" === typeof type && null !== type)
           switch (type.$$typeof) {
             case REACT_PROVIDER_TYPE:
-              fiberTag = 12;
+              fiberTag = 10;
               break a;
             case REACT_CONTEXT_TYPE:
-              fiberTag = 11;
+              fiberTag = 9;
               break a;
             case REACT_FORWARD_REF_TYPE:
-              fiberTag = 13;
+              fiberTag = 11;
               break a;
-            case REACT_PURE_TYPE:
-              fiberTag = 17;
+            case REACT_MEMO_TYPE:
+              fiberTag = 14;
+              break a;
+            case REACT_LAZY_TYPE:
+              fiberTag = 16;
+              owner = null;
               break a;
-            default:
-              if ("function" === typeof type.then) {
-                fiberTag = 4;
-                break a;
-              }
           }
         invariant(
           !1,
@@ -1871,24 +1903,33 @@ function createFiberFromElement(element, mode, expirationTime) {
           ""
         );
     }
-  mode = new FiberNode(fiberTag, element, key, mode);
-  mode.type = type;
-  mode.expirationTime = expirationTime;
-  return mode;
+  key = createFiber(fiberTag, pendingProps, key, mode);
+  key.elementType = type;
+  key.type = owner;
+  key.expirationTime = expirationTime;
+  return key;
 }
 function createFiberFromFragment(elements, mode, expirationTime, key) {
-  elements = new FiberNode(9, elements, key, mode);
+  elements = createFiber(7, elements, key, mode);
   elements.expirationTime = expirationTime;
   return elements;
 }
+function createFiberFromMode(pendingProps, mode, expirationTime, key) {
+  pendingProps = createFiber(8, pendingProps, key, mode);
+  mode = 0 === (mode & 1) ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
+  pendingProps.elementType = mode;
+  pendingProps.type = mode;
+  pendingProps.expirationTime = expirationTime;
+  return pendingProps;
+}
 function createFiberFromText(content, mode, expirationTime) {
-  content = new FiberNode(8, content, null, mode);
+  content = createFiber(6, content, null, mode);
   content.expirationTime = expirationTime;
   return content;
 }
 function createFiberFromPortal(portal, mode, expirationTime) {
-  mode = new FiberNode(
-    6,
+  mode = createFiber(
+    4,
     null !== portal.children ? portal.children : [],
     portal.key,
     mode
@@ -1906,12 +1947,45 @@ function markPendingPriorityLevel(root, expirationTime) {
   var earliestPendingTime = root.earliestPendingTime;
   0 === earliestPendingTime
     ? (root.earliestPendingTime = root.latestPendingTime = expirationTime)
-    : earliestPendingTime > expirationTime
+    : earliestPendingTime < expirationTime
       ? (root.earliestPendingTime = expirationTime)
-      : root.latestPendingTime < expirationTime &&
+      : root.latestPendingTime > expirationTime &&
         (root.latestPendingTime = expirationTime);
   findNextExpirationTimeToWorkOn(expirationTime, root);
 }
+function markSuspendedPriorityLevel(root, suspendedTime) {
+  root.didError = !1;
+  var latestPingedTime = root.latestPingedTime;
+  0 !== latestPingedTime &&
+    latestPingedTime >= suspendedTime &&
+    (root.latestPingedTime = 0);
+  latestPingedTime = root.earliestPendingTime;
+  var latestPendingTime = root.latestPendingTime;
+  latestPingedTime === suspendedTime
+    ? (root.earliestPendingTime =
+        latestPendingTime === suspendedTime
+          ? (root.latestPendingTime = 0)
+          : latestPendingTime)
+    : latestPendingTime === suspendedTime &&
+      (root.latestPendingTime = latestPingedTime);
+  latestPingedTime = root.earliestSuspendedTime;
+  latestPendingTime = root.latestSuspendedTime;
+  0 === latestPingedTime
+    ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
+    : latestPingedTime < suspendedTime
+      ? (root.earliestSuspendedTime = suspendedTime)
+      : latestPendingTime > suspendedTime &&
+        (root.latestSuspendedTime = suspendedTime);
+  findNextExpirationTimeToWorkOn(suspendedTime, root);
+}
+function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
+  var earliestPendingTime = root.earliestPendingTime;
+  root = root.earliestSuspendedTime;
+  earliestPendingTime > renderExpirationTime &&
+    (renderExpirationTime = earliestPendingTime);
+  root > renderExpirationTime && (renderExpirationTime = root);
+  return renderExpirationTime;
+}
 function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   var earliestSuspendedTime = root.earliestSuspendedTime,
     latestSuspendedTime = root.latestSuspendedTime,
@@ -1921,12 +1995,11 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
     0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
   0 === earliestPendingTime &&
     (0 === completedExpirationTime ||
-      latestSuspendedTime > completedExpirationTime) &&
+      latestSuspendedTime < completedExpirationTime) &&
     (earliestPendingTime = latestSuspendedTime);
   completedExpirationTime = earliestPendingTime;
   0 !== completedExpirationTime &&
-    0 !== earliestSuspendedTime &&
-    earliestSuspendedTime < completedExpirationTime &&
+    earliestSuspendedTime > completedExpirationTime &&
     (completedExpirationTime = earliestSuspendedTime);
   root.nextExpirationTimeToWorkOn = earliestPendingTime;
   root.expirationTime = completedExpirationTime;
@@ -2038,7 +2111,7 @@ function getStateFromUpdate(
           : workInProgress
       );
     case 3:
-      workInProgress.effectTag = (workInProgress.effectTag & -1025) | 64;
+      workInProgress.effectTag = (workInProgress.effectTag & -2049) | 64;
     case 0:
       workInProgress = update.payload;
       nextProps =
@@ -2071,58 +2144,52 @@ function processUpdateQueue(
 
   ) {
     var updateExpirationTime = update.expirationTime;
-    if (updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === newFirstUpdate &&
+    updateExpirationTime < renderExpirationTime
+      ? (null === newFirstUpdate &&
           ((newFirstUpdate = update), (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > updateExpirationTime)
-      )
-        newExpirationTime = updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < updateExpirationTime &&
+          (newExpirationTime = updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastEffect
             ? (queue.firstEffect = queue.lastEffect = update)
             : ((queue.lastEffect.nextEffect = update),
-              (queue.lastEffect = update)));
+              (queue.lastEffect = update))));
     update = update.next;
   }
   updateExpirationTime = null;
   for (update = queue.firstCapturedUpdate; null !== update; ) {
     var _updateExpirationTime = update.expirationTime;
-    if (_updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === updateExpirationTime &&
+    _updateExpirationTime < renderExpirationTime
+      ? (null === updateExpirationTime &&
           ((updateExpirationTime = update),
           null === newFirstUpdate && (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > _updateExpirationTime)
-      )
-        newExpirationTime = _updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < _updateExpirationTime &&
+          (newExpirationTime = _updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastCapturedEffect
             ? (queue.firstCapturedEffect = queue.lastCapturedEffect = update)
             : ((queue.lastCapturedEffect.nextEffect = update),
-              (queue.lastCapturedEffect = update)));
+              (queue.lastCapturedEffect = update))));
     update = update.next;
   }
   null === newFirstUpdate && (queue.lastUpdate = null);
@@ -2203,13 +2270,277 @@ function readContext(context, observedBits) {
     null === lastContextDependency
       ? (invariant(
           null !== currentlyRenderingFiber,
-          "Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
+          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
         ),
         (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
       : (lastContextDependency = lastContextDependency.next = observedBits);
   }
   return context._currentValue2;
 }
+function areHookInputsEqual(arr1, arr2) {
+  for (var i = 0; i < arr1.length; i++) {
+    var val1 = arr1[i],
+      val2 = arr2[i];
+    if (
+      (val1 !== val2 || (0 === val1 && 1 / val1 !== 1 / val2)) &&
+      (val1 === val1 || val2 === val2)
+    )
+      return !1;
+  }
+  return !0;
+}
+var renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  isReRender = !1,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = 0;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function finishHooks(Component, props, children, refOrContext) {
+  for (; didScheduleRenderPhaseUpdate; )
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (children = Component(props, refOrContext));
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return children;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.memoizedState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((isReRender = !1),
+        (currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((isReRender = !0),
+        (currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    isReRender = !1;
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (isReRender = !0),
+      (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (isReRender) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do
+            (initialAction = reducer(
+              initialAction,
+              firstRenderPhaseUpdate.action
+            )),
+              (firstRenderPhaseUpdate = firstRenderPhaseUpdate.next);
+          while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      initialAction = workInProgressHook.baseState;
+      var newBaseUpdate = (firstRenderPhaseUpdate = null),
+        _update = initialState,
+        didSkip = !1;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (newBaseUpdate = _baseUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : (initialAction = reducer(initialAction, _update.action));
+        _baseUpdate = _update;
+        _update = _update.next;
+      } while (null !== _update && _update !== initialState);
+      didSkip ||
+        ((newBaseUpdate = _baseUpdate),
+        (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = { last: null, dispatch: null };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, inputs) {
+  tag = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    inputs: inputs,
+    next: null
+  };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  inputs = void 0 !== inputs && null !== inputs ? inputs : [create];
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (areHookInputsEqual(inputs, prevEffect.inputs)) {
+      pushEffect(0, create, destroy, inputs);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    inputs
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (alternate = renderPhaseUpdates.get(queue)),
+      void 0 === alternate)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = alternate; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    alternate = requestCurrentTime();
+    alternate = computeExpirationForFiber(alternate, fiber);
+    action = { expirationTime: alternate, action: action, next: null };
+    flushPassiveEffects();
+    var _last2 = queue.last;
+    if (null === _last2) action.next = action;
+    else {
+      var first = _last2.next;
+      null !== first && (action.next = first);
+      _last2.next = action;
+    }
+    queue.last = action;
+    scheduleWork(fiber, alternate);
+  }
+}
 var NO_CONTEXT = {},
   contextStackCursor$1 = { current: NO_CONTEXT },
   contextFiberStackCursor = { current: NO_CONTEXT },
@@ -2279,7 +2610,47 @@ function shallowEqual(objA, objB) {
       return !1;
   return !0;
 }
-var emptyRefsObject = new React.Component().refs;
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    baseProps = Object.assign({}, baseProps);
+    Component = Component.defaultProps;
+    for (var propName in Component)
+      void 0 === baseProps[propName] &&
+        (baseProps[propName] = Component[propName]);
+  }
+  return baseProps;
+}
+function readLazyComponentType(lazyComponent) {
+  var result = lazyComponent._result;
+  switch (lazyComponent._status) {
+    case 1:
+      return result;
+    case 2:
+      throw result;
+    case 0:
+      throw result;
+    default:
+      throw ((lazyComponent._status = 0),
+      (result = lazyComponent._ctor),
+      (result = result()),
+      result.then(
+        function(moduleObject) {
+          0 === lazyComponent._status &&
+            ((moduleObject = moduleObject.default),
+            (lazyComponent._status = 1),
+            (lazyComponent._result = moduleObject));
+        },
+        function(error) {
+          0 === lazyComponent._status &&
+            ((lazyComponent._status = 2), (lazyComponent._result = error));
+        }
+      ),
+      (lazyComponent._result = result),
+      result);
+  }
+}
+var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
+  emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2311,6 +2682,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2322,6 +2694,7 @@ var classComponentUpdater = {
     update.tag = 1;
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2332,6 +2705,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.tag = 2;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   }
@@ -2352,6 +2726,32 @@ function checkShouldComponentUpdate(
       ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
       : !0;
 }
+function constructClassInstance(workInProgress, ctor, props) {
+  var isLegacyContextConsumer = !1,
+    unmaskedContext = emptyContextObject;
+  var context = ctor.contextType;
+  "object" === typeof context && null !== context
+    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    : ((unmaskedContext = isContextProvider(ctor)
+        ? previousContext
+        : contextStackCursor.current),
+      (isLegacyContextConsumer = ctor.contextTypes),
+      (context = (isLegacyContextConsumer =
+        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
+        ? getMaskedContext(workInProgress, unmaskedContext)
+        : emptyContextObject));
+  ctor = new ctor(props, context);
+  workInProgress.memoizedState =
+    null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
+  ctor.updater = classComponentUpdater;
+  workInProgress.stateNode = ctor;
+  ctor._reactInternalFiber = workInProgress;
+  isLegacyContextConsumer &&
+    ((workInProgress = workInProgress.stateNode),
+    (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
+    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
+  return ctor;
+}
 function callComponentWillReceiveProps(
   workInProgress,
   instance,
@@ -2378,7 +2778,9 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = contextType.unstable_read())
+    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
+        contextType
+      ))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2433,10 +2835,7 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(
-          2 === element.tag || 3 === element.tag,
-          "Function components cannot have refs."
-        ),
+        (invariant(1 === element.tag, "Function components cannot have refs."),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -2541,7 +2940,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     textContent,
     expirationTime
   ) {
-    if (null === current$$1 || 8 !== current$$1.tag)
+    if (null === current$$1 || 6 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromText(
           textContent,
@@ -2556,15 +2955,18 @@ function ChildReconciler(shouldTrackSideEffects) {
     return current$$1;
   }
   function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (null !== current$$1 && current$$1.type === element.type)
+    if (null !== current$$1 && current$$1.elementType === element.type)
       return (
         (expirationTime = useFiber(current$$1, element.props, expirationTime)),
         (expirationTime.ref = coerceRef(returnFiber, current$$1, element)),
         (expirationTime.return = returnFiber),
         expirationTime
       );
-    expirationTime = createFiberFromElement(
-      element,
+    expirationTime = createFiberFromTypeAndProps(
+      element.type,
+      element.key,
+      element.props,
+      null,
       returnFiber.mode,
       expirationTime
     );
@@ -2575,7 +2977,7 @@ function ChildReconciler(shouldTrackSideEffects) {
   function updatePortal(returnFiber, current$$1, portal, expirationTime) {
     if (
       null === current$$1 ||
-      6 !== current$$1.tag ||
+      4 !== current$$1.tag ||
       current$$1.stateNode.containerInfo !== portal.containerInfo ||
       current$$1.stateNode.implementation !== portal.implementation
     )
@@ -2599,7 +3001,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     expirationTime,
     key
   ) {
-    if (null === current$$1 || 9 !== current$$1.tag)
+    if (null === current$$1 || 7 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromFragment(
           fragment,
@@ -2629,8 +3031,11 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
           return (
-            (expirationTime = createFiberFromElement(
-              newChild,
+            (expirationTime = createFiberFromTypeAndProps(
+              newChild.type,
+              newChild.key,
+              newChild.props,
+              null,
               returnFiber.mode,
               expirationTime
             )),
@@ -2974,9 +3379,9 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (isUnkeyedTopLevelFragment.key === isObject)
                 if (
-                  9 === isUnkeyedTopLevelFragment.tag
+                  7 === isUnkeyedTopLevelFragment.tag
                     ? newChild.type === REACT_FRAGMENT_TYPE
-                    : isUnkeyedTopLevelFragment.type === newChild.type
+                    : isUnkeyedTopLevelFragment.elementType === newChild.type
                 ) {
                   deleteRemainingChildren(
                     returnFiber,
@@ -3016,8 +3421,11 @@ function ChildReconciler(shouldTrackSideEffects) {
                 )),
                 (currentFirstChild.return = returnFiber),
                 (returnFiber = currentFirstChild))
-              : ((expirationTime = createFiberFromElement(
-                  newChild,
+              : ((expirationTime = createFiberFromTypeAndProps(
+                  newChild.type,
+                  newChild.key,
+                  newChild.props,
+                  null,
                   returnFiber.mode,
                   expirationTime
                 )),
@@ -3039,7 +3447,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (currentFirstChild.key === isUnkeyedTopLevelFragment)
                 if (
-                  6 === currentFirstChild.tag &&
+                  4 === currentFirstChild.tag &&
                   currentFirstChild.stateNode.containerInfo ===
                     newChild.containerInfo &&
                   currentFirstChild.stateNode.implementation ===
@@ -3077,7 +3485,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (newChild = "" + newChild),
-        null !== currentFirstChild && 8 === currentFirstChild.tag
+        null !== currentFirstChild && 6 === currentFirstChild.tag
           ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
             (currentFirstChild = useFiber(
               currentFirstChild,
@@ -3113,8 +3521,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     isObject && throwOnInvalidObjectType(returnFiber, newChild);
     if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
       switch (returnFiber.tag) {
-        case 2:
-        case 3:
+        case 1:
         case 0:
           (expirationTime = returnFiber.type),
             invariant(
@@ -3133,12 +3540,12 @@ var reconcileChildFibers = ChildReconciler(!0),
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
   switch (fiber.tag) {
-    case 7:
+    case 5:
       return (
         (nextInstance = shim$1(nextInstance, fiber.type, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
       );
-    case 8:
+    case 6:
       return (
         (nextInstance = shim$1(nextInstance, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
@@ -3161,7 +3568,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
           return;
         }
         var returnFiber = hydrationParentFiber,
-          fiber = new FiberNode(7, null, null, 0);
+          fiber = createFiber(5, null, null, 0);
+        fiber.elementType = "DELETED";
         fiber.type = "DELETED";
         fiber.stateNode = firstAttemptedInstance;
         fiber.return = returnFiber;
@@ -3179,38 +3587,6 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-function readLazyComponentType(thenable) {
-  switch (thenable._reactStatus) {
-    case 1:
-      return thenable._reactResult;
-    case 2:
-      throw thenable._reactResult;
-    case 0:
-      throw thenable;
-    default:
-      throw ((thenable._reactStatus = 0),
-      thenable.then(
-        function(resolvedValue) {
-          if (0 === thenable._reactStatus) {
-            thenable._reactStatus = 1;
-            if ("object" === typeof resolvedValue && null !== resolvedValue) {
-              var defaultExport = resolvedValue.default;
-              resolvedValue =
-                void 0 !== defaultExport && null !== defaultExport
-                  ? defaultExport
-                  : resolvedValue;
-            }
-            thenable._reactResult = resolvedValue;
-          }
-        },
-        function(error) {
-          0 === thenable._reactStatus &&
-            ((thenable._reactStatus = 2), (thenable._reactResult = error));
-        }
-      ),
-      thenable);
-  }
-}
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 function reconcileChildren(
   current$$1,
@@ -3236,28 +3612,28 @@ function reconcileChildren(
 function updateForwardRef(
   current$$1,
   workInProgress,
-  type,
+  Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
-  type = type.render;
+  Component = Component.render;
   var ref = workInProgress.ref;
-  if (
-    !didPerformWorkStackCursor.current &&
-    workInProgress.memoizedProps === nextProps &&
-    ref === (null !== current$$1 ? current$$1.ref : null)
-  )
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  type = type(nextProps, ref);
-  reconcileChildren(current$$1, workInProgress, type, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, ref);
+  nextChildren = finishHooks(Component, nextProps, nextChildren, ref);
+  workInProgress.effectTag |= 1;
+  reconcileChildren(
+    current$$1,
+    workInProgress,
+    nextChildren,
+    renderExpirationTime$jscomp$0
+  );
   return workInProgress.child;
 }
-function updatePureComponent(
+function updateMemoComponent(
   current$$1,
   workInProgress,
   Component,
@@ -3265,27 +3641,82 @@ function updatePureComponent(
   updateExpirationTime,
   renderExpirationTime
 ) {
-  var render = Component.render;
+  if (null === current$$1) {
+    var type = Component.type;
+    if (
+      "function" === typeof type &&
+      !shouldConstruct(type) &&
+      void 0 === type.defaultProps &&
+      null === Component.compare
+    )
+      return (
+        (workInProgress.tag = 15),
+        (workInProgress.type = type),
+        updateSimpleMemoComponent(
+          current$$1,
+          workInProgress,
+          type,
+          nextProps,
+          updateExpirationTime,
+          renderExpirationTime
+        )
+      );
+    current$$1 = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      null,
+      workInProgress.mode,
+      renderExpirationTime
+    );
+    current$$1.ref = workInProgress.ref;
+    current$$1.return = workInProgress;
+    return (workInProgress.child = current$$1);
+  }
+  type = current$$1.child;
   if (
-    null !== current$$1 &&
-    (0 === updateExpirationTime ||
-      updateExpirationTime > renderExpirationTime) &&
-    ((updateExpirationTime = current$$1.memoizedProps),
+    updateExpirationTime < renderExpirationTime &&
+    ((updateExpirationTime = type.memoizedProps),
     (Component = Component.compare),
     (Component = null !== Component ? Component : shallowEqual),
-    Component(updateExpirationTime, nextProps))
+    Component(updateExpirationTime, nextProps) &&
+      current$$1.ref === workInProgress.ref)
   )
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
       renderExpirationTime
     );
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  render = render(nextProps);
   workInProgress.effectTag |= 1;
-  reconcileChildren(current$$1, workInProgress, render, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
-  return workInProgress.child;
+  current$$1 = createWorkInProgress(type, nextProps, renderExpirationTime);
+  current$$1.ref = workInProgress.ref;
+  current$$1.return = workInProgress;
+  return (workInProgress.child = current$$1);
+}
+function updateSimpleMemoComponent(
+  current$$1,
+  workInProgress,
+  Component,
+  nextProps,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  return null !== current$$1 &&
+    updateExpirationTime < renderExpirationTime &&
+    shallowEqual(current$$1.memoizedProps, nextProps) &&
+    current$$1.ref === workInProgress.ref
+    ? bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    : updateFunctionComponent(
+        current$$1,
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      );
 }
 function markRef(current$$1, workInProgress) {
   var ref = workInProgress.ref;
@@ -3300,22 +3731,30 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
   var unmaskedContext = isContextProvider(Component)
     ? previousContext
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, unmaskedContext);
+  nextChildren = finishHooks(
+    Component,
+    nextProps,
+    nextChildren,
+    unmaskedContext
+  );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
     workInProgress,
-    Component,
-    renderExpirationTime
+    nextChildren,
+    renderExpirationTime$jscomp$0
   );
-  workInProgress.memoizedProps = nextProps;
   return workInProgress.child;
 }
 function updateClassComponent(
@@ -3330,82 +3769,153 @@ function updateClassComponent(
     pushContextProvider(workInProgress);
   } else hasContext = !1;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  if (null === current$$1)
-    if (null === workInProgress.stateNode) {
-      var isLegacyContextConsumer = !1,
-        unmaskedContext = emptyContextObject;
-      var context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((unmaskedContext = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (isLegacyContextConsumer = Component.contextTypes),
-          (context = (isLegacyContextConsumer =
-            null !== isLegacyContextConsumer &&
-            void 0 !== isLegacyContextConsumer)
-            ? getMaskedContext(workInProgress, unmaskedContext)
-            : emptyContextObject));
-      var instance = new Component(nextProps, context);
-      workInProgress.memoizedState =
-        null !== instance.state && void 0 !== instance.state
-          ? instance.state
-          : null;
-      instance.updater = classComponentUpdater;
-      workInProgress.stateNode = instance;
-      instance._reactInternalFiber = workInProgress;
-      isLegacyContextConsumer &&
-        ((isLegacyContextConsumer = workInProgress.stateNode),
-        (isLegacyContextConsumer.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
-        (isLegacyContextConsumer.__reactInternalMemoizedMaskedChildContext = context));
+  if (null === workInProgress.stateNode)
+    null !== current$$1 &&
+      ((current$$1.alternate = null),
+      (workInProgress.alternate = null),
+      (workInProgress.effectTag |= 2)),
+      constructClassInstance(
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      ),
       mountClassInstance(
         workInProgress,
         Component,
         nextProps,
         renderExpirationTime
-      );
-      nextProps = !0;
-    } else {
-      unmaskedContext = workInProgress.stateNode;
-      isLegacyContextConsumer = workInProgress.memoizedProps;
-      unmaskedContext.props = isLegacyContextConsumer;
-      var oldContext = unmaskedContext.context;
-      context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
+      ),
+      (nextProps = !0);
+  else if (null === current$$1) {
+    var instance = workInProgress.stateNode,
+      oldProps = workInProgress.memoizedProps;
+    instance.props = oldProps;
+    var oldContext = instance.context,
+      contextType = Component.contextType;
+    "object" === typeof contextType && null !== contextType
+      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+          contextType
+        ))
+      : ((contextType = isContextProvider(Component)
+          ? previousContext
+          : contextStackCursor.current),
+        (contextType = getMaskedContext(workInProgress, contextType)));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
+      hasNewLifecycles =
+        "function" === typeof getDerivedStateFromProps ||
+        "function" === typeof instance.getSnapshotBeforeUpdate;
+    hasNewLifecycles ||
+      ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof instance.componentWillReceiveProps) ||
+      ((oldProps !== nextProps || oldContext !== contextType) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          instance,
+          nextProps,
+          contextType
+        ));
+    hasForceUpdate = !1;
+    var oldState = workInProgress.memoizedState;
+    oldContext = instance.state = oldState;
+    var updateQueue = workInProgress.updateQueue;
+    null !== updateQueue &&
+      (processUpdateQueue(
+        workInProgress,
+        updateQueue,
+        nextProps,
+        instance,
+        renderExpirationTime
+      ),
+      (oldContext = workInProgress.memoizedState));
+    oldProps !== nextProps ||
+    oldState !== oldContext ||
+    didPerformWorkStackCursor.current ||
+    hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps,
+            nextProps
+          ),
+          (oldContext = workInProgress.memoizedState)),
+        (oldProps =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
+            workInProgress,
+            Component,
+            oldProps,
+            nextProps,
+            oldState,
+            oldContext,
+            contextType
+          ))
+          ? (hasNewLifecycles ||
+              ("function" !== typeof instance.UNSAFE_componentWillMount &&
+                "function" !== typeof instance.componentWillMount) ||
+              ("function" === typeof instance.componentWillMount &&
+                instance.componentWillMount(),
+              "function" === typeof instance.UNSAFE_componentWillMount &&
+                instance.UNSAFE_componentWillMount()),
+            "function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4))
+          : ("function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = oldContext)),
+        (instance.props = nextProps),
+        (instance.state = oldContext),
+        (instance.context = contextType),
+        (nextProps = oldProps))
+      : ("function" === typeof instance.componentDidMount &&
+          (workInProgress.effectTag |= 4),
+        (nextProps = !1));
+  } else
+    (instance = workInProgress.stateNode),
+      (oldProps = workInProgress.memoizedProps),
+      (instance.props =
+        workInProgress.type === workInProgress.elementType
+          ? oldProps
+          : resolveDefaultProps(workInProgress.type, oldProps)),
+      (oldContext = instance.context),
+      (contextType = Component.contextType),
+      "object" === typeof contextType && null !== contextType
+        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+            contextType
+          ))
+        : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context)));
-      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
-      (instance =
+          (contextType = getMaskedContext(workInProgress, contextType))),
+      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
+      (hasNewLifecycles =
         "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
+        "function" === typeof instance.getSnapshotBeforeUpdate) ||
+        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+          "function" !== typeof instance.componentWillReceiveProps) ||
+        ((oldProps !== nextProps || oldContext !== contextType) &&
           callComponentWillReceiveProps(
             workInProgress,
-            unmaskedContext,
+            instance,
             nextProps,
-            context
-          ));
-      hasForceUpdate = !1;
-      var oldState = workInProgress.memoizedState;
-      oldContext = unmaskedContext.state = oldState;
-      var updateQueue = workInProgress.updateQueue;
+            contextType
+          )),
+      (hasForceUpdate = !1),
+      (oldContext = workInProgress.memoizedState),
+      (oldState = instance.state = oldContext),
+      (updateQueue = workInProgress.updateQueue),
       null !== updateQueue &&
         (processUpdateQueue(
           workInProgress,
           updateQueue,
           nextProps,
-          unmaskedContext,
+          instance,
           renderExpirationTime
         ),
-        (oldContext = workInProgress.memoizedState));
-      isLegacyContextConsumer !== nextProps ||
-      oldState !== oldContext ||
+        (oldState = workInProgress.memoizedState)),
+      oldProps !== nextProps ||
+      oldContext !== oldState ||
       didPerformWorkStackCursor.current ||
       hasForceUpdate
         ? ("function" === typeof getDerivedStateFromProps &&
@@ -3415,144 +3925,57 @@ function updateClassComponent(
               getDerivedStateFromProps,
               nextProps
             ),
-            (oldContext = workInProgress.memoizedState)),
-          (isLegacyContextConsumer =
+            (oldState = workInProgress.memoizedState)),
+          (getDerivedStateFromProps =
             hasForceUpdate ||
             checkShouldComponentUpdate(
               workInProgress,
               Component,
-              isLegacyContextConsumer,
+              oldProps,
               nextProps,
-              oldState,
               oldContext,
-              context
+              oldState,
+              contextType
             ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  "function" !== typeof unmaskedContext.componentWillMount) ||
-                ("function" === typeof unmaskedContext.componentWillMount &&
-                  unmaskedContext.componentWillMount(),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  unmaskedContext.UNSAFE_componentWillMount()),
-              "function" === typeof unmaskedContext.componentDidMount &&
-                (workInProgress.effectTag |= 4))
-            : ("function" === typeof unmaskedContext.componentDidMount &&
-                (workInProgress.effectTag |= 4),
-              (workInProgress.memoizedProps = nextProps),
-              (workInProgress.memoizedState = oldContext)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldContext),
-          (unmaskedContext.context = context),
-          (nextProps = isLegacyContextConsumer))
-        : ("function" === typeof unmaskedContext.componentDidMount &&
-            (workInProgress.effectTag |= 4),
-          (nextProps = !1));
-    }
-  else
-    (unmaskedContext = workInProgress.stateNode),
-      (isLegacyContextConsumer = workInProgress.memoizedProps),
-      (unmaskedContext.props = isLegacyContextConsumer),
-      (oldContext = unmaskedContext.context),
-      (context = Component.contextType),
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context))),
-      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
-      (instance =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
-          callComponentWillReceiveProps(
-            workInProgress,
-            unmaskedContext,
-            nextProps,
-            context
-          )),
-      (hasForceUpdate = !1),
-      (oldContext = workInProgress.memoizedState),
-      (oldState = unmaskedContext.state = oldContext),
-      (updateQueue = workInProgress.updateQueue),
-      null !== updateQueue &&
-        (processUpdateQueue(
-          workInProgress,
-          updateQueue,
-          nextProps,
-          unmaskedContext,
-          renderExpirationTime
-        ),
-        (oldState = workInProgress.memoizedState)),
-      isLegacyContextConsumer !== nextProps ||
-      oldContext !== oldState ||
-      didPerformWorkStackCursor.current ||
-      hasForceUpdate
-        ? ("function" === typeof getDerivedStateFromProps &&
-            (applyDerivedStateFromProps(
-              workInProgress,
-              Component,
-              getDerivedStateFromProps,
-              nextProps
-            ),
-            (oldState = workInProgress.memoizedState)),
-          (getDerivedStateFromProps =
-            hasForceUpdate ||
-            checkShouldComponentUpdate(
-              workInProgress,
-              Component,
-              isLegacyContextConsumer,
-              nextProps,
-              oldContext,
-              oldState,
-              context
-            ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  "function" !== typeof unmaskedContext.componentWillUpdate) ||
-                ("function" === typeof unmaskedContext.componentWillUpdate &&
-                  unmaskedContext.componentWillUpdate(
+            ? (hasNewLifecycles ||
+                ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
+                  "function" !== typeof instance.componentWillUpdate) ||
+                ("function" === typeof instance.componentWillUpdate &&
+                  instance.componentWillUpdate(
                     nextProps,
                     oldState,
-                    context
+                    contextType
                   ),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  unmaskedContext.UNSAFE_componentWillUpdate(
+                "function" === typeof instance.UNSAFE_componentWillUpdate &&
+                  instance.UNSAFE_componentWillUpdate(
                     nextProps,
                     oldState,
-                    context
+                    contextType
                   )),
-              "function" === typeof unmaskedContext.componentDidUpdate &&
+              "function" === typeof instance.componentDidUpdate &&
                 (workInProgress.effectTag |= 4),
-              "function" === typeof unmaskedContext.getSnapshotBeforeUpdate &&
+              "function" === typeof instance.getSnapshotBeforeUpdate &&
                 (workInProgress.effectTag |= 256))
-            : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
+            : ("function" !== typeof instance.componentDidUpdate ||
+                (oldProps === current$$1.memoizedProps &&
                   oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 4),
-              "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
+              "function" !== typeof instance.getSnapshotBeforeUpdate ||
+                (oldProps === current$$1.memoizedProps &&
                   oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 256),
               (workInProgress.memoizedProps = nextProps),
               (workInProgress.memoizedState = oldState)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldState),
-          (unmaskedContext.context = context),
+          (instance.props = nextProps),
+          (instance.state = oldState),
+          (instance.context = contextType),
           (nextProps = getDerivedStateFromProps))
-        : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+        : ("function" !== typeof instance.componentDidUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 4),
-          "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+          "function" !== typeof instance.getSnapshotBeforeUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 256),
           (nextProps = !1));
@@ -3611,7 +4034,6 @@ function finishClassComponent(
         renderExpirationTime
       );
   workInProgress.memoizedState = shouldUpdate.state;
-  workInProgress.memoizedProps = shouldUpdate.props;
   hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
@@ -3627,15 +4049,101 @@ function pushHostRootContext(workInProgress) {
       pushTopLevelContextObject(workInProgress, root.context, !1);
   pushHostContainer(workInProgress, root.containerInfo);
 }
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    baseProps = Object.assign({}, baseProps);
-    Component = Component.defaultProps;
-    for (var propName in Component)
-      void 0 === baseProps[propName] &&
-        (baseProps[propName] = Component[propName]);
-  }
-  return baseProps;
+function updateSuspenseComponent(
+  current$$1,
+  workInProgress,
+  renderExpirationTime
+) {
+  var mode = workInProgress.mode,
+    nextProps = workInProgress.pendingProps,
+    nextState = workInProgress.memoizedState;
+  if (0 === (workInProgress.effectTag & 64)) {
+    nextState = null;
+    var nextDidTimeout = !1;
+  } else
+    (nextState = { timedOutAt: null !== nextState ? nextState.timedOutAt : 0 }),
+      (nextDidTimeout = !0),
+      (workInProgress.effectTag &= -65);
+  null === current$$1
+    ? nextDidTimeout
+      ? ((nextDidTimeout = nextProps.fallback),
+        (nextProps = createFiberFromFragment(null, mode, 0, null)),
+        0 === (workInProgress.mode & 1) &&
+          (nextProps.child =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child),
+        (mode = createFiberFromFragment(
+          nextDidTimeout,
+          mode,
+          renderExpirationTime,
+          null
+        )),
+        (nextProps.sibling = mode),
+        (renderExpirationTime = nextProps),
+        (renderExpirationTime.return = mode.return = workInProgress))
+      : (renderExpirationTime = mode = mountChildFibers(
+          workInProgress,
+          null,
+          nextProps.children,
+          renderExpirationTime
+        ))
+    : null !== current$$1.memoizedState
+      ? ((mode = current$$1.child),
+        (current$$1 = mode.sibling),
+        nextDidTimeout
+          ? ((renderExpirationTime = nextProps.fallback),
+            (nextProps = createWorkInProgress(mode, mode.pendingProps, 0)),
+            0 === (workInProgress.mode & 1) &&
+              ((nextDidTimeout =
+                null !== workInProgress.memoizedState
+                  ? workInProgress.child.child
+                  : workInProgress.child),
+              nextDidTimeout !== mode.child &&
+                (nextProps.child = nextDidTimeout)),
+            (mode = nextProps.sibling = createWorkInProgress(
+              current$$1,
+              renderExpirationTime,
+              current$$1.expirationTime
+            )),
+            (renderExpirationTime = nextProps),
+            (nextProps.childExpirationTime = 0),
+            (renderExpirationTime.return = mode.return = workInProgress))
+          : (renderExpirationTime = mode = reconcileChildFibers(
+              workInProgress,
+              mode.child,
+              nextProps.children,
+              renderExpirationTime
+            )))
+      : ((current$$1 = current$$1.child),
+        nextDidTimeout
+          ? ((nextDidTimeout = nextProps.fallback),
+            (nextProps = createFiberFromFragment(null, mode, 0, null)),
+            (nextProps.child = current$$1),
+            0 === (workInProgress.mode & 1) &&
+              (nextProps.child =
+                null !== workInProgress.memoizedState
+                  ? workInProgress.child.child
+                  : workInProgress.child),
+            (mode = nextProps.sibling = createFiberFromFragment(
+              nextDidTimeout,
+              mode,
+              renderExpirationTime,
+              null
+            )),
+            (mode.effectTag |= 2),
+            (renderExpirationTime = nextProps),
+            (nextProps.childExpirationTime = 0),
+            (renderExpirationTime.return = mode.return = workInProgress))
+          : (mode = renderExpirationTime = reconcileChildFibers(
+              workInProgress,
+              current$$1,
+              nextProps.children,
+              renderExpirationTime
+            )));
+  workInProgress.memoizedState = nextState;
+  workInProgress.child = renderExpirationTime;
+  return mode;
 }
 function bailoutOnAlreadyFinishedWork(
   current$$1,
@@ -3644,9 +4152,7 @@ function bailoutOnAlreadyFinishedWork(
 ) {
   null !== current$$1 &&
     (workInProgress.firstContextDependency = current$$1.firstContextDependency);
-  var childExpirationTime = workInProgress.childExpirationTime;
-  if (0 === childExpirationTime || childExpirationTime > renderExpirationTime)
-    return null;
+  if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
     null === current$$1 || workInProgress.child === current$$1.child,
     "Resuming work not yet implemented."
@@ -3675,518 +4181,559 @@ function bailoutOnAlreadyFinishedWork(
   }
   return workInProgress.child;
 }
-function beginWork(current$$1, workInProgress, renderExpirationTime) {
+function beginWork(current$$1, workInProgress, renderExpirationTime$jscomp$0) {
   var updateExpirationTime = workInProgress.expirationTime;
   if (
     null !== current$$1 &&
     current$$1.memoizedProps === workInProgress.pendingProps &&
     !didPerformWorkStackCursor.current &&
-    (0 === updateExpirationTime || updateExpirationTime > renderExpirationTime)
+    updateExpirationTime < renderExpirationTime$jscomp$0
   ) {
     switch (workInProgress.tag) {
-      case 5:
+      case 3:
         pushHostRootContext(workInProgress);
         break;
-      case 7:
+      case 5:
         pushHostContext(workInProgress);
         break;
-      case 2:
+      case 1:
         isContextProvider(workInProgress.type) &&
           pushContextProvider(workInProgress);
         break;
-      case 3:
-        isContextProvider(workInProgress.type._reactResult) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 6:
+      case 4:
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         );
         break;
-      case 12:
+      case 10:
         pushProvider(workInProgress, workInProgress.memoizedProps.value);
+        break;
+      case 13:
+        if (null !== workInProgress.memoizedState) {
+          updateExpirationTime = workInProgress.child.childExpirationTime;
+          if (
+            0 !== updateExpirationTime &&
+            updateExpirationTime >= renderExpirationTime$jscomp$0
+          )
+            return updateSuspenseComponent(
+              current$$1,
+              workInProgress,
+              renderExpirationTime$jscomp$0
+            );
+          workInProgress = bailoutOnAlreadyFinishedWork(
+            current$$1,
+            workInProgress,
+            renderExpirationTime$jscomp$0
+          );
+          return null !== workInProgress ? workInProgress.sibling : null;
+        }
     }
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
-      renderExpirationTime
+      renderExpirationTime$jscomp$0
     );
   }
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
-    case 4:
-      var Component = workInProgress.type;
-      invariant(
-        null === current$$1,
-        "An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue."
+    case 2:
+      updateExpirationTime = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      current$$1 = workInProgress.pendingProps;
+      var context = getMaskedContext(
+        workInProgress,
+        contextStackCursor.current
       );
-      var props = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+      renderExpirationTime = renderExpirationTime$jscomp$0;
+      currentlyRenderingFiber$1 = workInProgress;
+      firstCurrentHook = null;
+      var value = updateExpirationTime(current$$1, context);
+      workInProgress.effectTag |= 1;
       if (
-        "object" === typeof Component &&
-        null !== Component &&
-        "function" === typeof Component.then
+        "object" === typeof value &&
+        null !== value &&
+        "function" === typeof value.render &&
+        void 0 === value.$$typeof
       ) {
-        Component = readLazyComponentType(Component);
-        var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(
+        workInProgress.tag = 1;
+        resetHooks();
+        isContextProvider(updateExpirationTime)
+          ? ((context = !0), pushContextProvider(workInProgress))
+          : (context = !1);
+        workInProgress.memoizedState =
+          null !== value.state && void 0 !== value.state ? value.state : null;
+        var getDerivedStateFromProps =
+          updateExpirationTime.getDerivedStateFromProps;
+        "function" === typeof getDerivedStateFromProps &&
+          applyDerivedStateFromProps(
             workInProgress,
-            Component
-          )),
-          resolvedProps = resolveDefaultProps(Component, props),
-          child = void 0;
-        switch (resolvedTag) {
-          case 1:
-            child = updateFunctionComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 3:
-            child = updateClassComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 14:
-            child = updateForwardRef(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 18:
-            child = updatePureComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              updateExpirationTime,
-              renderExpirationTime
-            );
-            break;
-          default:
-            invariant(
-              !1,
-              "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
-              Component
-            );
-        }
-        workInProgress.memoizedProps = props;
-        workInProgress = child;
-      } else
-        (updateExpirationTime = getMaskedContext(
+            updateExpirationTime,
+            getDerivedStateFromProps,
+            current$$1
+          );
+        value.updater = classComponentUpdater;
+        workInProgress.stateNode = value;
+        value._reactInternalFiber = workInProgress;
+        mountClassInstance(
           workInProgress,
-          contextStackCursor.current
-        )),
-          prepareToReadContext(workInProgress, renderExpirationTime),
-          (updateExpirationTime = Component(props, updateExpirationTime)),
-          (workInProgress.effectTag |= 1),
-          "object" === typeof updateExpirationTime &&
-          null !== updateExpirationTime &&
-          "function" === typeof updateExpirationTime.render &&
-          void 0 === updateExpirationTime.$$typeof
-            ? ((workInProgress.tag = 2),
-              isContextProvider(Component)
-                ? ((resolvedTag = !0), pushContextProvider(workInProgress))
-                : (resolvedTag = !1),
-              (workInProgress.memoizedState =
-                null !== updateExpirationTime.state &&
-                void 0 !== updateExpirationTime.state
-                  ? updateExpirationTime.state
-                  : null),
-              (resolvedProps = Component.getDerivedStateFromProps),
-              "function" === typeof resolvedProps &&
-                applyDerivedStateFromProps(
-                  workInProgress,
-                  Component,
-                  resolvedProps,
-                  props
-                ),
-              (updateExpirationTime.updater = classComponentUpdater),
-              (workInProgress.stateNode = updateExpirationTime),
-              (updateExpirationTime._reactInternalFiber = workInProgress),
-              mountClassInstance(
-                workInProgress,
-                Component,
-                props,
-                renderExpirationTime
-              ),
-              (workInProgress = finishClassComponent(
-                current$$1,
-                workInProgress,
-                Component,
-                !0,
-                resolvedTag,
-                renderExpirationTime
-              )))
-            : ((workInProgress.tag = 0),
-              reconcileChildren(
-                current$$1,
-                workInProgress,
-                updateExpirationTime,
-                renderExpirationTime
-              ),
-              (workInProgress.memoizedProps = props),
-              (workInProgress = workInProgress.child));
+          updateExpirationTime,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        );
+        workInProgress = finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          context,
+          renderExpirationTime$jscomp$0
+        );
+      } else
+        (workInProgress.tag = 0),
+          (value = finishHooks(
+            updateExpirationTime,
+            current$$1,
+            value,
+            context
+          )),
+          reconcileChildren(
+            null,
+            workInProgress,
+            value,
+            renderExpirationTime$jscomp$0
+          ),
+          (workInProgress = workInProgress.child);
       return workInProgress;
+    case 16:
+      value = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      context = workInProgress.pendingProps;
+      current$$1 = readLazyComponentType(value);
+      workInProgress.type = current$$1;
+      value = workInProgress.tag = resolveLazyComponentTag(current$$1);
+      context = resolveDefaultProps(current$$1, context);
+      getDerivedStateFromProps = void 0;
+      switch (value) {
+        case 0:
+          getDerivedStateFromProps = updateFunctionComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 1:
+          getDerivedStateFromProps = updateClassComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 11:
+          getDerivedStateFromProps = updateForwardRef(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 14:
+          getDerivedStateFromProps = updateMemoComponent(
+            null,
+            workInProgress,
+            current$$1,
+            resolveDefaultProps(current$$1.type, context),
+            updateExpirationTime,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        default:
+          invariant(
+            !1,
+            "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
+            current$$1
+          );
+      }
+      return getDerivedStateFromProps;
     case 0:
-      return updateFunctionComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateFunctionComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateFunctionComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
-      );
-    case 2:
-      return updateClassComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 3:
+    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateClassComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateClassComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 5:
+    case 3:
       return (
         pushHostRootContext(workInProgress),
-        (Component = workInProgress.updateQueue),
+        (updateExpirationTime = workInProgress.updateQueue),
         invariant(
-          null !== Component,
+          null !== updateExpirationTime,
           "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
         ),
-        (props = workInProgress.memoizedState),
-        (props = null !== props ? props.element : null),
+        (value = workInProgress.memoizedState),
+        (value = null !== value ? value.element : null),
         processUpdateQueue(
           workInProgress,
-          Component,
+          updateExpirationTime,
           workInProgress.pendingProps,
           null,
-          renderExpirationTime
+          renderExpirationTime$jscomp$0
         ),
-        (Component = workInProgress.memoizedState.element),
-        Component === props
+        (updateExpirationTime = workInProgress.memoizedState.element),
+        updateExpirationTime === value
           ? (workInProgress = bailoutOnAlreadyFinishedWork(
               current$$1,
               workInProgress,
-              renderExpirationTime
+              renderExpirationTime$jscomp$0
             ))
           : (reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
             (workInProgress = workInProgress.child)),
         workInProgress
       );
-    case 7:
+    case 5:
       return (
         pushHostContext(workInProgress),
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
+        (updateExpirationTime = workInProgress.pendingProps.children),
         markRef(current$$1, workInProgress),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         (workInProgress = workInProgress.child),
         workInProgress
       );
-    case 8:
+    case 6:
       return (
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (workInProgress.memoizedProps = workInProgress.pendingProps),
         null
       );
-    case 16:
-      return null;
-    case 6:
+    case 13:
+      return updateSuspenseComponent(
+        current$$1,
+        workInProgress,
+        renderExpirationTime$jscomp$0
+      );
+    case 4:
       return (
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         ),
-        (Component = workInProgress.pendingProps),
+        (updateExpirationTime = workInProgress.pendingProps),
         null === current$$1
           ? (workInProgress.child = reconcileChildFibers(
               workInProgress,
               null,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ))
           : reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 13:
-      return updateForwardRef(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 14:
+    case 11:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateForwardRef(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateForwardRef(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 9:
+    case 7:
       return (
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 10:
+    case 8:
       return (
-        (Component = workInProgress.pendingProps.children),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 15:
+    case 12:
       return (
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component.children,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 12:
+    case 10:
       a: {
-        Component = workInProgress.type._context;
-        props = workInProgress.pendingProps;
-        resolvedTag = workInProgress.memoizedProps;
-        updateExpirationTime = props.value;
-        workInProgress.memoizedProps = props;
-        pushProvider(workInProgress, updateExpirationTime);
-        if (null !== resolvedTag)
-          if (
-            ((resolvedProps = resolvedTag.value),
-            (updateExpirationTime =
-              (resolvedProps === updateExpirationTime &&
-                (0 !== resolvedProps ||
-                  1 / resolvedProps === 1 / updateExpirationTime)) ||
-              (resolvedProps !== resolvedProps &&
-                updateExpirationTime !== updateExpirationTime)
-                ? 0
-                : ("function" === typeof Component._calculateChangedBits
-                    ? Component._calculateChangedBits(
-                        resolvedProps,
-                        updateExpirationTime
-                      )
-                    : 1073741823) | 0),
-            0 === updateExpirationTime)
-          ) {
+        updateExpirationTime = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        getDerivedStateFromProps = workInProgress.memoizedProps;
+        context = value.value;
+        pushProvider(workInProgress, context);
+        if (null !== getDerivedStateFromProps) {
+          var oldValue = getDerivedStateFromProps.value;
+          context =
+            (oldValue === context &&
+              (0 !== oldValue || 1 / oldValue === 1 / context)) ||
+            (oldValue !== oldValue && context !== context)
+              ? 0
+              : ("function" ===
+                typeof updateExpirationTime._calculateChangedBits
+                  ? updateExpirationTime._calculateChangedBits(
+                      oldValue,
+                      context
+                    )
+                  : 1073741823) | 0;
+          if (0 === context) {
             if (
-              resolvedTag.children === props.children &&
+              getDerivedStateFromProps.children === value.children &&
               !didPerformWorkStackCursor.current
             ) {
               workInProgress = bailoutOnAlreadyFinishedWork(
                 current$$1,
                 workInProgress,
-                renderExpirationTime
+                renderExpirationTime$jscomp$0
               );
               break a;
             }
           } else
             for (
-              resolvedTag = workInProgress.child,
-                null !== resolvedTag && (resolvedTag.return = workInProgress);
-              null !== resolvedTag;
+              getDerivedStateFromProps = workInProgress.child,
+                null !== getDerivedStateFromProps &&
+                  (getDerivedStateFromProps.return = workInProgress);
+              null !== getDerivedStateFromProps;
 
             ) {
-              resolvedProps = resolvedTag.firstContextDependency;
-              if (null !== resolvedProps) {
+              oldValue = getDerivedStateFromProps.firstContextDependency;
+              if (null !== oldValue) {
                 do {
                   if (
-                    resolvedProps.context === Component &&
-                    0 !== (resolvedProps.observedBits & updateExpirationTime)
+                    oldValue.context === updateExpirationTime &&
+                    0 !== (oldValue.observedBits & context)
                   ) {
-                    if (2 === resolvedTag.tag || 3 === resolvedTag.tag)
-                      (child = createUpdate(renderExpirationTime)),
-                        (child.tag = 2),
-                        enqueueUpdate(resolvedTag, child);
-                    if (
-                      0 === resolvedTag.expirationTime ||
-                      resolvedTag.expirationTime > renderExpirationTime
-                    )
-                      resolvedTag.expirationTime = renderExpirationTime;
-                    child = resolvedTag.alternate;
-                    null !== child &&
-                      (0 === child.expirationTime ||
-                        child.expirationTime > renderExpirationTime) &&
-                      (child.expirationTime = renderExpirationTime);
-                    for (var node = resolvedTag.return; null !== node; ) {
-                      child = node.alternate;
+                    if (1 === getDerivedStateFromProps.tag) {
+                      var nextFiber = createUpdate(
+                        renderExpirationTime$jscomp$0
+                      );
+                      nextFiber.tag = 2;
+                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
+                    }
+                    getDerivedStateFromProps.expirationTime <
+                      renderExpirationTime$jscomp$0 &&
+                      (getDerivedStateFromProps.expirationTime = renderExpirationTime$jscomp$0);
+                    nextFiber = getDerivedStateFromProps.alternate;
+                    null !== nextFiber &&
+                      nextFiber.expirationTime <
+                        renderExpirationTime$jscomp$0 &&
+                      (nextFiber.expirationTime = renderExpirationTime$jscomp$0);
+                    for (
+                      var node = getDerivedStateFromProps.return;
+                      null !== node;
+
+                    ) {
+                      nextFiber = node.alternate;
                       if (
-                        0 === node.childExpirationTime ||
-                        node.childExpirationTime > renderExpirationTime
+                        node.childExpirationTime < renderExpirationTime$jscomp$0
                       )
-                        (node.childExpirationTime = renderExpirationTime),
-                          null !== child &&
-                            (0 === child.childExpirationTime ||
-                              child.childExpirationTime >
-                                renderExpirationTime) &&
-                            (child.childExpirationTime = renderExpirationTime);
+                        (node.childExpirationTime = renderExpirationTime$jscomp$0),
+                          null !== nextFiber &&
+                            nextFiber.childExpirationTime <
+                              renderExpirationTime$jscomp$0 &&
+                            (nextFiber.childExpirationTime = renderExpirationTime$jscomp$0);
                       else if (
-                        null !== child &&
-                        (0 === child.childExpirationTime ||
-                          child.childExpirationTime > renderExpirationTime)
+                        null !== nextFiber &&
+                        nextFiber.childExpirationTime <
+                          renderExpirationTime$jscomp$0
                       )
-                        child.childExpirationTime = renderExpirationTime;
+                        nextFiber.childExpirationTime = renderExpirationTime$jscomp$0;
                       else break;
                       node = node.return;
                     }
                   }
-                  child = resolvedTag.child;
-                  resolvedProps = resolvedProps.next;
-                } while (null !== resolvedProps);
+                  nextFiber = getDerivedStateFromProps.child;
+                  oldValue = oldValue.next;
+                } while (null !== oldValue);
               } else
-                child =
-                  12 === resolvedTag.tag
-                    ? resolvedTag.type === workInProgress.type
+                nextFiber =
+                  10 === getDerivedStateFromProps.tag
+                    ? getDerivedStateFromProps.type === workInProgress.type
                       ? null
-                      : resolvedTag.child
-                    : resolvedTag.child;
-              if (null !== child) child.return = resolvedTag;
+                      : getDerivedStateFromProps.child
+                    : getDerivedStateFromProps.child;
+              if (null !== nextFiber)
+                nextFiber.return = getDerivedStateFromProps;
               else
-                for (child = resolvedTag; null !== child; ) {
-                  if (child === workInProgress) {
-                    child = null;
+                for (
+                  nextFiber = getDerivedStateFromProps;
+                  null !== nextFiber;
+
+                ) {
+                  if (nextFiber === workInProgress) {
+                    nextFiber = null;
                     break;
                   }
-                  resolvedTag = child.sibling;
-                  if (null !== resolvedTag) {
-                    resolvedTag.return = child.return;
-                    child = resolvedTag;
+                  getDerivedStateFromProps = nextFiber.sibling;
+                  if (null !== getDerivedStateFromProps) {
+                    getDerivedStateFromProps.return = nextFiber.return;
+                    nextFiber = getDerivedStateFromProps;
                     break;
                   }
-                  child = child.return;
+                  nextFiber = nextFiber.return;
                 }
-              resolvedTag = child;
+              getDerivedStateFromProps = nextFiber;
             }
+        }
         reconcileChildren(
           current$$1,
           workInProgress,
-          props.children,
-          renderExpirationTime
+          value.children,
+          renderExpirationTime$jscomp$0
         );
         workInProgress = workInProgress.child;
       }
       return workInProgress;
-    case 11:
+    case 9:
       return (
-        (updateExpirationTime = workInProgress.type),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
-        prepareToReadContext(workInProgress, renderExpirationTime),
-        (updateExpirationTime = readContext(
-          updateExpirationTime,
-          Component.unstable_observedBits
-        )),
-        (props = props(updateExpirationTime)),
+        (value = workInProgress.type),
+        (context = workInProgress.pendingProps),
+        (updateExpirationTime = context.children),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        (value = readContext(value, context.unstable_observedBits)),
+        (updateExpirationTime = updateExpirationTime(value)),
         (workInProgress.effectTag |= 1),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 17:
-      return updatePureComponent(
+    case 14:
+      return (
+        (value = workInProgress.type),
+        (context = resolveDefaultProps(
+          value.type,
+          workInProgress.pendingProps
+        )),
+        updateMemoComponent(
+          current$$1,
+          workInProgress,
+          value,
+          context,
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
         current$$1,
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
         updateExpirationTime,
-        renderExpirationTime
+        renderExpirationTime$jscomp$0
       );
-    case 18:
+    case 17:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updatePureComponent(
-          current$$1,
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        null !== current$$1 &&
+          ((current$$1.alternate = null),
+          (workInProgress.alternate = null),
+          (workInProgress.effectTag |= 2)),
+        (workInProgress.tag = 1),
+        isContextProvider(updateExpirationTime)
+          ? ((current$$1 = !0), pushContextProvider(workInProgress))
+          : (current$$1 = !1),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        constructClassInstance(
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
           updateExpirationTime,
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        mountClassInstance(
+          workInProgress,
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        )
       );
     default:
       invariant(
@@ -4195,14 +4742,113 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
-function appendAllChildren(parent, workInProgress) {
+var appendAllChildren = void 0,
+  updateHostContainer = void 0,
+  updateHostComponent$1 = void 0,
+  updateHostText$1 = void 0;
+appendAllChildren = function(
+  parent,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
+  for (var node = workInProgress.child; null !== node; ) {
+    a: if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        var props = node.memoizedProps,
+          type = node.type;
+        instance = isHidden
+          ? cloneHiddenInstance(instance, type, props, node)
+          : cloneUnhiddenInstance(instance, type, props, node);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChild(parent.node, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        instance = node.memoizedProps;
+        props = requiredContext(rootInstanceStackCursor.current);
+        type = requiredContext(contextStackCursor$1.current);
+        if (isHidden) throw Error("Not yet implemented.");
+        instance = createTextInstance(instance, props, type, workInProgress);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChild(parent.node, instance.node);
+    } else if (4 !== node.tag) {
+      if (
+        13 === node.tag &&
+        ((props = node.alternate),
+        null !== props &&
+          ((instance = null !== node.memoizedState),
+          (null !== props.memoizedState) !== instance))
+      ) {
+        props = instance ? node.child : node;
+        null !== props && appendAllChildren(parent, props, !0, instance);
+        break a;
+      }
+      if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    }
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+};
+function appendAllChildrenToContainer(
+  containerChildSet,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
   for (var node = workInProgress.child; null !== node; ) {
-    if (7 === node.tag || 8 === node.tag)
-      FabricUIManager.appendChild(parent.node, node.stateNode.node);
-    else if (6 !== node.tag && null !== node.child) {
-      node.child.return = node;
-      node = node.child;
-      continue;
+    a: if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        var props = node.memoizedProps,
+          type = node.type;
+        instance = isHidden
+          ? cloneHiddenInstance(instance, type, props, node)
+          : cloneUnhiddenInstance(instance, type, props, node);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChildToSet(containerChildSet, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        instance = node.memoizedProps;
+        props = requiredContext(rootInstanceStackCursor.current);
+        type = requiredContext(contextStackCursor$1.current);
+        if (isHidden) throw Error("Not yet implemented.");
+        instance = createTextInstance(instance, props, type, workInProgress);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChildToSet(containerChildSet, instance.node);
+    } else if (4 !== node.tag) {
+      if (
+        13 === node.tag &&
+        ((props = node.alternate),
+        null !== props &&
+          ((instance = null !== node.memoizedState),
+          (null !== props.memoizedState) !== instance))
+      ) {
+        props = instance ? node.child : node;
+        null !== props &&
+          appendAllChildrenToContainer(containerChildSet, props, !0, instance);
+        break a;
+      }
+      if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
     }
     if (node === workInProgress) break;
     for (; null === node.sibling; ) {
@@ -4213,30 +4859,12 @@ function appendAllChildren(parent, workInProgress) {
     node = node.sibling;
   }
 }
-var updateHostContainer = void 0,
-  updateHostComponent$1 = void 0,
-  updateHostText$1 = void 0;
 updateHostContainer = function(workInProgress) {
   var portalOrRoot = workInProgress.stateNode;
   if (null !== workInProgress.firstEffect) {
     var container = portalOrRoot.containerInfo,
       newChildSet = FabricUIManager.createChildSet(container);
-    a: for (var node = workInProgress.child; null !== node; ) {
-      if (7 === node.tag || 8 === node.tag)
-        FabricUIManager.appendChildToSet(newChildSet, node.stateNode.node);
-      else if (6 !== node.tag && null !== node.child) {
-        node.child.return = node;
-        node = node.child;
-        continue;
-      }
-      if (node === workInProgress) break a;
-      for (; null === node.sibling; ) {
-        if (null === node.return || node.return === workInProgress) break a;
-        node = node.return;
-      }
-      node.sibling.return = node.return;
-      node = node.sibling;
-    }
+    appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
     portalOrRoot.pendingChildren = newChildSet;
     workInProgress.effectTag |= 4;
     FabricUIManager.completeRoot(container, newChildSet);
@@ -4283,7 +4911,7 @@ updateHostComponent$1 = function(current, workInProgress, type, newProps) {
         (workInProgress.stateNode = type),
         current
           ? (workInProgress.effectTag |= 4)
-          : appendAllChildren(type, workInProgress));
+          : appendAllChildren(type, workInProgress, !1, !1));
   }
 };
 updateHostText$1 = function(current, workInProgress, oldText, newText) {
@@ -4333,7 +4961,7 @@ function logError(boundary, errorInfo) {
     willRetry: !1
   };
   null !== boundary &&
-    2 === boundary.tag &&
+    1 === boundary.tag &&
     ((errorInfo.errorBoundary = boundary.stateNode),
     (errorInfo.errorBoundaryName = getComponentName(boundary.type)),
     (errorInfo.errorBoundaryFound = !0),
@@ -4357,18 +4985,45 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if (0 !== (effect.tag & unmountTag)) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      0 !== (effect.tag & mountTag) &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
 function commitWork(current$$1, finishedWork) {
   switch (finishedWork.tag) {
-    case 2:
-    case 3:
-      break;
-    case 7:
-      break;
-    case 8:
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      commitHookEffectList(4, 8, finishedWork);
+      return;
+  }
+  switch (finishedWork.tag) {
+    case 1:
       break;
     case 5:
+      break;
     case 6:
       break;
+    case 3:
+    case 4:
+      break;
     default:
       invariant(
         !1,
@@ -4416,24 +5071,14 @@ function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
 }
 function unwindWork(workInProgress) {
   switch (workInProgress.tag) {
-    case 2:
+    case 1:
       isContextProvider(workInProgress.type) && popContext(workInProgress);
       var effectTag = workInProgress.effectTag;
-      return effectTag & 1024
-        ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+      return effectTag & 2048
+        ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
           workInProgress)
         : null;
     case 3:
-      return (
-        isContextProvider(workInProgress.type._reactResult) &&
-          popContext(workInProgress),
-        (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
-            workInProgress)
-          : null
-      );
-    case 5:
       return (
         popHostContainer(workInProgress),
         popTopLevelContextObject(workInProgress),
@@ -4442,36 +5087,117 @@ function unwindWork(workInProgress) {
           0 === (effectTag & 64),
           "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
         ),
-        (workInProgress.effectTag = (effectTag & -1025) | 64),
+        (workInProgress.effectTag = (effectTag & -2049) | 64),
         workInProgress
       );
-    case 7:
+    case 5:
       return popHostContext(workInProgress), null;
-    case 16:
+    case 13:
       return (
         (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+        effectTag & 2048
+          ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
             workInProgress)
           : null
       );
-    case 6:
+    case 4:
       return popHostContainer(workInProgress), null;
-    case 12:
+    case 10:
       return popProvider(workInProgress), null;
     default:
       return null;
   }
 }
-var Dispatcher = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [callback];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, inputs];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, inputs) {
+      useEffectImpl(516, 192, create, inputs);
+    },
+    useImperativeMethods: function(ref, create, inputs) {
+      inputs =
+        null !== inputs && void 0 !== inputs
+          ? inputs.concat([ref])
+          : [ref, create];
+      useEffectImpl(
+        4,
+        36,
+        function() {
+          if ("function" === typeof ref) {
+            var _inst = create();
+            ref(_inst);
+            return function() {
+              return ref(null);
+            };
+          }
+          if (null !== ref && void 0 !== ref)
+            return (
+              (_inst = create()),
+              (ref.current = _inst),
+              function() {
+                ref.current = null;
+              }
+            );
+        },
+        inputs
+      );
+    },
+    useLayoutEffect: function(create, inputs) {
+      useEffectImpl(4, 36, create, inputs);
+    },
+    useMemo: function(nextCreate, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [nextCreate];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      nextCreate = nextCreate();
+      workInProgressHook.memoizedState = [nextCreate, inputs];
+      return nextCreate;
+    },
+    useMutationEffect: function(create, inputs) {
+      useEffectImpl(260, 10, create, inputs);
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
   isWorking = !1,
   nextUnitOfWork = null,
   nextRoot = null,
   nextRenderExpirationTime = 0,
+  nextLatestAbsoluteTimeoutMs = -1,
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
+  passiveEffectCallbackHandle = null,
+  passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
 function resetStack() {
   if (null !== nextUnitOfWork)
@@ -4482,7 +5208,7 @@ function resetStack() {
     ) {
       var interruptedWork$jscomp$0 = interruptedWork;
       switch (interruptedWork$jscomp$0.tag) {
-        case 2:
+        case 1:
           var childContextTypes =
             interruptedWork$jscomp$0.type.childContextTypes;
           null !== childContextTypes &&
@@ -4490,200 +5216,243 @@ function resetStack() {
             popContext(interruptedWork$jscomp$0);
           break;
         case 3:
-          childContextTypes =
-            interruptedWork$jscomp$0.type._reactResult.childContextTypes;
-          null !== childContextTypes &&
-            void 0 !== childContextTypes &&
-            popContext(interruptedWork$jscomp$0);
-          break;
-        case 5:
           popHostContainer(interruptedWork$jscomp$0);
           popTopLevelContextObject(interruptedWork$jscomp$0);
           break;
-        case 7:
+        case 5:
           popHostContext(interruptedWork$jscomp$0);
           break;
-        case 6:
+        case 4:
           popHostContainer(interruptedWork$jscomp$0);
           break;
-        case 12:
+        case 10:
           popProvider(interruptedWork$jscomp$0);
       }
       interruptedWork = interruptedWork.return;
     }
   nextRoot = null;
   nextRenderExpirationTime = 0;
+  nextLatestAbsoluteTimeoutMs = -1;
   nextRenderDidError = !1;
   nextUnitOfWork = null;
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(128, 0, finishedWork);
+        commitHookEffectList(0, 64, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
+function flushPassiveEffects() {
+  null !== passiveEffectCallback &&
+    (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
+    passiveEffectCallback());
+}
 function completeUnitOfWork(workInProgress) {
   for (;;) {
     var current$$1 = workInProgress.alternate,
       returnFiber = workInProgress.return,
       siblingFiber = workInProgress.sibling;
-    if (0 === (workInProgress.effectTag & 512)) {
-      var current = current$$1;
-      current$$1 = workInProgress;
-      var instance = current$$1.pendingProps;
-      switch (current$$1.tag) {
-        case 0:
-        case 1:
-          break;
-        case 2:
-          isContextProvider(current$$1.type) && popContext(current$$1);
-          break;
-        case 3:
-          isContextProvider(current$$1.type._reactResult) &&
-            popContext(current$$1);
-          break;
-        case 5:
-          popHostContainer(current$$1);
-          popTopLevelContextObject(current$$1);
-          instance = current$$1.stateNode;
-          instance.pendingContext &&
-            ((instance.context = instance.pendingContext),
-            (instance.pendingContext = null));
-          if (null === current || null === current.child)
-            current$$1.effectTag &= -3;
-          updateHostContainer(current$$1);
-          break;
-        case 7:
-          popHostContext(current$$1);
-          var rootContainerInstance = requiredContext(
+    if (0 === (workInProgress.effectTag & 1024)) {
+      nextUnitOfWork = workInProgress;
+      a: {
+        var current = current$$1;
+        current$$1 = workInProgress;
+        var renderExpirationTime = nextRenderExpirationTime;
+        var instance = current$$1.pendingProps;
+        switch (current$$1.tag) {
+          case 2:
+            break;
+          case 16:
+            break;
+          case 15:
+          case 0:
+            break;
+          case 1:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          case 3:
+            popHostContainer(current$$1);
+            popTopLevelContextObject(current$$1);
+            instance = current$$1.stateNode;
+            instance.pendingContext &&
+              ((instance.context = instance.pendingContext),
+              (instance.pendingContext = null));
+            if (null === current || null === current.child)
+              current$$1.effectTag &= -3;
+            updateHostContainer(current$$1);
+            break;
+          case 5:
+            popHostContext(current$$1);
+            renderExpirationTime = requiredContext(
               rootInstanceStackCursor.current
-            ),
-            type = current$$1.type;
-          if (null !== current && null != current$$1.stateNode)
-            updateHostComponent$1(
-              current,
-              current$$1,
-              type,
-              instance,
-              rootContainerInstance
-            ),
-              current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
-          else if (instance) {
-            var currentHostContext = requiredContext(
-                contextStackCursor$1.current
-              ),
-              internalInstanceHandle = current$$1;
-            current = nextReactTag;
-            nextReactTag += 2;
-            var viewConfig = ReactNativeViewConfigRegistry.get(type);
-            invariant(
-              "RCTView" !== type || !currentHostContext.isInAParentText,
-              "Nesting of <View> within <Text> is not currently supported."
-            );
-            type = diffProperties(
-              null,
-              emptyObject,
-              instance,
-              viewConfig.validAttributes
-            );
-            rootContainerInstance = FabricUIManager.createNode(
-              current,
-              viewConfig.uiViewClassName,
-              rootContainerInstance,
-              type,
-              internalInstanceHandle
-            );
-            instance = new ReactFabricHostComponent(
-              current,
-              viewConfig,
-              instance
             );
-            instance = { node: rootContainerInstance, canonical: instance };
-            appendAllChildren(instance, current$$1);
-            current$$1.stateNode = instance;
-            null !== current$$1.ref && (current$$1.effectTag |= 128);
-          } else
-            invariant(
-              null !== current$$1.stateNode,
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-            );
-          break;
-        case 8:
-          current && null != current$$1.stateNode
-            ? updateHostText$1(
+            var type = current$$1.type;
+            if (null !== current && null != current$$1.stateNode)
+              updateHostComponent$1(
                 current,
                 current$$1,
-                current.memoizedProps,
-                instance
-              )
-            : ("string" !== typeof instance &&
-                invariant(
-                  null !== current$$1.stateNode,
-                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                type,
+                instance,
+                renderExpirationTime
+              ),
+                current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
+            else if (instance) {
+              var currentHostContext = requiredContext(
+                  contextStackCursor$1.current
                 ),
-              (rootContainerInstance = requiredContext(
-                rootInstanceStackCursor.current
-              )),
-              (current = requiredContext(contextStackCursor$1.current)),
-              (current$$1.stateNode = createTextInstance(
+                internalInstanceHandle = current$$1;
+              current = nextReactTag;
+              nextReactTag += 2;
+              var viewConfig = ReactNativeViewConfigRegistry.get(type);
+              invariant(
+                "RCTView" !== type || !currentHostContext.isInAParentText,
+                "Nesting of <View> within <Text> is not currently supported."
+              );
+              type = diffProperties(
+                null,
+                emptyObject,
                 instance,
-                rootContainerInstance,
+                viewConfig.validAttributes
+              );
+              renderExpirationTime = FabricUIManager.createNode(
                 current,
-                current$$1
-              )));
-          break;
-        case 13:
-        case 14:
-          break;
-        case 16:
-          break;
-        case 9:
-          break;
-        case 10:
-          break;
-        case 15:
-          break;
-        case 6:
-          popHostContainer(current$$1);
-          updateHostContainer(current$$1);
-          break;
-        case 12:
-          popProvider(current$$1);
-          break;
-        case 11:
-          break;
-        case 17:
-        case 18:
-          break;
-        case 4:
-          invariant(
-            !1,
-            "An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue."
-          );
-        default:
-          invariant(
-            !1,
-            "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
-          );
+                viewConfig.uiViewClassName,
+                renderExpirationTime,
+                type,
+                internalInstanceHandle
+              );
+              instance = new ReactFabricHostComponent(
+                current,
+                viewConfig,
+                instance
+              );
+              instance = { node: renderExpirationTime, canonical: instance };
+              appendAllChildren(instance, current$$1, !1, !1);
+              current$$1.stateNode = instance;
+              null !== current$$1.ref && (current$$1.effectTag |= 128);
+            } else
+              invariant(
+                null !== current$$1.stateNode,
+                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+              );
+            break;
+          case 6:
+            current && null != current$$1.stateNode
+              ? updateHostText$1(
+                  current,
+                  current$$1,
+                  current.memoizedProps,
+                  instance
+                )
+              : ("string" !== typeof instance &&
+                  invariant(
+                    null !== current$$1.stateNode,
+                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                  ),
+                (current = requiredContext(rootInstanceStackCursor.current)),
+                (renderExpirationTime = requiredContext(
+                  contextStackCursor$1.current
+                )),
+                (current$$1.stateNode = createTextInstance(
+                  instance,
+                  current,
+                  renderExpirationTime,
+                  current$$1
+                )));
+            break;
+          case 11:
+            break;
+          case 13:
+            instance = current$$1.memoizedState;
+            if (0 !== (current$$1.effectTag & 64)) {
+              current$$1.expirationTime = renderExpirationTime;
+              nextUnitOfWork = current$$1;
+              break a;
+            }
+            instance = null !== instance;
+            renderExpirationTime =
+              null !== current && null !== current.memoizedState;
+            null !== current &&
+              !instance &&
+              renderExpirationTime &&
+              ((current = current.child.sibling),
+              null !== current &&
+                ((viewConfig = current$$1.firstEffect),
+                null !== viewConfig
+                  ? ((current$$1.firstEffect = current),
+                    (current.nextEffect = viewConfig))
+                  : ((current$$1.firstEffect = current$$1.lastEffect = current),
+                    (current.nextEffect = null)),
+                (current.effectTag = 8)));
+            if (
+              instance !== renderExpirationTime ||
+              (0 === (current$$1.effectTag & 1) && instance)
+            )
+              current$$1.effectTag |= 4;
+            break;
+          case 7:
+            break;
+          case 8:
+            break;
+          case 12:
+            break;
+          case 4:
+            popHostContainer(current$$1);
+            updateHostContainer(current$$1);
+            break;
+          case 10:
+            popProvider(current$$1);
+            break;
+          case 9:
+            break;
+          case 14:
+            break;
+          case 17:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          default:
+            invariant(
+              !1,
+              "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
+        nextUnitOfWork = null;
       }
-      nextUnitOfWork = null;
       current$$1 = workInProgress;
       if (
-        1073741823 === nextRenderExpirationTime ||
-        1073741823 !== current$$1.childExpirationTime
+        1 === nextRenderExpirationTime ||
+        1 !== current$$1.childExpirationTime
       ) {
         instance = 0;
-        for (
-          rootContainerInstance = current$$1.child;
-          null !== rootContainerInstance;
-
-        ) {
-          current = rootContainerInstance.expirationTime;
-          viewConfig = rootContainerInstance.childExpirationTime;
-          if (0 === instance || (0 !== current && current < instance))
-            instance = current;
-          if (0 === instance || (0 !== viewConfig && viewConfig < instance))
-            instance = viewConfig;
-          rootContainerInstance = rootContainerInstance.sibling;
-        }
+        for (current = current$$1.child; null !== current; )
+          (renderExpirationTime = current.expirationTime),
+            (viewConfig = current.childExpirationTime),
+            renderExpirationTime > instance &&
+              (instance = renderExpirationTime),
+            viewConfig > instance && (instance = viewConfig),
+            (current = current.sibling);
         current$$1.childExpirationTime = instance;
       }
+      if (null !== nextUnitOfWork) return nextUnitOfWork;
       null !== returnFiber &&
-        0 === (returnFiber.effectTag & 512) &&
+        0 === (returnFiber.effectTag & 1024) &&
         (null === returnFiber.firstEffect &&
           (returnFiber.firstEffect = workInProgress.firstEffect),
         null !== workInProgress.lastEffect &&
@@ -4698,10 +5467,10 @@ function completeUnitOfWork(workInProgress) {
     } else {
       workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
       if (null !== workInProgress)
-        return (workInProgress.effectTag &= 511), workInProgress;
+        return (workInProgress.effectTag &= 1023), workInProgress;
       null !== returnFiber &&
         ((returnFiber.firstEffect = returnFiber.lastEffect = null),
-        (returnFiber.effectTag |= 512));
+        (returnFiber.effectTag |= 1024));
     }
     if (null !== siblingFiber) return siblingFiber;
     if (null !== returnFiber) workInProgress = returnFiber;
@@ -4715,43 +5484,49 @@ function performUnitOfWork(workInProgress) {
     workInProgress,
     nextRenderExpirationTime
   );
+  workInProgress.memoizedProps = workInProgress.pendingProps;
   null === next && (next = completeUnitOfWork(workInProgress));
   ReactCurrentOwner$2.current = null;
   return next;
 }
-function renderRoot(root, isYieldy, isExpired) {
+function renderRoot(root$jscomp$0, isYieldy) {
   invariant(
     !isWorking,
     "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
+  flushPassiveEffects();
   isWorking = !0;
   ReactCurrentOwner$2.currentDispatcher = Dispatcher;
-  var expirationTime = root.nextExpirationTimeToWorkOn;
+  var expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn;
   if (
     expirationTime !== nextRenderExpirationTime ||
-    root !== nextRoot ||
+    root$jscomp$0 !== nextRoot ||
     null === nextUnitOfWork
   )
     resetStack(),
-      (nextRoot = root),
+      (nextRoot = root$jscomp$0),
       (nextRenderExpirationTime = expirationTime),
       (nextUnitOfWork = createWorkInProgress(
         nextRoot.current,
         null,
         nextRenderExpirationTime
       )),
-      (root.pendingCommitExpirationTime = 0);
+      (root$jscomp$0.pendingCommitExpirationTime = 0);
   var didFatal = !1;
   do {
     try {
       if (isYieldy)
-        for (; null !== nextUnitOfWork && !shouldYield(); )
+        for (; null !== nextUnitOfWork && !shouldYieldToRenderer(); )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
       else
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (null === nextUnitOfWork)
+      if (
+        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
+        resetHooks(),
+        null === nextUnitOfWork)
+      )
         (didFatal = !0), onUncaughtError(thrownValue);
       else {
         invariant(
@@ -4763,54 +5538,141 @@ function renderRoot(root, isYieldy, isExpired) {
         if (null === returnFiber) (didFatal = !0), onUncaughtError(thrownValue);
         else {
           a: {
-            var returnFiber$jscomp$0 = returnFiber,
+            var root = root$jscomp$0,
+              returnFiber$jscomp$0 = returnFiber,
               sourceFiber$jscomp$0 = sourceFiber,
               value = thrownValue;
             returnFiber = nextRenderExpirationTime;
-            sourceFiber$jscomp$0.effectTag |= 512;
+            sourceFiber$jscomp$0.effectTag |= 1024;
             sourceFiber$jscomp$0.firstEffect = sourceFiber$jscomp$0.lastEffect = null;
+            if (
+              null !== value &&
+              "object" === typeof value &&
+              "function" === typeof value.then
+            ) {
+              var thenable = value;
+              value = returnFiber$jscomp$0;
+              var earliestTimeoutMs = -1,
+                startTimeMs = -1;
+              do {
+                if (13 === value.tag) {
+                  var current$$1 = value.alternate;
+                  if (
+                    null !== current$$1 &&
+                    ((current$$1 = current$$1.memoizedState),
+                    null !== current$$1)
+                  ) {
+                    startTimeMs = 10 * (1073741822 - current$$1.timedOutAt);
+                    break;
+                  }
+                  current$$1 = value.pendingProps.maxDuration;
+                  if ("number" === typeof current$$1)
+                    if (0 >= current$$1) earliestTimeoutMs = 0;
+                    else if (
+                      -1 === earliestTimeoutMs ||
+                      current$$1 < earliestTimeoutMs
+                    )
+                      earliestTimeoutMs = current$$1;
+                }
+                value = value.return;
+              } while (null !== value);
+              value = returnFiber$jscomp$0;
+              do {
+                if ((current$$1 = 13 === value.tag))
+                  current$$1 =
+                    void 0 === value.memoizedProps.fallback
+                      ? !1
+                      : null === value.memoizedState;
+                if (current$$1) {
+                  returnFiber$jscomp$0 = retrySuspendedRoot.bind(
+                    null,
+                    root,
+                    value,
+                    sourceFiber$jscomp$0,
+                    0 === (value.mode & 1) ? 1073741823 : returnFiber
+                  );
+                  thenable.then(returnFiber$jscomp$0, returnFiber$jscomp$0);
+                  if (0 === (value.mode & 1)) {
+                    value.effectTag |= 64;
+                    sourceFiber$jscomp$0.effectTag &= -1957;
+                    1 === sourceFiber$jscomp$0.tag &&
+                      null === sourceFiber$jscomp$0.alternate &&
+                      (sourceFiber$jscomp$0.tag = 17);
+                    sourceFiber$jscomp$0.expirationTime = returnFiber;
+                    break a;
+                  }
+                  -1 === earliestTimeoutMs
+                    ? (root = 1073741823)
+                    : (-1 === startTimeMs &&
+                        (startTimeMs =
+                          10 *
+                            (1073741822 -
+                              findEarliestOutstandingPriorityLevel(
+                                root,
+                                returnFiber
+                              )) -
+                          5e3),
+                      (root = startTimeMs + earliestTimeoutMs));
+                  0 <= root &&
+                    nextLatestAbsoluteTimeoutMs < root &&
+                    (nextLatestAbsoluteTimeoutMs = root);
+                  value.effectTag |= 2048;
+                  value.expirationTime = returnFiber;
+                  break a;
+                }
+                value = value.return;
+              } while (null !== value);
+              value = Error(
+                (getComponentName(sourceFiber$jscomp$0.type) ||
+                  "A React component") +
+                  " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
+                  getStackByFiberInDevAndProd(sourceFiber$jscomp$0)
+              );
+            }
             nextRenderDidError = !0;
             value = createCapturedValue(value, sourceFiber$jscomp$0);
+            root = returnFiber$jscomp$0;
             do {
-              switch (returnFiber$jscomp$0.tag) {
-                case 5:
-                  returnFiber$jscomp$0.effectTag |= 1024;
-                  returnFiber$jscomp$0.expirationTime = returnFiber;
+              switch (root.tag) {
+                case 3:
+                  sourceFiber$jscomp$0 = value;
+                  root.effectTag |= 2048;
+                  root.expirationTime = returnFiber;
                   returnFiber = createRootErrorUpdate(
-                    returnFiber$jscomp$0,
-                    value,
+                    root,
+                    sourceFiber$jscomp$0,
                     returnFiber
                   );
-                  enqueueCapturedUpdate(returnFiber$jscomp$0, returnFiber);
+                  enqueueCapturedUpdate(root, returnFiber);
                   break a;
-                case 2:
-                case 3:
-                  sourceFiber$jscomp$0 = value;
-                  var ctor = returnFiber$jscomp$0.type,
-                    instance = returnFiber$jscomp$0.stateNode;
+                case 1:
                   if (
-                    0 === (returnFiber$jscomp$0.effectTag & 64) &&
-                    ("function" === typeof ctor.getDerivedStateFromError ||
-                      (null !== instance &&
-                        "function" === typeof instance.componentDidCatch &&
-                        (null === legacyErrorBoundariesThatAlreadyFailed ||
-                          !legacyErrorBoundariesThatAlreadyFailed.has(
-                            instance
-                          ))))
+                    ((sourceFiber$jscomp$0 = value),
+                    (returnFiber$jscomp$0 = root.type),
+                    (thenable = root.stateNode),
+                    0 === (root.effectTag & 64) &&
+                      ("function" ===
+                        typeof returnFiber$jscomp$0.getDerivedStateFromError ||
+                        (null !== thenable &&
+                          "function" === typeof thenable.componentDidCatch &&
+                          (null === legacyErrorBoundariesThatAlreadyFailed ||
+                            !legacyErrorBoundariesThatAlreadyFailed.has(
+                              thenable
+                            )))))
                   ) {
-                    returnFiber$jscomp$0.effectTag |= 1024;
-                    returnFiber$jscomp$0.expirationTime = returnFiber;
+                    root.effectTag |= 2048;
+                    root.expirationTime = returnFiber;
                     returnFiber = createClassErrorUpdate(
-                      returnFiber$jscomp$0,
+                      root,
                       sourceFiber$jscomp$0,
                       returnFiber
                     );
-                    enqueueCapturedUpdate(returnFiber$jscomp$0, returnFiber);
+                    enqueueCapturedUpdate(root, returnFiber);
                     break a;
                   }
               }
-              returnFiber$jscomp$0 = returnFiber$jscomp$0.return;
-            } while (null !== returnFiber$jscomp$0);
+              root = root.return;
+            } while (null !== root);
           }
           nextUnitOfWork = completeUnitOfWork(sourceFiber);
           continue;
@@ -4821,197 +5683,193 @@ function renderRoot(root, isYieldy, isExpired) {
   } while (1);
   isWorking = !1;
   lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
-  if (didFatal) (nextRoot = null), (root.finishedWork = null);
-  else if (null !== nextUnitOfWork) root.finishedWork = null;
+  resetHooks();
+  if (didFatal) (nextRoot = null), (root$jscomp$0.finishedWork = null);
+  else if (null !== nextUnitOfWork) root$jscomp$0.finishedWork = null;
   else {
-    isYieldy = root.current.alternate;
+    didFatal = root$jscomp$0.current.alternate;
     invariant(
-      null !== isYieldy,
+      null !== didFatal,
       "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue."
     );
     nextRoot = null;
     if (nextRenderDidError) {
-      didFatal = root.latestPendingTime;
-      sourceFiber = root.latestSuspendedTime;
-      returnFiber = root.latestPingedTime;
+      sourceFiber = root$jscomp$0.latestPendingTime;
+      returnFiber = root$jscomp$0.latestSuspendedTime;
+      root = root$jscomp$0.latestPingedTime;
       if (
-        (0 !== didFatal && didFatal > expirationTime) ||
-        (0 !== sourceFiber && sourceFiber > expirationTime) ||
-        (0 !== returnFiber && returnFiber > expirationTime)
+        (0 !== sourceFiber && sourceFiber < expirationTime) ||
+        (0 !== returnFiber && returnFiber < expirationTime) ||
+        (0 !== root && root < expirationTime)
       ) {
-        root.didError = !1;
-        isExpired = root.latestPingedTime;
-        0 !== isExpired &&
-          isExpired <= expirationTime &&
-          (root.latestPingedTime = 0);
-        isExpired = root.earliestPendingTime;
-        isYieldy = root.latestPendingTime;
-        isExpired === expirationTime
-          ? (root.earliestPendingTime =
-              isYieldy === expirationTime
-                ? (root.latestPendingTime = 0)
-                : isYieldy)
-          : isYieldy === expirationTime && (root.latestPendingTime = isExpired);
-        isExpired = root.earliestSuspendedTime;
-        isYieldy = root.latestSuspendedTime;
-        0 === isExpired
-          ? (root.earliestSuspendedTime = root.latestSuspendedTime = expirationTime)
-          : isExpired > expirationTime
-            ? (root.earliestSuspendedTime = expirationTime)
-            : isYieldy < expirationTime &&
-              (root.latestSuspendedTime = expirationTime);
-        findNextExpirationTimeToWorkOn(expirationTime, root);
-        root.expirationTime = root.expirationTime;
+        markSuspendedPriorityLevel(root$jscomp$0, expirationTime);
+        onSuspend(
+          root$jscomp$0,
+          didFatal,
+          expirationTime,
+          root$jscomp$0.expirationTime,
+          -1
+        );
         return;
       }
-      if (!root.didError && !isExpired) {
-        root.didError = !0;
-        root.nextExpirationTimeToWorkOn = expirationTime;
-        root.expirationTime = 1;
+      if (!root$jscomp$0.didError && isYieldy) {
+        root$jscomp$0.didError = !0;
+        expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn = expirationTime;
+        isYieldy = root$jscomp$0.expirationTime = 1073741823;
+        onSuspend(root$jscomp$0, didFatal, expirationTime, isYieldy, -1);
         return;
       }
     }
-    root.pendingCommitExpirationTime = expirationTime;
-    root.finishedWork = isYieldy;
+    isYieldy && -1 !== nextLatestAbsoluteTimeoutMs
+      ? (markSuspendedPriorityLevel(root$jscomp$0, expirationTime),
+        (isYieldy =
+          10 *
+          (1073741822 -
+            findEarliestOutstandingPriorityLevel(
+              root$jscomp$0,
+              expirationTime
+            ))),
+        isYieldy < nextLatestAbsoluteTimeoutMs &&
+          (nextLatestAbsoluteTimeoutMs = isYieldy),
+        (isYieldy = 10 * (1073741822 - requestCurrentTime())),
+        (isYieldy = nextLatestAbsoluteTimeoutMs - isYieldy),
+        onSuspend(
+          root$jscomp$0,
+          didFatal,
+          expirationTime,
+          root$jscomp$0.expirationTime,
+          0 > isYieldy ? 0 : isYieldy
+        ))
+      : ((root$jscomp$0.pendingCommitExpirationTime = expirationTime),
+        (root$jscomp$0.finishedWork = didFatal));
   }
 }
-function captureCommitPhaseError(fiber, error) {
-  var JSCompiler_inline_result;
-  a: {
-    invariant(
-      !isWorking || isCommitting$1,
-      "dispatch: Cannot dispatch during the render phase."
-    );
-    for (
-      JSCompiler_inline_result = fiber.return;
-      null !== JSCompiler_inline_result;
-
-    ) {
-      switch (JSCompiler_inline_result.tag) {
-        case 2:
-        case 3:
-          var instance = JSCompiler_inline_result.stateNode;
-          if (
-            "function" ===
-              typeof JSCompiler_inline_result.type.getDerivedStateFromError ||
-            ("function" === typeof instance.componentDidCatch &&
-              (null === legacyErrorBoundariesThatAlreadyFailed ||
-                !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
-          ) {
-            fiber = createCapturedValue(error, fiber);
-            fiber = createClassErrorUpdate(JSCompiler_inline_result, fiber, 1);
-            enqueueUpdate(JSCompiler_inline_result, fiber);
-            scheduleWork(JSCompiler_inline_result, 1);
-            JSCompiler_inline_result = void 0;
-            break a;
-          }
-          break;
-        case 5:
-          fiber = createCapturedValue(error, fiber);
-          fiber = createRootErrorUpdate(JSCompiler_inline_result, fiber, 1);
-          enqueueUpdate(JSCompiler_inline_result, fiber);
-          scheduleWork(JSCompiler_inline_result, 1);
-          JSCompiler_inline_result = void 0;
-          break a;
-      }
-      JSCompiler_inline_result = JSCompiler_inline_result.return;
+function captureCommitPhaseError(sourceFiber, value) {
+  for (var fiber = sourceFiber.return; null !== fiber; ) {
+    switch (fiber.tag) {
+      case 1:
+        var instance = fiber.stateNode;
+        if (
+          "function" === typeof fiber.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValue(value, sourceFiber);
+          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
+          enqueueUpdate(fiber, sourceFiber);
+          scheduleWork(fiber, 1073741823);
+          return;
+        }
+        break;
+      case 3:
+        sourceFiber = createCapturedValue(value, sourceFiber);
+        sourceFiber = createRootErrorUpdate(fiber, sourceFiber, 1073741823);
+        enqueueUpdate(fiber, sourceFiber);
+        scheduleWork(fiber, 1073741823);
+        return;
     }
-    5 === fiber.tag &&
-      ((JSCompiler_inline_result = createCapturedValue(error, fiber)),
-      (JSCompiler_inline_result = createRootErrorUpdate(
-        fiber,
-        JSCompiler_inline_result,
-        1
-      )),
-      enqueueUpdate(fiber, JSCompiler_inline_result),
-      scheduleWork(fiber, 1));
-    JSCompiler_inline_result = void 0;
+    fiber = fiber.return;
   }
-  return JSCompiler_inline_result;
+  3 === sourceFiber.tag &&
+    ((fiber = createCapturedValue(value, sourceFiber)),
+    (fiber = createRootErrorUpdate(sourceFiber, fiber, 1073741823)),
+    enqueueUpdate(sourceFiber, fiber),
+    scheduleWork(sourceFiber, 1073741823));
 }
 function computeExpirationForFiber(currentTime, fiber) {
   isWorking
-    ? (currentTime = isCommitting$1 ? 1 : nextRenderExpirationTime)
+    ? (currentTime = isCommitting$1 ? 1073741823 : nextRenderExpirationTime)
     : fiber.mode & 1
       ? ((currentTime = isBatchingInteractiveUpdates
-          ? 2 + 10 * ((((currentTime - 2 + 15) / 10) | 0) + 1)
-          : 2 + 25 * ((((currentTime - 2 + 500) / 25) | 0) + 1)),
+          ? 1073741822 - 10 * ((((1073741822 - currentTime + 15) / 10) | 0) + 1)
+          : 1073741822 -
+            25 * ((((1073741822 - currentTime + 500) / 25) | 0) + 1)),
         null !== nextRoot &&
           currentTime === nextRenderExpirationTime &&
-          (currentTime += 1))
-      : (currentTime = 1);
+          --currentTime)
+      : (currentTime = 1073741823);
   isBatchingInteractiveUpdates &&
-    currentTime > lowestPriorityPendingInteractiveExpirationTime &&
+    (0 === lowestPriorityPendingInteractiveExpirationTime ||
+      currentTime < lowestPriorityPendingInteractiveExpirationTime) &&
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
-function scheduleWork(fiber, expirationTime) {
-  if (0 === fiber.expirationTime || fiber.expirationTime > expirationTime)
-    fiber.expirationTime = expirationTime;
+function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
+  var retryTime = root.earliestSuspendedTime;
+  var latestSuspendedTime = root.latestSuspendedTime;
+  if (
+    0 !== retryTime &&
+    suspendedTime <= retryTime &&
+    suspendedTime >= latestSuspendedTime
+  ) {
+    latestSuspendedTime = retryTime = suspendedTime;
+    root.didError = !1;
+    var latestPingedTime = root.latestPingedTime;
+    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
+      root.latestPingedTime = latestSuspendedTime;
+    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
+  } else
+    (retryTime = requestCurrentTime()),
+      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
+      markPendingPriorityLevel(root, retryTime);
+  0 !== (boundaryFiber.mode & 1) &&
+    root === nextRoot &&
+    nextRenderExpirationTime === suspendedTime &&
+    (nextRoot = null);
+  scheduleWorkToRoot(boundaryFiber, retryTime);
+  0 === (boundaryFiber.mode & 1) &&
+    (scheduleWorkToRoot(sourceFiber, retryTime),
+    1 === sourceFiber.tag &&
+      null !== sourceFiber.stateNode &&
+      ((boundaryFiber = createUpdate(retryTime)),
+      (boundaryFiber.tag = 2),
+      enqueueUpdate(sourceFiber, boundaryFiber)));
+  sourceFiber = root.expirationTime;
+  0 !== sourceFiber && requestWork(root, sourceFiber);
+}
+function scheduleWorkToRoot(fiber, expirationTime) {
+  fiber.expirationTime < expirationTime &&
+    (fiber.expirationTime = expirationTime);
   var alternate = fiber.alternate;
   null !== alternate &&
-    (0 === alternate.expirationTime ||
-      alternate.expirationTime > expirationTime) &&
+    alternate.expirationTime < expirationTime &&
     (alternate.expirationTime = expirationTime);
   var node = fiber.return,
     root = null;
-  if (null === node && 5 === fiber.tag) root = fiber.stateNode;
+  if (null === node && 3 === fiber.tag) root = fiber.stateNode;
   else
     for (; null !== node; ) {
       alternate = node.alternate;
-      if (
-        0 === node.childExpirationTime ||
-        node.childExpirationTime > expirationTime
-      )
-        node.childExpirationTime = expirationTime;
+      node.childExpirationTime < expirationTime &&
+        (node.childExpirationTime = expirationTime);
       null !== alternate &&
-        (0 === alternate.childExpirationTime ||
-          alternate.childExpirationTime > expirationTime) &&
+        alternate.childExpirationTime < expirationTime &&
         (alternate.childExpirationTime = expirationTime);
-      if (null === node.return && 5 === node.tag) {
+      if (null === node.return && 3 === node.tag) {
         root = node.stateNode;
         break;
       }
       node = node.return;
     }
-  fiber = null === root ? null : root;
-  if (null !== fiber) {
-    !isWorking &&
+  return root;
+}
+function scheduleWork(fiber, expirationTime) {
+  fiber = scheduleWorkToRoot(fiber, expirationTime);
+  null !== fiber &&
+    (!isWorking &&
       0 !== nextRenderExpirationTime &&
-      expirationTime < nextRenderExpirationTime &&
-      resetStack();
-    markPendingPriorityLevel(fiber, expirationTime);
-    if (!isWorking || isCommitting$1 || nextRoot !== fiber) {
-      expirationTime = fiber.expirationTime;
-      if (null === fiber.nextScheduledRoot)
-        (fiber.expirationTime = expirationTime),
-          null === lastScheduledRoot
-            ? ((firstScheduledRoot = lastScheduledRoot = fiber),
-              (fiber.nextScheduledRoot = fiber))
-            : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = fiber),
-              (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot));
-      else if (
-        ((alternate = fiber.expirationTime),
-        0 === alternate || expirationTime < alternate)
-      )
-        fiber.expirationTime = expirationTime;
-      isRendering ||
-        (isBatchingUpdates
-          ? isUnbatchingUpdates &&
-            ((nextFlushedRoot = fiber),
-            (nextFlushedExpirationTime = 1),
-            performWorkOnRoot(fiber, 1, !0))
-          : 1 === expirationTime
-            ? performWork(1, null)
-            : scheduleCallbackWithExpirationTime(fiber, expirationTime));
-    }
+      expirationTime > nextRenderExpirationTime &&
+      resetStack(),
+    markPendingPriorityLevel(fiber, expirationTime),
+    (isWorking && !isCommitting$1 && nextRoot === fiber) ||
+      requestWork(fiber, fiber.expirationTime),
     nestedUpdateCount > NESTED_UPDATE_LIMIT &&
       ((nestedUpdateCount = 0),
       invariant(
         !1,
         "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-      ));
-  }
+      )));
 }
 var firstScheduledRoot = null,
   lastScheduledRoot = null,
@@ -5021,27 +5879,25 @@ var firstScheduledRoot = null,
   nextFlushedRoot = null,
   nextFlushedExpirationTime = 0,
   lowestPriorityPendingInteractiveExpirationTime = 0,
-  deadlineDidExpire = !1,
   hasUnhandledError = !1,
   unhandledError = null,
-  deadline = null,
   isBatchingUpdates = !1,
   isUnbatchingUpdates = !1,
   isBatchingInteractiveUpdates = !1,
   completedBatches = null,
   originalStartTimeMs = now$1(),
-  currentRendererTime = ((originalStartTimeMs / 10) | 0) + 2,
+  currentRendererTime = 1073741822 - ((originalStartTimeMs / 10) | 0),
   currentSchedulerTime = currentRendererTime,
   NESTED_UPDATE_LIMIT = 50,
   nestedUpdateCount = 0,
-  lastCommittedRootDuringThisBatch = null,
-  timeHeuristicForUnitOfWork = 1;
+  lastCommittedRootDuringThisBatch = null;
 function recomputeCurrentRendererTime() {
-  currentRendererTime = (((now$1() - originalStartTimeMs) / 10) | 0) + 2;
+  currentRendererTime =
+    1073741822 - (((now$1() - originalStartTimeMs) / 10) | 0);
 }
 function scheduleCallbackWithExpirationTime(root, expirationTime) {
   if (0 !== callbackExpirationTime) {
-    if (expirationTime > callbackExpirationTime) return;
+    if (expirationTime < callbackExpirationTime) return;
     null !== callbackID &&
       ((root = callbackID), (scheduledCallback = null), clearTimeout(root));
   }
@@ -5050,17 +5906,65 @@ function scheduleCallbackWithExpirationTime(root, expirationTime) {
   scheduledCallback = performAsyncWork;
   callbackID = setTimeout(setTimeoutCallback, 1);
 }
+function onSuspend(
+  root,
+  finishedWork,
+  suspendedExpirationTime,
+  rootExpirationTime,
+  msUntilTimeout
+) {
+  root.expirationTime = rootExpirationTime;
+  0 !== msUntilTimeout || shouldYieldToRenderer()
+    ? 0 < msUntilTimeout &&
+      (root.timeoutHandle = scheduleTimeout(
+        onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
+        msUntilTimeout
+      ))
+    : ((root.pendingCommitExpirationTime = suspendedExpirationTime),
+      (root.finishedWork = finishedWork));
+}
+function onTimeout(root, finishedWork, suspendedExpirationTime) {
+  root.pendingCommitExpirationTime = suspendedExpirationTime;
+  root.finishedWork = finishedWork;
+  recomputeCurrentRendererTime();
+  currentSchedulerTime = currentRendererTime;
+  invariant(
+    !isRendering,
+    "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method."
+  );
+  nextFlushedRoot = root;
+  nextFlushedExpirationTime = suspendedExpirationTime;
+  performWorkOnRoot(root, suspendedExpirationTime, !1);
+  performWork(1073741823, !1);
+}
 function requestCurrentTime() {
   if (isRendering) return currentSchedulerTime;
   findHighestPriorityRoot();
-  if (
-    0 === nextFlushedExpirationTime ||
-    1073741823 === nextFlushedExpirationTime
-  )
+  if (0 === nextFlushedExpirationTime || 1 === nextFlushedExpirationTime)
     recomputeCurrentRendererTime(),
       (currentSchedulerTime = currentRendererTime);
   return currentSchedulerTime;
 }
+function requestWork(root, expirationTime) {
+  null === root.nextScheduledRoot
+    ? ((root.expirationTime = expirationTime),
+      null === lastScheduledRoot
+        ? ((firstScheduledRoot = lastScheduledRoot = root),
+          (root.nextScheduledRoot = root))
+        : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root),
+          (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot)))
+    : expirationTime > root.expirationTime &&
+      (root.expirationTime = expirationTime);
+  isRendering ||
+    (isBatchingUpdates
+      ? isUnbatchingUpdates &&
+        ((nextFlushedRoot = root),
+        (nextFlushedExpirationTime = 1073741823),
+        performWorkOnRoot(root, 1073741823, !1))
+      : 1073741823 === expirationTime
+        ? performWork(1073741823, !1)
+        : scheduleCallbackWithExpirationTime(root, expirationTime));
+}
 function findHighestPriorityRoot() {
   var highestPriorityWork = 0,
     highestPriorityRoot = null;
@@ -5094,14 +5998,11 @@ function findHighestPriorityRoot() {
             (root.nextScheduledRoot = null);
         root = previousScheduledRoot.nextScheduledRoot;
       } else {
-        if (
-          0 === highestPriorityWork ||
-          remainingExpirationTime < highestPriorityWork
-        )
-          (highestPriorityWork = remainingExpirationTime),
-            (highestPriorityRoot = root);
+        remainingExpirationTime > highestPriorityWork &&
+          ((highestPriorityWork = remainingExpirationTime),
+          (highestPriorityRoot = root));
         if (root === lastScheduledRoot) break;
-        if (1 === highestPriorityWork) break;
+        if (1073741823 === highestPriorityWork) break;
         previousScheduledRoot = root;
         root = root.nextScheduledRoot;
       }
@@ -5109,38 +6010,44 @@ function findHighestPriorityRoot() {
   nextFlushedRoot = highestPriorityRoot;
   nextFlushedExpirationTime = highestPriorityWork;
 }
-function performAsyncWork(dl) {
-  if (dl.didTimeout && null !== firstScheduledRoot) {
-    recomputeCurrentRendererTime();
-    var root = firstScheduledRoot;
-    do {
-      var expirationTime = root.expirationTime;
-      0 !== expirationTime &&
-        currentRendererTime >= expirationTime &&
-        (root.nextExpirationTimeToWorkOn = currentRendererTime);
-      root = root.nextScheduledRoot;
-    } while (root !== firstScheduledRoot);
+var didYield = !1;
+function shouldYieldToRenderer() {
+  return didYield ? !0 : frameDeadline <= now$1() ? (didYield = !0) : !1;
+}
+function performAsyncWork() {
+  try {
+    if (!shouldYieldToRenderer() && null !== firstScheduledRoot) {
+      recomputeCurrentRendererTime();
+      var root = firstScheduledRoot;
+      do {
+        var expirationTime = root.expirationTime;
+        0 !== expirationTime &&
+          currentRendererTime <= expirationTime &&
+          (root.nextExpirationTimeToWorkOn = currentRendererTime);
+        root = root.nextScheduledRoot;
+      } while (root !== firstScheduledRoot);
+    }
+    performWork(0, !0);
+  } finally {
+    didYield = !1;
   }
-  performWork(0, dl);
 }
-function performWork(minExpirationTime, dl) {
-  deadline = dl;
+function performWork(minExpirationTime, isYieldy) {
   findHighestPriorityRoot();
-  if (null !== deadline)
+  if (isYieldy)
     for (
       recomputeCurrentRendererTime(),
         currentSchedulerTime = currentRendererTime;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime) &&
-      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime &&
+      !(didYield && currentRendererTime > nextFlushedExpirationTime);
 
     )
       performWorkOnRoot(
         nextFlushedRoot,
         nextFlushedExpirationTime,
-        currentRendererTime >= nextFlushedExpirationTime
+        currentRendererTime > nextFlushedExpirationTime
       ),
         findHighestPriorityRoot(),
         recomputeCurrentRendererTime(),
@@ -5150,29 +6057,28 @@ function performWork(minExpirationTime, dl) {
       ;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime;
 
     )
-      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !0),
+      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !1),
         findHighestPriorityRoot();
-  null !== deadline && ((callbackExpirationTime = 0), (callbackID = null));
+  isYieldy && ((callbackExpirationTime = 0), (callbackID = null));
   0 !== nextFlushedExpirationTime &&
     scheduleCallbackWithExpirationTime(
       nextFlushedRoot,
       nextFlushedExpirationTime
     );
-  deadline = null;
-  deadlineDidExpire = !1;
   nestedUpdateCount = 0;
   lastCommittedRootDuringThisBatch = null;
   if (null !== completedBatches)
     for (
-      minExpirationTime = completedBatches, completedBatches = null, dl = 0;
-      dl < minExpirationTime.length;
-      dl++
+      minExpirationTime = completedBatches,
+        completedBatches = null,
+        isYieldy = 0;
+      isYieldy < minExpirationTime.length;
+      isYieldy++
     ) {
-      var batch = minExpirationTime[dl];
+      var batch = minExpirationTime[isYieldy];
       try {
         batch._onComplete();
       } catch (error) {
@@ -5186,39 +6092,45 @@ function performWork(minExpirationTime, dl) {
     (hasUnhandledError = !1),
     minExpirationTime);
 }
-function performWorkOnRoot(root, expirationTime, isExpired) {
+function performWorkOnRoot(root, expirationTime, isYieldy) {
   invariant(
     !isRendering,
     "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
   isRendering = !0;
-  if (null === deadline || isExpired) {
-    var finishedWork = root.finishedWork;
-    null !== finishedWork
-      ? completeRoot$1(root, finishedWork, expirationTime)
+  if (isYieldy) {
+    var _finishedWork = root.finishedWork;
+    null !== _finishedWork
+      ? completeRoot$1(root, _finishedWork, expirationTime)
       : ((root.finishedWork = null),
-        renderRoot(root, !1, isExpired),
-        (finishedWork = root.finishedWork),
-        null !== finishedWork &&
-          completeRoot$1(root, finishedWork, expirationTime));
+        (_finishedWork = root.timeoutHandle),
+        -1 !== _finishedWork &&
+          ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+        renderRoot(root, isYieldy),
+        (_finishedWork = root.finishedWork),
+        null !== _finishedWork &&
+          (shouldYieldToRenderer()
+            ? (root.finishedWork = _finishedWork)
+            : completeRoot$1(root, _finishedWork, expirationTime)));
   } else
-    (finishedWork = root.finishedWork),
-      null !== finishedWork
-        ? completeRoot$1(root, finishedWork, expirationTime)
+    (_finishedWork = root.finishedWork),
+      null !== _finishedWork
+        ? completeRoot$1(root, _finishedWork, expirationTime)
         : ((root.finishedWork = null),
-          renderRoot(root, !0, isExpired),
-          (finishedWork = root.finishedWork),
-          null !== finishedWork &&
-            (shouldYield()
-              ? (root.finishedWork = finishedWork)
-              : completeRoot$1(root, finishedWork, expirationTime)));
+          (_finishedWork = root.timeoutHandle),
+          -1 !== _finishedWork &&
+            ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+          renderRoot(root, isYieldy),
+          (_finishedWork = root.finishedWork),
+          null !== _finishedWork &&
+            completeRoot$1(root, _finishedWork, expirationTime));
   isRendering = !1;
 }
 function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
   var firstBatch = root.firstBatch;
   if (
     null !== firstBatch &&
-    firstBatch._expirationTime <= expirationTime &&
+    firstBatch._expirationTime >= expirationTime &&
     (null === completedBatches
       ? (completedBatches = [firstBatch])
       : completedBatches.push(firstBatch),
@@ -5247,9 +6159,7 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
   var childExpirationTimeBeforeCommit =
     finishedWork$jscomp$0.childExpirationTime;
   firstBatch =
-    0 === firstBatch ||
-    (0 !== childExpirationTimeBeforeCommit &&
-      childExpirationTimeBeforeCommit < firstBatch)
+    childExpirationTimeBeforeCommit > firstBatch
       ? childExpirationTimeBeforeCommit
       : firstBatch;
   root.didError = !1;
@@ -5261,19 +6171,19 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
       (root.latestPingedTime = 0))
     : ((childExpirationTimeBeforeCommit = root.latestPendingTime),
       0 !== childExpirationTimeBeforeCommit &&
-        (childExpirationTimeBeforeCommit < firstBatch
+        (childExpirationTimeBeforeCommit > firstBatch
           ? (root.earliestPendingTime = root.latestPendingTime = 0)
-          : root.earliestPendingTime < firstBatch &&
+          : root.earliestPendingTime > firstBatch &&
             (root.earliestPendingTime = root.latestPendingTime)),
       (childExpirationTimeBeforeCommit = root.earliestSuspendedTime),
       0 === childExpirationTimeBeforeCommit
         ? markPendingPriorityLevel(root, firstBatch)
-        : firstBatch > root.latestSuspendedTime
+        : firstBatch < root.latestSuspendedTime
           ? ((root.earliestSuspendedTime = 0),
             (root.latestSuspendedTime = 0),
             (root.latestPingedTime = 0),
             markPendingPriorityLevel(root, firstBatch))
-          : firstBatch < childExpirationTimeBeforeCommit &&
+          : firstBatch > childExpirationTimeBeforeCommit &&
             markPendingPriorityLevel(root, firstBatch));
   findNextExpirationTimeToWorkOn(0, root);
   ReactCurrentOwner$2.current = null;
@@ -5285,33 +6195,38 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
     : (firstBatch = finishedWork$jscomp$0.firstEffect);
   for (nextEffect = firstBatch; null !== nextEffect; ) {
     childExpirationTimeBeforeCommit = !1;
-    var error = void 0;
+    var error$jscomp$0 = void 0;
     try {
       for (; null !== nextEffect; ) {
-        if (nextEffect.effectTag & 256) {
-          var current$$1 = nextEffect.alternate;
+        if (nextEffect.effectTag & 256)
           a: {
-            var finishedWork = nextEffect;
+            var current$$1 = nextEffect.alternate,
+              finishedWork = nextEffect;
             switch (finishedWork.tag) {
-              case 2:
-              case 3:
+              case 0:
+              case 11:
+              case 15:
+                commitHookEffectList(2, 0, finishedWork);
+                break a;
+              case 1:
                 if (finishedWork.effectTag & 256 && null !== current$$1) {
                   var prevProps = current$$1.memoizedProps,
                     prevState = current$$1.memoizedState,
-                    instance = finishedWork.stateNode;
-                  instance.props = finishedWork.memoizedProps;
-                  instance.state = finishedWork.memoizedState;
-                  var snapshot = instance.getSnapshotBeforeUpdate(
-                    prevProps,
-                    prevState
-                  );
+                    instance = finishedWork.stateNode,
+                    snapshot = instance.getSnapshotBeforeUpdate(
+                      finishedWork.elementType === finishedWork.type
+                        ? prevProps
+                        : resolveDefaultProps(finishedWork.type, prevProps),
+                      prevState
+                    );
                   instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                 }
                 break a;
+              case 3:
               case 5:
-              case 7:
-              case 8:
               case 6:
+              case 4:
+              case 17:
                 break a;
               default:
                 invariant(
@@ -5320,18 +6235,17 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
                 );
             }
           }
-        }
         nextEffect = nextEffect.nextEffect;
       }
     } catch (e) {
-      (childExpirationTimeBeforeCommit = !0), (error = e);
+      (childExpirationTimeBeforeCommit = !0), (error$jscomp$0 = e);
     }
     childExpirationTimeBeforeCommit &&
       (invariant(
         null !== nextEffect,
         "Should have next effect. This error is likely caused by a bug in React. Please file an issue."
       ),
-      captureCommitPhaseError(nextEffect, error),
+      captureCommitPhaseError(nextEffect, error$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
   for (nextEffect = firstBatch; null !== nextEffect; ) {
@@ -5368,8 +6282,32 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
               "function" === typeof onCommitFiberUnmount &&
                 onCommitFiberUnmount(childExpirationTimeBeforeCommit);
               switch (childExpirationTimeBeforeCommit.tag) {
-                case 2:
-                case 3:
+                case 0:
+                case 11:
+                case 14:
+                case 15:
+                  var updateQueue = childExpirationTimeBeforeCommit.updateQueue;
+                  if (null !== updateQueue) {
+                    var lastEffect = updateQueue.lastEffect;
+                    if (null !== lastEffect) {
+                      var firstEffect = lastEffect.next;
+                      error$jscomp$0 = firstEffect;
+                      do {
+                        var destroy = error$jscomp$0.destroy;
+                        if (null !== destroy) {
+                          finishedWork = childExpirationTimeBeforeCommit;
+                          try {
+                            destroy();
+                          } catch (error) {
+                            captureCommitPhaseError(finishedWork, error);
+                          }
+                        }
+                        error$jscomp$0 = error$jscomp$0.next;
+                      } while (error$jscomp$0 !== firstEffect);
+                    }
+                  }
+                  break;
+                case 1:
                   safelyDetachRef(childExpirationTimeBeforeCommit);
                   var instance$jscomp$0 =
                     childExpirationTimeBeforeCommit.stateNode;
@@ -5389,10 +6327,10 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
                       );
                     }
                   break;
-                case 7:
+                case 5:
                   safelyDetachRef(childExpirationTimeBeforeCommit);
                   break;
-                case 6:
+                case 4:
                   FabricUIManager.createChildSet(
                     childExpirationTimeBeforeCommit.stateNode.containerInfo
                   );
@@ -5434,79 +6372,87 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
     effectTag = !1;
     current$$1$jscomp$0 = void 0;
     try {
-      for (currentRef = expirationTime; null !== nextEffect; ) {
+      for (
+        currentRef = root, updateQueue = expirationTime;
+        null !== nextEffect;
+
+      ) {
         var effectTag$jscomp$0 = nextEffect.effectTag;
         if (effectTag$jscomp$0 & 36) {
           var current$$1$jscomp$1 = nextEffect.alternate;
-          instance$jscomp$0 = nextEffect;
-          firstBatch = currentRef;
-          switch (instance$jscomp$0.tag) {
-            case 2:
-            case 3:
-              var instance$jscomp$1 = instance$jscomp$0.stateNode;
-              if (instance$jscomp$0.effectTag & 4)
+          lastEffect = nextEffect;
+          firstEffect = updateQueue;
+          switch (lastEffect.tag) {
+            case 0:
+            case 11:
+            case 15:
+              commitHookEffectList(16, 32, lastEffect);
+              break;
+            case 1:
+              var instance$jscomp$1 = lastEffect.stateNode;
+              if (lastEffect.effectTag & 4)
                 if (null === current$$1$jscomp$1)
-                  (instance$jscomp$1.props = instance$jscomp$0.memoizedProps),
-                    (instance$jscomp$1.state = instance$jscomp$0.memoizedState),
-                    instance$jscomp$1.componentDidMount();
+                  instance$jscomp$1.componentDidMount();
                 else {
-                  var prevProps$jscomp$0 = current$$1$jscomp$1.memoizedProps,
-                    prevState$jscomp$0 = current$$1$jscomp$1.memoizedState;
-                  instance$jscomp$1.props = instance$jscomp$0.memoizedProps;
-                  instance$jscomp$1.state = instance$jscomp$0.memoizedState;
+                  var prevProps$jscomp$0 =
+                    lastEffect.elementType === lastEffect.type
+                      ? current$$1$jscomp$1.memoizedProps
+                      : resolveDefaultProps(
+                          lastEffect.type,
+                          current$$1$jscomp$1.memoizedProps
+                        );
                   instance$jscomp$1.componentDidUpdate(
                     prevProps$jscomp$0,
-                    prevState$jscomp$0,
+                    current$$1$jscomp$1.memoizedState,
                     instance$jscomp$1.__reactInternalSnapshotBeforeUpdate
                   );
                 }
-              var updateQueue = instance$jscomp$0.updateQueue;
-              null !== updateQueue &&
-                ((instance$jscomp$1.props = instance$jscomp$0.memoizedProps),
-                (instance$jscomp$1.state = instance$jscomp$0.memoizedState),
+              var updateQueue$jscomp$0 = lastEffect.updateQueue;
+              null !== updateQueue$jscomp$0 &&
                 commitUpdateQueue(
-                  instance$jscomp$0,
-                  updateQueue,
+                  lastEffect,
+                  updateQueue$jscomp$0,
                   instance$jscomp$1,
-                  firstBatch
-                ));
+                  firstEffect
+                );
               break;
-            case 5:
-              var _updateQueue = instance$jscomp$0.updateQueue;
+            case 3:
+              var _updateQueue = lastEffect.updateQueue;
               if (null !== _updateQueue) {
-                current$$1 = null;
-                if (null !== instance$jscomp$0.child)
-                  switch (instance$jscomp$0.child.tag) {
-                    case 7:
-                      current$$1 = instance$jscomp$0.child.stateNode.canonical;
+                destroy = null;
+                if (null !== lastEffect.child)
+                  switch (lastEffect.child.tag) {
+                    case 5:
+                      destroy = lastEffect.child.stateNode.canonical;
                       break;
-                    case 2:
-                    case 3:
-                      current$$1 = instance$jscomp$0.child.stateNode;
+                    case 1:
+                      destroy = lastEffect.child.stateNode;
                   }
                 commitUpdateQueue(
-                  instance$jscomp$0,
+                  lastEffect,
                   _updateQueue,
-                  current$$1,
-                  firstBatch
+                  destroy,
+                  firstEffect
                 );
               }
               break;
-            case 7:
+            case 5:
               null === current$$1$jscomp$1 &&
-                instance$jscomp$0.effectTag & 4 &&
+                lastEffect.effectTag & 4 &&
                 invariant(
                   !1,
                   "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
                 );
               break;
-            case 8:
-              break;
             case 6:
               break;
-            case 15:
+            case 4:
               break;
-            case 16:
+            case 12:
+              break;
+            case 13:
+              break;
+            case 17:
               break;
             default:
               invariant(
@@ -5520,7 +6466,7 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
           if (null !== ref) {
             var instance$jscomp$2 = nextEffect.stateNode;
             switch (nextEffect.tag) {
-              case 7:
+              case 5:
                 var instanceToUse = instance$jscomp$2.canonical;
                 break;
               default:
@@ -5531,9 +6477,9 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
               : (ref.current = instanceToUse);
           }
         }
-        var next = nextEffect.nextEffect;
-        nextEffect.nextEffect = null;
-        nextEffect = next;
+        effectTag$jscomp$0 & 512 &&
+          (rootWithPendingPassiveEffects = currentRef);
+        nextEffect = nextEffect.nextEffect;
       }
     } catch (e) {
       (effectTag = !0), (current$$1$jscomp$0 = e);
@@ -5546,14 +6492,20 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
       captureCommitPhaseError(nextEffect, current$$1$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== firstBatch &&
+    null !== rootWithPendingPassiveEffects &&
+    ((effectTag$jscomp$0 = commitPassiveEffects.bind(null, root, firstBatch)),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      effectTag$jscomp$0
+    )),
+    (passiveEffectCallback = effectTag$jscomp$0));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork$jscomp$0.stateNode);
   effectTag$jscomp$0 = finishedWork$jscomp$0.expirationTime;
   finishedWork$jscomp$0 = finishedWork$jscomp$0.childExpirationTime;
   finishedWork$jscomp$0 =
-    0 === effectTag$jscomp$0 ||
-    (0 !== finishedWork$jscomp$0 && finishedWork$jscomp$0 < effectTag$jscomp$0)
+    finishedWork$jscomp$0 > effectTag$jscomp$0
       ? finishedWork$jscomp$0
       : effectTag$jscomp$0;
   0 === finishedWork$jscomp$0 &&
@@ -5561,13 +6513,6 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
   root.expirationTime = finishedWork$jscomp$0;
   root.finishedWork = null;
 }
-function shouldYield() {
-  return deadlineDidExpire
-    ? !0
-    : null === deadline || deadline.timeRemaining() > timeHeuristicForUnitOfWork
-      ? !1
-      : (deadlineDidExpire = !0);
-}
 function onUncaughtError(error) {
   invariant(
     null !== nextFlushedRoot,
@@ -5576,55 +6521,6 @@ function onUncaughtError(error) {
   nextFlushedRoot.expirationTime = 0;
   hasUnhandledError || ((hasUnhandledError = !0), (unhandledError = error));
 }
-function getContextForSubtree(parentComponent) {
-  if (!parentComponent) return emptyContextObject;
-  parentComponent = parentComponent._reactInternalFiber;
-  a: {
-    invariant(
-      2 === isFiberMountedImpl(parentComponent) &&
-        (2 === parentComponent.tag || 3 === parentComponent.tag),
-      "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-    );
-    var parentContext = parentComponent;
-    do {
-      switch (parentContext.tag) {
-        case 5:
-          parentContext = parentContext.stateNode.context;
-          break a;
-        case 2:
-          if (isContextProvider(parentContext.type)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-          break;
-        case 3:
-          if (isContextProvider(parentContext.type._reactResult)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-      }
-      parentContext = parentContext.return;
-    } while (null !== parentContext);
-    invariant(
-      !1,
-      "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-    );
-    parentContext = void 0;
-  }
-  if (2 === parentComponent.tag) {
-    var Component = parentComponent.type;
-    if (isContextProvider(Component))
-      return processChildContext(parentComponent, Component, parentContext);
-  } else if (
-    3 === parentComponent.tag &&
-    ((Component = parentComponent.type._reactResult),
-    isContextProvider(Component))
-  )
-    return processChildContext(parentComponent, Component, parentContext);
-  return parentContext;
-}
 function findHostInstance$1(component) {
   var fiber = component._reactInternalFiber;
   void 0 === fiber &&
@@ -5643,7 +6539,48 @@ function updateContainer(element, container, parentComponent, callback) {
     currentTime = requestCurrentTime();
   current$$1 = computeExpirationForFiber(currentTime, current$$1);
   currentTime = container.current;
-  parentComponent = getContextForSubtree(parentComponent);
+  a: if (parentComponent) {
+    parentComponent = parentComponent._reactInternalFiber;
+    b: {
+      invariant(
+        2 === isFiberMountedImpl(parentComponent) && 1 === parentComponent.tag,
+        "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
+      );
+      var parentContext = parentComponent;
+      do {
+        switch (parentContext.tag) {
+          case 3:
+            parentContext = parentContext.stateNode.context;
+            break b;
+          case 1:
+            if (isContextProvider(parentContext.type)) {
+              parentContext =
+                parentContext.stateNode
+                  .__reactInternalMemoizedMergedChildContext;
+              break b;
+            }
+        }
+        parentContext = parentContext.return;
+      } while (null !== parentContext);
+      invariant(
+        !1,
+        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
+      );
+      parentContext = void 0;
+    }
+    if (1 === parentComponent.tag) {
+      var Component = parentComponent.type;
+      if (isContextProvider(Component)) {
+        parentComponent = processChildContext(
+          parentComponent,
+          Component,
+          parentContext
+        );
+        break a;
+      }
+    }
+    parentComponent = parentContext;
+  } else parentComponent = emptyContextObject;
   null === container.context
     ? (container.context = parentComponent)
     : (container.pendingContext = parentComponent);
@@ -5652,6 +6589,7 @@ function updateContainer(element, container, parentComponent, callback) {
   callback.payload = { element: element };
   container = void 0 === container ? null : container;
   null !== container && (callback.callback = container);
+  flushPassiveEffects();
   enqueueUpdate(currentTime, callback);
   scheduleWork(currentTime, current$$1);
   return current$$1;
@@ -5711,13 +6649,13 @@ _batchedUpdatesImpl = function(fn, a) {
   } finally {
     (isBatchingUpdates = previousIsBatchingUpdates) ||
       isRendering ||
-      performWork(1, null);
+      performWork(1073741823, !1);
   }
 };
 _flushInteractiveUpdatesImpl = function() {
   isRendering ||
     0 === lowestPriorityPendingInteractiveExpirationTime ||
-    (performWork(lowestPriorityPendingInteractiveExpirationTime, null),
+    (performWork(lowestPriorityPendingInteractiveExpirationTime, !1),
     (lowestPriorityPendingInteractiveExpirationTime = 0));
 };
 var roots = new Map(),
@@ -5797,7 +6735,7 @@ var roots = new Map(),
     render: function(element, containerTag, callback) {
       var root = roots.get(containerTag);
       if (!root) {
-        root = new FiberNode(5, null, null, 0);
+        root = createFiber(3, null, null, 0);
         var root$jscomp$0 = {
           current: root,
           containerInfo: containerTag,
@@ -5825,7 +6763,7 @@ var roots = new Map(),
       updateContainer(element, root, null, callback);
       a: if (((element = root.current), element.child))
         switch (element.child.tag) {
-          case 7:
+          case 5:
             element = element.child.stateNode.canonical;
             break a;
           default:
@@ -5922,7 +6860,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromInstance,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.5.2",
+  version: "16.6.1",
   rendererPackageName: "react-native-renderer"
 });
 var ReactFabric$2 = { default: ReactFabric },
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-profiling.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-profiling.js
@@ -20,6 +20,7 @@ var ReactNativeViewConfigRegistry = require("ReactNativeViewConfigRegistry"),
   TextInputState = require("TextInputState"),
   FabricUIManager = require("FabricUIManager"),
   tracing = require("scheduler/tracing"),
+  scheduler = require("scheduler"),
   ExceptionsManager = require("ExceptionsManager");
 function invariant(condition, format, a, b, c, d, e, f) {
   if (!condition) {
@@ -167,10 +168,10 @@ var plugins = [],
   getFiberCurrentPropsFromNode = null,
   getInstanceFromNode = null,
   getNodeFromInstance = null;
-function executeDispatch(event, simulated, listener, inst) {
-  simulated = event.type || "unknown-event";
+function executeDispatch(event, listener, inst) {
+  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
-  invokeGuardedCallbackAndCatchFirstError(simulated, listener, void 0, event);
+  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
@@ -216,10 +217,10 @@ function executeDispatchesAndReleaseTopLevel(e) {
         i < dispatchListeners.length && !e.isPropagationStopped();
         i++
       )
-        executeDispatch(e, !1, dispatchListeners[i], dispatchInstances[i]);
+        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
     else
       dispatchListeners &&
-        executeDispatch(e, !1, dispatchListeners, dispatchInstances);
+        executeDispatch(e, dispatchListeners, dispatchInstances);
     e._dispatchListeners = null;
     e._dispatchInstances = null;
     e.isPersistent() || e.constructor.release(e);
@@ -294,7 +295,7 @@ function getListener(inst, registrationName) {
 }
 function getParent(inst) {
   do inst = inst.return;
-  while (inst && 7 !== inst.tag);
+  while (inst && 5 !== inst.tag);
   return inst ? inst : null;
 }
 function traverseTwoPhase(inst, fn, arg) {
@@ -1034,8 +1035,9 @@ var ReactSharedInternals =
     ? Symbol.for("react.concurrent_mode")
     : 60111,
   REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112,
-  REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for("react.placeholder") : 60113,
-  REACT_PURE_TYPE = hasSymbol ? Symbol.for("react.pure") : 60115,
+  REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
+  REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
+  REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
   MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
@@ -1059,29 +1061,28 @@ function getComponentName(type) {
       return "Profiler";
     case REACT_STRICT_MODE_TYPE:
       return "StrictMode";
-    case REACT_PLACEHOLDER_TYPE:
-      return "Placeholder";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
   }
-  if ("object" === typeof type) {
+  if ("object" === typeof type)
     switch (type.$$typeof) {
       case REACT_CONTEXT_TYPE:
         return "Context.Consumer";
       case REACT_PROVIDER_TYPE:
         return "Context.Provider";
       case REACT_FORWARD_REF_TYPE:
-        var renderFn = type.render;
-        renderFn = renderFn.displayName || renderFn.name || "";
+        var innerType = type.render;
+        innerType = innerType.displayName || innerType.name || "";
         return (
           type.displayName ||
-          ("" !== renderFn ? "ForwardRef(" + renderFn + ")" : "ForwardRef")
+          ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef")
         );
+      case REACT_MEMO_TYPE:
+        return getComponentName(type.type);
+      case REACT_LAZY_TYPE:
+        if ((type = 1 === type._status ? type._result : null))
+          return getComponentName(type);
     }
-    if (
-      "function" === typeof type.then &&
-      (type = 1 === type._reactStatus ? type._reactResult : null)
-    )
-      return getComponentName(type);
-  }
   return null;
 }
 function isFiberMountedImpl(fiber) {
@@ -1092,7 +1093,7 @@ function isFiberMountedImpl(fiber) {
     for (; node.return; )
       if (((node = node.return), 0 !== (node.effectTag & 2))) return 1;
   }
-  return 5 === node.tag ? 2 : 3;
+  return 3 === node.tag ? 2 : 3;
 }
 function assertIsMounted(fiber) {
   invariant(
@@ -1168,14 +1169,14 @@ function findCurrentFiberUsingSlowPath(fiber) {
       "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
     );
   }
-  invariant(5 === a.tag, "Unable to find node on an unmounted component.");
+  invariant(3 === a.tag, "Unable to find node on an unmounted component.");
   return a.stateNode.current === a ? fiber : alternate;
 }
 function findCurrentHostFiber(parent) {
   parent = findCurrentFiberUsingSlowPath(parent);
   if (!parent) return null;
   for (var node = parent; ; ) {
-    if (7 === node.tag || 8 === node.tag) return node;
+    if (5 === node.tag || 6 === node.tag) return node;
     if (node.child) (node.child.return = node), (node = node.child);
     else {
       if (node === parent) break;
@@ -1425,18 +1426,12 @@ var now$1 =
           return Date.now();
         },
   scheduledCallback = null,
-  frameDeadline = 0,
-  frameDeadlineObject = {
-    timeRemaining: function() {
-      return frameDeadline - now$1();
-    },
-    didTimeout: !1
-  };
+  frameDeadline = 0;
 function setTimeoutCallback() {
   frameDeadline = now$1() + 5;
   var callback = scheduledCallback;
   scheduledCallback = null;
-  null !== callback && callback(frameDeadlineObject);
+  null !== callback && callback();
 }
 var restoreTarget = null,
   restoreQueue = null;
@@ -1511,7 +1506,7 @@ function dispatchEvent(target, topLevelType, nativeEvent) {
 function shim$1() {
   invariant(
     !1,
-    "The current renderer does not support hyration. This error is likely caused by a bug in React. Please file an issue."
+    "The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue."
   );
 }
 var nextReactTag = 2;
@@ -1594,18 +1589,44 @@ function createTextInstance(
   };
 }
 var scheduleTimeout = setTimeout,
-  BEFORE_SLASH_RE = /^(.*)[\\\/]/;
+  cancelTimeout = clearTimeout;
+function cloneHiddenInstance(instance) {
+  var node = instance.node;
+  var updatePayload = diffProperties(
+    null,
+    emptyObject,
+    { style: { display: "none" } },
+    instance.canonical.viewConfig.validAttributes
+  );
+  return {
+    node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
+    canonical: instance.canonical
+  };
+}
+function cloneUnhiddenInstance(instance, type, props) {
+  var viewConfig = instance.canonical.viewConfig;
+  type = instance.node;
+  var prevProps = Object.assign({}, props, {
+    style: [props.style, { display: "none" }]
+  });
+  props = diffProperties(null, prevProps, props, viewConfig.validAttributes);
+  return {
+    node: FabricUIManager.cloneNodeWithNewProps(type, props),
+    canonical: instance.canonical
+  };
+}
+var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 function getStackByFiberInDevAndProd(workInProgress) {
   var info = "";
   do {
     a: switch (workInProgress.tag) {
-      case 4:
+      case 2:
+      case 16:
       case 0:
       case 1:
-      case 2:
-      case 3:
-      case 7:
-      case 10:
+      case 5:
+      case 8:
+      case 13:
         var owner = workInProgress._debugOwner,
           source = workInProgress._debugSource,
           name = getComponentName(workInProgress.type);
@@ -1757,7 +1778,7 @@ function injectInternals(internals) {
 function FiberNode(tag, pendingProps, key, mode) {
   this.tag = tag;
   this.key = key;
-  this.sibling = this.child = this.return = this.stateNode = this.type = null;
+  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
@@ -1771,29 +1792,33 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.actualStartTime = -1;
   this.treeBaseDuration = this.selfBaseDuration = 0;
 }
+function createFiber(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
 function shouldConstruct(Component) {
   Component = Component.prototype;
   return !(!Component || !Component.isReactComponent);
 }
-function resolveLazyComponentTag(fiber, Component) {
+function resolveLazyComponentTag(Component) {
   if ("function" === typeof Component)
-    return shouldConstruct(Component) ? 3 : 1;
+    return shouldConstruct(Component) ? 1 : 0;
   if (void 0 !== Component && null !== Component) {
-    fiber = Component.$$typeof;
-    if (fiber === REACT_FORWARD_REF_TYPE) return 14;
-    if (fiber === REACT_PURE_TYPE) return 18;
+    Component = Component.$$typeof;
+    if (Component === REACT_FORWARD_REF_TYPE) return 11;
+    if (Component === REACT_MEMO_TYPE) return 14;
   }
-  return 4;
+  return 2;
 }
 function createWorkInProgress(current, pendingProps) {
   var workInProgress = current.alternate;
   null === workInProgress
-    ? ((workInProgress = new FiberNode(
+    ? ((workInProgress = createFiber(
         current.tag,
         pendingProps,
         current.key,
         current.mode
       )),
+      (workInProgress.elementType = current.elementType),
       (workInProgress.type = current.type),
       (workInProgress.stateNode = current.stateNode),
       (workInProgress.alternate = current),
@@ -1819,60 +1844,66 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.treeBaseDuration = current.treeBaseDuration;
   return workInProgress;
 }
-function createFiberFromElement(element, mode, expirationTime) {
-  var type = element.type,
-    key = element.key;
-  element = element.props;
-  var fiberTag = void 0;
-  if ("function" === typeof type) fiberTag = shouldConstruct(type) ? 2 : 4;
-  else if ("string" === typeof type) fiberTag = 7;
+function createFiberFromTypeAndProps(
+  type,
+  key,
+  pendingProps,
+  owner,
+  mode,
+  expirationTime
+) {
+  var fiberTag = 2;
+  owner = type;
+  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
+  else if ("string" === typeof type) fiberTag = 5;
   else
     a: switch (type) {
       case REACT_FRAGMENT_TYPE:
         return createFiberFromFragment(
-          element.children,
+          pendingProps.children,
           mode,
           expirationTime,
           key
         );
       case REACT_CONCURRENT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 3;
-        break;
+        return createFiberFromMode(pendingProps, mode | 3, expirationTime, key);
       case REACT_STRICT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 2;
-        break;
+        return createFiberFromMode(pendingProps, mode | 2, expirationTime, key);
       case REACT_PROFILER_TYPE:
         return (
-          (type = new FiberNode(15, element, key, mode | 4)),
+          (type = createFiber(12, pendingProps, key, mode | 4)),
+          (type.elementType = REACT_PROFILER_TYPE),
           (type.type = REACT_PROFILER_TYPE),
           (type.expirationTime = expirationTime),
           type
         );
-      case REACT_PLACEHOLDER_TYPE:
-        fiberTag = 16;
-        break;
+      case REACT_SUSPENSE_TYPE:
+        return (
+          (type = createFiber(13, pendingProps, key, mode)),
+          (type.elementType = REACT_SUSPENSE_TYPE),
+          (type.type = REACT_SUSPENSE_TYPE),
+          (type.expirationTime = expirationTime),
+          type
+        );
       default:
         if ("object" === typeof type && null !== type)
           switch (type.$$typeof) {
             case REACT_PROVIDER_TYPE:
-              fiberTag = 12;
+              fiberTag = 10;
               break a;
             case REACT_CONTEXT_TYPE:
-              fiberTag = 11;
+              fiberTag = 9;
               break a;
             case REACT_FORWARD_REF_TYPE:
-              fiberTag = 13;
+              fiberTag = 11;
               break a;
-            case REACT_PURE_TYPE:
-              fiberTag = 17;
+            case REACT_MEMO_TYPE:
+              fiberTag = 14;
+              break a;
+            case REACT_LAZY_TYPE:
+              fiberTag = 16;
+              owner = null;
               break a;
-            default:
-              if ("function" === typeof type.then) {
-                fiberTag = 4;
-                break a;
-              }
           }
         invariant(
           !1,
@@ -1881,24 +1912,33 @@ function createFiberFromElement(element, mode, expirationTime) {
           ""
         );
     }
-  mode = new FiberNode(fiberTag, element, key, mode);
-  mode.type = type;
-  mode.expirationTime = expirationTime;
-  return mode;
+  key = createFiber(fiberTag, pendingProps, key, mode);
+  key.elementType = type;
+  key.type = owner;
+  key.expirationTime = expirationTime;
+  return key;
 }
 function createFiberFromFragment(elements, mode, expirationTime, key) {
-  elements = new FiberNode(9, elements, key, mode);
+  elements = createFiber(7, elements, key, mode);
   elements.expirationTime = expirationTime;
   return elements;
 }
+function createFiberFromMode(pendingProps, mode, expirationTime, key) {
+  pendingProps = createFiber(8, pendingProps, key, mode);
+  mode = 0 === (mode & 1) ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
+  pendingProps.elementType = mode;
+  pendingProps.type = mode;
+  pendingProps.expirationTime = expirationTime;
+  return pendingProps;
+}
 function createFiberFromText(content, mode, expirationTime) {
-  content = new FiberNode(8, content, null, mode);
+  content = createFiber(6, content, null, mode);
   content.expirationTime = expirationTime;
   return content;
 }
 function createFiberFromPortal(portal, mode, expirationTime) {
-  mode = new FiberNode(
-    6,
+  mode = createFiber(
+    4,
     null !== portal.children ? portal.children : [],
     portal.key,
     mode
@@ -1916,9 +1956,9 @@ function markPendingPriorityLevel(root, expirationTime) {
   var earliestPendingTime = root.earliestPendingTime;
   0 === earliestPendingTime
     ? (root.earliestPendingTime = root.latestPendingTime = expirationTime)
-    : earliestPendingTime > expirationTime
+    : earliestPendingTime < expirationTime
       ? (root.earliestPendingTime = expirationTime)
-      : root.latestPendingTime < expirationTime &&
+      : root.latestPendingTime > expirationTime &&
         (root.latestPendingTime = expirationTime);
   findNextExpirationTimeToWorkOn(expirationTime, root);
 }
@@ -1933,19 +1973,19 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
   else {
     var latestPendingTime = root.latestPendingTime;
     0 !== latestPendingTime &&
-      (latestPendingTime < earliestRemainingTime
+      (latestPendingTime > earliestRemainingTime
         ? (root.earliestPendingTime = root.latestPendingTime = 0)
-        : root.earliestPendingTime < earliestRemainingTime &&
+        : root.earliestPendingTime > earliestRemainingTime &&
           (root.earliestPendingTime = root.latestPendingTime));
     latestPendingTime = root.earliestSuspendedTime;
     0 === latestPendingTime
       ? markPendingPriorityLevel(root, earliestRemainingTime)
-      : earliestRemainingTime > root.latestSuspendedTime
+      : earliestRemainingTime < root.latestSuspendedTime
         ? ((root.earliestSuspendedTime = 0),
           (root.latestSuspendedTime = 0),
           (root.latestPingedTime = 0),
           markPendingPriorityLevel(root, earliestRemainingTime))
-        : earliestRemainingTime < latestPendingTime &&
+        : earliestRemainingTime > latestPendingTime &&
           markPendingPriorityLevel(root, earliestRemainingTime);
   }
   findNextExpirationTimeToWorkOn(0, root);
@@ -1955,17 +1995,17 @@ function hasLowerPriorityWork(root, erroredExpirationTime) {
     latestSuspendedTime = root.latestSuspendedTime;
   root = root.latestPingedTime;
   return (
-    (0 !== latestPendingTime && latestPendingTime > erroredExpirationTime) ||
+    (0 !== latestPendingTime && latestPendingTime < erroredExpirationTime) ||
     (0 !== latestSuspendedTime &&
-      latestSuspendedTime > erroredExpirationTime) ||
-    (0 !== root && root > erroredExpirationTime)
+      latestSuspendedTime < erroredExpirationTime) ||
+    (0 !== root && root < erroredExpirationTime)
   );
 }
 function markSuspendedPriorityLevel(root, suspendedTime) {
   root.didError = !1;
   var latestPingedTime = root.latestPingedTime;
   0 !== latestPingedTime &&
-    latestPingedTime <= suspendedTime &&
+    latestPingedTime >= suspendedTime &&
     (root.latestPingedTime = 0);
   latestPingedTime = root.earliestPendingTime;
   var latestPendingTime = root.latestPendingTime;
@@ -1980,12 +2020,20 @@ function markSuspendedPriorityLevel(root, suspendedTime) {
   latestPendingTime = root.latestSuspendedTime;
   0 === latestPingedTime
     ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
-    : latestPingedTime > suspendedTime
+    : latestPingedTime < suspendedTime
       ? (root.earliestSuspendedTime = suspendedTime)
-      : latestPendingTime < suspendedTime &&
+      : latestPendingTime > suspendedTime &&
         (root.latestSuspendedTime = suspendedTime);
   findNextExpirationTimeToWorkOn(suspendedTime, root);
 }
+function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
+  var earliestPendingTime = root.earliestPendingTime;
+  root = root.earliestSuspendedTime;
+  earliestPendingTime > renderExpirationTime &&
+    (renderExpirationTime = earliestPendingTime);
+  root > renderExpirationTime && (renderExpirationTime = root);
+  return renderExpirationTime;
+}
 function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   var earliestSuspendedTime = root.earliestSuspendedTime,
     latestSuspendedTime = root.latestSuspendedTime,
@@ -1995,12 +2043,11 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
     0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
   0 === earliestPendingTime &&
     (0 === completedExpirationTime ||
-      latestSuspendedTime > completedExpirationTime) &&
+      latestSuspendedTime < completedExpirationTime) &&
     (earliestPendingTime = latestSuspendedTime);
   completedExpirationTime = earliestPendingTime;
   0 !== completedExpirationTime &&
-    0 !== earliestSuspendedTime &&
-    earliestSuspendedTime < completedExpirationTime &&
+    earliestSuspendedTime > completedExpirationTime &&
     (completedExpirationTime = earliestSuspendedTime);
   root.nextExpirationTimeToWorkOn = earliestPendingTime;
   root.expirationTime = completedExpirationTime;
@@ -2112,7 +2159,7 @@ function getStateFromUpdate(
           : workInProgress
       );
     case 3:
-      workInProgress.effectTag = (workInProgress.effectTag & -1025) | 64;
+      workInProgress.effectTag = (workInProgress.effectTag & -2049) | 64;
     case 0:
       workInProgress = update.payload;
       nextProps =
@@ -2145,58 +2192,52 @@ function processUpdateQueue(
 
   ) {
     var updateExpirationTime = update.expirationTime;
-    if (updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === newFirstUpdate &&
+    updateExpirationTime < renderExpirationTime
+      ? (null === newFirstUpdate &&
           ((newFirstUpdate = update), (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > updateExpirationTime)
-      )
-        newExpirationTime = updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < updateExpirationTime &&
+          (newExpirationTime = updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastEffect
             ? (queue.firstEffect = queue.lastEffect = update)
             : ((queue.lastEffect.nextEffect = update),
-              (queue.lastEffect = update)));
+              (queue.lastEffect = update))));
     update = update.next;
   }
   updateExpirationTime = null;
   for (update = queue.firstCapturedUpdate; null !== update; ) {
     var _updateExpirationTime = update.expirationTime;
-    if (_updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === updateExpirationTime &&
+    _updateExpirationTime < renderExpirationTime
+      ? (null === updateExpirationTime &&
           ((updateExpirationTime = update),
           null === newFirstUpdate && (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > _updateExpirationTime)
-      )
-        newExpirationTime = _updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < _updateExpirationTime &&
+          (newExpirationTime = _updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastCapturedEffect
             ? (queue.firstCapturedEffect = queue.lastCapturedEffect = update)
             : ((queue.lastCapturedEffect.nextEffect = update),
-              (queue.lastCapturedEffect = update)));
+              (queue.lastCapturedEffect = update))));
     update = update.next;
   }
   null === newFirstUpdate && (queue.lastUpdate = null);
@@ -2277,13 +2318,277 @@ function readContext(context, observedBits) {
     null === lastContextDependency
       ? (invariant(
           null !== currentlyRenderingFiber,
-          "Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
+          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
         ),
         (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
       : (lastContextDependency = lastContextDependency.next = observedBits);
   }
   return context._currentValue2;
 }
+function areHookInputsEqual(arr1, arr2) {
+  for (var i = 0; i < arr1.length; i++) {
+    var val1 = arr1[i],
+      val2 = arr2[i];
+    if (
+      (val1 !== val2 || (0 === val1 && 1 / val1 !== 1 / val2)) &&
+      (val1 === val1 || val2 === val2)
+    )
+      return !1;
+  }
+  return !0;
+}
+var renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  isReRender = !1,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = 0;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function finishHooks(Component, props, children, refOrContext) {
+  for (; didScheduleRenderPhaseUpdate; )
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (children = Component(props, refOrContext));
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return children;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.memoizedState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((isReRender = !1),
+        (currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((isReRender = !0),
+        (currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    isReRender = !1;
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (isReRender = !0),
+      (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (isReRender) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do
+            (initialAction = reducer(
+              initialAction,
+              firstRenderPhaseUpdate.action
+            )),
+              (firstRenderPhaseUpdate = firstRenderPhaseUpdate.next);
+          while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      initialAction = workInProgressHook.baseState;
+      var newBaseUpdate = (firstRenderPhaseUpdate = null),
+        _update = initialState,
+        didSkip = !1;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (newBaseUpdate = _baseUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : (initialAction = reducer(initialAction, _update.action));
+        _baseUpdate = _update;
+        _update = _update.next;
+      } while (null !== _update && _update !== initialState);
+      didSkip ||
+        ((newBaseUpdate = _baseUpdate),
+        (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = { last: null, dispatch: null };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, inputs) {
+  tag = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    inputs: inputs,
+    next: null
+  };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  inputs = void 0 !== inputs && null !== inputs ? inputs : [create];
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (areHookInputsEqual(inputs, prevEffect.inputs)) {
+      pushEffect(0, create, destroy, inputs);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    inputs
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (alternate = renderPhaseUpdates.get(queue)),
+      void 0 === alternate)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = alternate; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    alternate = requestCurrentTime();
+    alternate = computeExpirationForFiber(alternate, fiber);
+    action = { expirationTime: alternate, action: action, next: null };
+    flushPassiveEffects();
+    var _last2 = queue.last;
+    if (null === _last2) action.next = action;
+    else {
+      var first = _last2.next;
+      null !== first && (action.next = first);
+      _last2.next = action;
+    }
+    queue.last = action;
+    scheduleWork(fiber, alternate);
+  }
+}
 var NO_CONTEXT = {},
   contextStackCursor$1 = { current: NO_CONTEXT },
   contextFiberStackCursor = { current: NO_CONTEXT },
@@ -2363,7 +2668,47 @@ function shallowEqual(objA, objB) {
       return !1;
   return !0;
 }
-var emptyRefsObject = new React.Component().refs;
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    baseProps = Object.assign({}, baseProps);
+    Component = Component.defaultProps;
+    for (var propName in Component)
+      void 0 === baseProps[propName] &&
+        (baseProps[propName] = Component[propName]);
+  }
+  return baseProps;
+}
+function readLazyComponentType(lazyComponent) {
+  var result = lazyComponent._result;
+  switch (lazyComponent._status) {
+    case 1:
+      return result;
+    case 2:
+      throw result;
+    case 0:
+      throw result;
+    default:
+      throw ((lazyComponent._status = 0),
+      (result = lazyComponent._ctor),
+      (result = result()),
+      result.then(
+        function(moduleObject) {
+          0 === lazyComponent._status &&
+            ((moduleObject = moduleObject.default),
+            (lazyComponent._status = 1),
+            (lazyComponent._result = moduleObject));
+        },
+        function(error) {
+          0 === lazyComponent._status &&
+            ((lazyComponent._status = 2), (lazyComponent._result = error));
+        }
+      ),
+      (lazyComponent._result = result),
+      result);
+  }
+}
+var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
+  emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2395,6 +2740,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2406,6 +2752,7 @@ var classComponentUpdater = {
     update.tag = 1;
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2416,6 +2763,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.tag = 2;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   }
@@ -2436,6 +2784,32 @@ function checkShouldComponentUpdate(
       ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
       : !0;
 }
+function constructClassInstance(workInProgress, ctor, props) {
+  var isLegacyContextConsumer = !1,
+    unmaskedContext = emptyContextObject;
+  var context = ctor.contextType;
+  "object" === typeof context && null !== context
+    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    : ((unmaskedContext = isContextProvider(ctor)
+        ? previousContext
+        : contextStackCursor.current),
+      (isLegacyContextConsumer = ctor.contextTypes),
+      (context = (isLegacyContextConsumer =
+        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
+        ? getMaskedContext(workInProgress, unmaskedContext)
+        : emptyContextObject));
+  ctor = new ctor(props, context);
+  workInProgress.memoizedState =
+    null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
+  ctor.updater = classComponentUpdater;
+  workInProgress.stateNode = ctor;
+  ctor._reactInternalFiber = workInProgress;
+  isLegacyContextConsumer &&
+    ((workInProgress = workInProgress.stateNode),
+    (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
+    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
+  return ctor;
+}
 function callComponentWillReceiveProps(
   workInProgress,
   instance,
@@ -2462,7 +2836,9 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = contextType.unstable_read())
+    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
+        contextType
+      ))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2517,10 +2893,7 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(
-          2 === element.tag || 3 === element.tag,
-          "Function components cannot have refs."
-        ),
+        (invariant(1 === element.tag, "Function components cannot have refs."),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -2625,7 +2998,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     textContent,
     expirationTime
   ) {
-    if (null === current$$1 || 8 !== current$$1.tag)
+    if (null === current$$1 || 6 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromText(
           textContent,
@@ -2640,15 +3013,18 @@ function ChildReconciler(shouldTrackSideEffects) {
     return current$$1;
   }
   function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (null !== current$$1 && current$$1.type === element.type)
+    if (null !== current$$1 && current$$1.elementType === element.type)
       return (
         (expirationTime = useFiber(current$$1, element.props, expirationTime)),
         (expirationTime.ref = coerceRef(returnFiber, current$$1, element)),
         (expirationTime.return = returnFiber),
         expirationTime
       );
-    expirationTime = createFiberFromElement(
-      element,
+    expirationTime = createFiberFromTypeAndProps(
+      element.type,
+      element.key,
+      element.props,
+      null,
       returnFiber.mode,
       expirationTime
     );
@@ -2659,7 +3035,7 @@ function ChildReconciler(shouldTrackSideEffects) {
   function updatePortal(returnFiber, current$$1, portal, expirationTime) {
     if (
       null === current$$1 ||
-      6 !== current$$1.tag ||
+      4 !== current$$1.tag ||
       current$$1.stateNode.containerInfo !== portal.containerInfo ||
       current$$1.stateNode.implementation !== portal.implementation
     )
@@ -2683,7 +3059,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     expirationTime,
     key
   ) {
-    if (null === current$$1 || 9 !== current$$1.tag)
+    if (null === current$$1 || 7 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromFragment(
           fragment,
@@ -2713,8 +3089,11 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
           return (
-            (expirationTime = createFiberFromElement(
-              newChild,
+            (expirationTime = createFiberFromTypeAndProps(
+              newChild.type,
+              newChild.key,
+              newChild.props,
+              null,
               returnFiber.mode,
               expirationTime
             )),
@@ -3058,9 +3437,9 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (isUnkeyedTopLevelFragment.key === isObject)
                 if (
-                  9 === isUnkeyedTopLevelFragment.tag
+                  7 === isUnkeyedTopLevelFragment.tag
                     ? newChild.type === REACT_FRAGMENT_TYPE
-                    : isUnkeyedTopLevelFragment.type === newChild.type
+                    : isUnkeyedTopLevelFragment.elementType === newChild.type
                 ) {
                   deleteRemainingChildren(
                     returnFiber,
@@ -3100,8 +3479,11 @@ function ChildReconciler(shouldTrackSideEffects) {
                 )),
                 (currentFirstChild.return = returnFiber),
                 (returnFiber = currentFirstChild))
-              : ((expirationTime = createFiberFromElement(
-                  newChild,
+              : ((expirationTime = createFiberFromTypeAndProps(
+                  newChild.type,
+                  newChild.key,
+                  newChild.props,
+                  null,
                   returnFiber.mode,
                   expirationTime
                 )),
@@ -3123,7 +3505,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (currentFirstChild.key === isUnkeyedTopLevelFragment)
                 if (
-                  6 === currentFirstChild.tag &&
+                  4 === currentFirstChild.tag &&
                   currentFirstChild.stateNode.containerInfo ===
                     newChild.containerInfo &&
                   currentFirstChild.stateNode.implementation ===
@@ -3161,7 +3543,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (newChild = "" + newChild),
-        null !== currentFirstChild && 8 === currentFirstChild.tag
+        null !== currentFirstChild && 6 === currentFirstChild.tag
           ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
             (currentFirstChild = useFiber(
               currentFirstChild,
@@ -3197,8 +3579,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     isObject && throwOnInvalidObjectType(returnFiber, newChild);
     if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
       switch (returnFiber.tag) {
-        case 2:
-        case 3:
+        case 1:
         case 0:
           (expirationTime = returnFiber.type),
             invariant(
@@ -3217,12 +3598,12 @@ var reconcileChildFibers = ChildReconciler(!0),
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
   switch (fiber.tag) {
-    case 7:
+    case 5:
       return (
         (nextInstance = shim$1(nextInstance, fiber.type, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
       );
-    case 8:
+    case 6:
       return (
         (nextInstance = shim$1(nextInstance, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
@@ -3245,7 +3626,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
           return;
         }
         var returnFiber = hydrationParentFiber,
-          fiber = new FiberNode(7, null, null, 0);
+          fiber = createFiber(5, null, null, 0);
+        fiber.elementType = "DELETED";
         fiber.type = "DELETED";
         fiber.stateNode = firstAttemptedInstance;
         fiber.return = returnFiber;
@@ -3263,38 +3645,6 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-function readLazyComponentType(thenable) {
-  switch (thenable._reactStatus) {
-    case 1:
-      return thenable._reactResult;
-    case 2:
-      throw thenable._reactResult;
-    case 0:
-      throw thenable;
-    default:
-      throw ((thenable._reactStatus = 0),
-      thenable.then(
-        function(resolvedValue) {
-          if (0 === thenable._reactStatus) {
-            thenable._reactStatus = 1;
-            if ("object" === typeof resolvedValue && null !== resolvedValue) {
-              var defaultExport = resolvedValue.default;
-              resolvedValue =
-                void 0 !== defaultExport && null !== defaultExport
-                  ? defaultExport
-                  : resolvedValue;
-            }
-            thenable._reactResult = resolvedValue;
-          }
-        },
-        function(error) {
-          0 === thenable._reactStatus &&
-            ((thenable._reactStatus = 2), (thenable._reactResult = error));
-        }
-      ),
-      thenable);
-  }
-}
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 function reconcileChildren(
   current$$1,
@@ -3320,28 +3670,28 @@ function reconcileChildren(
 function updateForwardRef(
   current$$1,
   workInProgress,
-  type,
+  Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
-  type = type.render;
+  Component = Component.render;
   var ref = workInProgress.ref;
-  if (
-    !didPerformWorkStackCursor.current &&
-    workInProgress.memoizedProps === nextProps &&
-    ref === (null !== current$$1 ? current$$1.ref : null)
-  )
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  type = type(nextProps, ref);
-  reconcileChildren(current$$1, workInProgress, type, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, ref);
+  nextChildren = finishHooks(Component, nextProps, nextChildren, ref);
+  workInProgress.effectTag |= 1;
+  reconcileChildren(
+    current$$1,
+    workInProgress,
+    nextChildren,
+    renderExpirationTime$jscomp$0
+  );
   return workInProgress.child;
 }
-function updatePureComponent(
+function updateMemoComponent(
   current$$1,
   workInProgress,
   Component,
@@ -3349,27 +3699,82 @@ function updatePureComponent(
   updateExpirationTime,
   renderExpirationTime
 ) {
-  var render = Component.render;
+  if (null === current$$1) {
+    var type = Component.type;
+    if (
+      "function" === typeof type &&
+      !shouldConstruct(type) &&
+      void 0 === type.defaultProps &&
+      null === Component.compare
+    )
+      return (
+        (workInProgress.tag = 15),
+        (workInProgress.type = type),
+        updateSimpleMemoComponent(
+          current$$1,
+          workInProgress,
+          type,
+          nextProps,
+          updateExpirationTime,
+          renderExpirationTime
+        )
+      );
+    current$$1 = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      null,
+      workInProgress.mode,
+      renderExpirationTime
+    );
+    current$$1.ref = workInProgress.ref;
+    current$$1.return = workInProgress;
+    return (workInProgress.child = current$$1);
+  }
+  type = current$$1.child;
   if (
-    null !== current$$1 &&
-    (0 === updateExpirationTime ||
-      updateExpirationTime > renderExpirationTime) &&
-    ((updateExpirationTime = current$$1.memoizedProps),
+    updateExpirationTime < renderExpirationTime &&
+    ((updateExpirationTime = type.memoizedProps),
     (Component = Component.compare),
     (Component = null !== Component ? Component : shallowEqual),
-    Component(updateExpirationTime, nextProps))
+    Component(updateExpirationTime, nextProps) &&
+      current$$1.ref === workInProgress.ref)
   )
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
       renderExpirationTime
     );
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  render = render(nextProps);
   workInProgress.effectTag |= 1;
-  reconcileChildren(current$$1, workInProgress, render, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
-  return workInProgress.child;
+  current$$1 = createWorkInProgress(type, nextProps, renderExpirationTime);
+  current$$1.ref = workInProgress.ref;
+  current$$1.return = workInProgress;
+  return (workInProgress.child = current$$1);
+}
+function updateSimpleMemoComponent(
+  current$$1,
+  workInProgress,
+  Component,
+  nextProps,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  return null !== current$$1 &&
+    updateExpirationTime < renderExpirationTime &&
+    shallowEqual(current$$1.memoizedProps, nextProps) &&
+    current$$1.ref === workInProgress.ref
+    ? bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    : updateFunctionComponent(
+        current$$1,
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      );
 }
 function markRef(current$$1, workInProgress) {
   var ref = workInProgress.ref;
@@ -3384,22 +3789,30 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
   var unmaskedContext = isContextProvider(Component)
     ? previousContext
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, unmaskedContext);
+  nextChildren = finishHooks(
+    Component,
+    nextProps,
+    nextChildren,
+    unmaskedContext
+  );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
     workInProgress,
-    Component,
-    renderExpirationTime
+    nextChildren,
+    renderExpirationTime$jscomp$0
   );
-  workInProgress.memoizedProps = nextProps;
   return workInProgress.child;
 }
 function updateClassComponent(
@@ -3414,82 +3827,153 @@ function updateClassComponent(
     pushContextProvider(workInProgress);
   } else hasContext = !1;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  if (null === current$$1)
-    if (null === workInProgress.stateNode) {
-      var isLegacyContextConsumer = !1,
-        unmaskedContext = emptyContextObject;
-      var context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((unmaskedContext = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (isLegacyContextConsumer = Component.contextTypes),
-          (context = (isLegacyContextConsumer =
-            null !== isLegacyContextConsumer &&
-            void 0 !== isLegacyContextConsumer)
-            ? getMaskedContext(workInProgress, unmaskedContext)
-            : emptyContextObject));
-      var instance = new Component(nextProps, context);
-      workInProgress.memoizedState =
-        null !== instance.state && void 0 !== instance.state
-          ? instance.state
-          : null;
-      instance.updater = classComponentUpdater;
-      workInProgress.stateNode = instance;
-      instance._reactInternalFiber = workInProgress;
-      isLegacyContextConsumer &&
-        ((isLegacyContextConsumer = workInProgress.stateNode),
-        (isLegacyContextConsumer.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
-        (isLegacyContextConsumer.__reactInternalMemoizedMaskedChildContext = context));
+  if (null === workInProgress.stateNode)
+    null !== current$$1 &&
+      ((current$$1.alternate = null),
+      (workInProgress.alternate = null),
+      (workInProgress.effectTag |= 2)),
+      constructClassInstance(
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      ),
       mountClassInstance(
         workInProgress,
         Component,
         nextProps,
         renderExpirationTime
-      );
-      nextProps = !0;
-    } else {
-      unmaskedContext = workInProgress.stateNode;
-      isLegacyContextConsumer = workInProgress.memoizedProps;
-      unmaskedContext.props = isLegacyContextConsumer;
-      var oldContext = unmaskedContext.context;
-      context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
+      ),
+      (nextProps = !0);
+  else if (null === current$$1) {
+    var instance = workInProgress.stateNode,
+      oldProps = workInProgress.memoizedProps;
+    instance.props = oldProps;
+    var oldContext = instance.context,
+      contextType = Component.contextType;
+    "object" === typeof contextType && null !== contextType
+      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+          contextType
+        ))
+      : ((contextType = isContextProvider(Component)
+          ? previousContext
+          : contextStackCursor.current),
+        (contextType = getMaskedContext(workInProgress, contextType)));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
+      hasNewLifecycles =
+        "function" === typeof getDerivedStateFromProps ||
+        "function" === typeof instance.getSnapshotBeforeUpdate;
+    hasNewLifecycles ||
+      ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof instance.componentWillReceiveProps) ||
+      ((oldProps !== nextProps || oldContext !== contextType) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          instance,
+          nextProps,
+          contextType
+        ));
+    hasForceUpdate = !1;
+    var oldState = workInProgress.memoizedState;
+    oldContext = instance.state = oldState;
+    var updateQueue = workInProgress.updateQueue;
+    null !== updateQueue &&
+      (processUpdateQueue(
+        workInProgress,
+        updateQueue,
+        nextProps,
+        instance,
+        renderExpirationTime
+      ),
+      (oldContext = workInProgress.memoizedState));
+    oldProps !== nextProps ||
+    oldState !== oldContext ||
+    didPerformWorkStackCursor.current ||
+    hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps,
+            nextProps
+          ),
+          (oldContext = workInProgress.memoizedState)),
+        (oldProps =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
+            workInProgress,
+            Component,
+            oldProps,
+            nextProps,
+            oldState,
+            oldContext,
+            contextType
+          ))
+          ? (hasNewLifecycles ||
+              ("function" !== typeof instance.UNSAFE_componentWillMount &&
+                "function" !== typeof instance.componentWillMount) ||
+              ("function" === typeof instance.componentWillMount &&
+                instance.componentWillMount(),
+              "function" === typeof instance.UNSAFE_componentWillMount &&
+                instance.UNSAFE_componentWillMount()),
+            "function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4))
+          : ("function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = oldContext)),
+        (instance.props = nextProps),
+        (instance.state = oldContext),
+        (instance.context = contextType),
+        (nextProps = oldProps))
+      : ("function" === typeof instance.componentDidMount &&
+          (workInProgress.effectTag |= 4),
+        (nextProps = !1));
+  } else
+    (instance = workInProgress.stateNode),
+      (oldProps = workInProgress.memoizedProps),
+      (instance.props =
+        workInProgress.type === workInProgress.elementType
+          ? oldProps
+          : resolveDefaultProps(workInProgress.type, oldProps)),
+      (oldContext = instance.context),
+      (contextType = Component.contextType),
+      "object" === typeof contextType && null !== contextType
+        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+            contextType
+          ))
+        : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context)));
-      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
-      (instance =
+          (contextType = getMaskedContext(workInProgress, contextType))),
+      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
+      (hasNewLifecycles =
         "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
+        "function" === typeof instance.getSnapshotBeforeUpdate) ||
+        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+          "function" !== typeof instance.componentWillReceiveProps) ||
+        ((oldProps !== nextProps || oldContext !== contextType) &&
           callComponentWillReceiveProps(
             workInProgress,
-            unmaskedContext,
+            instance,
             nextProps,
-            context
-          ));
-      hasForceUpdate = !1;
-      var oldState = workInProgress.memoizedState;
-      oldContext = unmaskedContext.state = oldState;
-      var updateQueue = workInProgress.updateQueue;
+            contextType
+          )),
+      (hasForceUpdate = !1),
+      (oldContext = workInProgress.memoizedState),
+      (oldState = instance.state = oldContext),
+      (updateQueue = workInProgress.updateQueue),
       null !== updateQueue &&
         (processUpdateQueue(
           workInProgress,
           updateQueue,
           nextProps,
-          unmaskedContext,
+          instance,
           renderExpirationTime
         ),
-        (oldContext = workInProgress.memoizedState));
-      isLegacyContextConsumer !== nextProps ||
-      oldState !== oldContext ||
+        (oldState = workInProgress.memoizedState)),
+      oldProps !== nextProps ||
+      oldContext !== oldState ||
       didPerformWorkStackCursor.current ||
       hasForceUpdate
         ? ("function" === typeof getDerivedStateFromProps &&
@@ -3499,144 +3983,57 @@ function updateClassComponent(
               getDerivedStateFromProps,
               nextProps
             ),
-            (oldContext = workInProgress.memoizedState)),
-          (isLegacyContextConsumer =
+            (oldState = workInProgress.memoizedState)),
+          (getDerivedStateFromProps =
             hasForceUpdate ||
             checkShouldComponentUpdate(
               workInProgress,
               Component,
-              isLegacyContextConsumer,
+              oldProps,
               nextProps,
-              oldState,
               oldContext,
-              context
+              oldState,
+              contextType
             ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  "function" !== typeof unmaskedContext.componentWillMount) ||
-                ("function" === typeof unmaskedContext.componentWillMount &&
-                  unmaskedContext.componentWillMount(),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  unmaskedContext.UNSAFE_componentWillMount()),
-              "function" === typeof unmaskedContext.componentDidMount &&
-                (workInProgress.effectTag |= 4))
-            : ("function" === typeof unmaskedContext.componentDidMount &&
-                (workInProgress.effectTag |= 4),
-              (workInProgress.memoizedProps = nextProps),
-              (workInProgress.memoizedState = oldContext)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldContext),
-          (unmaskedContext.context = context),
-          (nextProps = isLegacyContextConsumer))
-        : ("function" === typeof unmaskedContext.componentDidMount &&
-            (workInProgress.effectTag |= 4),
-          (nextProps = !1));
-    }
-  else
-    (unmaskedContext = workInProgress.stateNode),
-      (isLegacyContextConsumer = workInProgress.memoizedProps),
-      (unmaskedContext.props = isLegacyContextConsumer),
-      (oldContext = unmaskedContext.context),
-      (context = Component.contextType),
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context))),
-      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
-      (instance =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
-          callComponentWillReceiveProps(
-            workInProgress,
-            unmaskedContext,
-            nextProps,
-            context
-          )),
-      (hasForceUpdate = !1),
-      (oldContext = workInProgress.memoizedState),
-      (oldState = unmaskedContext.state = oldContext),
-      (updateQueue = workInProgress.updateQueue),
-      null !== updateQueue &&
-        (processUpdateQueue(
-          workInProgress,
-          updateQueue,
-          nextProps,
-          unmaskedContext,
-          renderExpirationTime
-        ),
-        (oldState = workInProgress.memoizedState)),
-      isLegacyContextConsumer !== nextProps ||
-      oldContext !== oldState ||
-      didPerformWorkStackCursor.current ||
-      hasForceUpdate
-        ? ("function" === typeof getDerivedStateFromProps &&
-            (applyDerivedStateFromProps(
-              workInProgress,
-              Component,
-              getDerivedStateFromProps,
-              nextProps
-            ),
-            (oldState = workInProgress.memoizedState)),
-          (getDerivedStateFromProps =
-            hasForceUpdate ||
-            checkShouldComponentUpdate(
-              workInProgress,
-              Component,
-              isLegacyContextConsumer,
-              nextProps,
-              oldContext,
-              oldState,
-              context
-            ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  "function" !== typeof unmaskedContext.componentWillUpdate) ||
-                ("function" === typeof unmaskedContext.componentWillUpdate &&
-                  unmaskedContext.componentWillUpdate(
+            ? (hasNewLifecycles ||
+                ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
+                  "function" !== typeof instance.componentWillUpdate) ||
+                ("function" === typeof instance.componentWillUpdate &&
+                  instance.componentWillUpdate(
                     nextProps,
                     oldState,
-                    context
+                    contextType
                   ),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  unmaskedContext.UNSAFE_componentWillUpdate(
+                "function" === typeof instance.UNSAFE_componentWillUpdate &&
+                  instance.UNSAFE_componentWillUpdate(
                     nextProps,
                     oldState,
-                    context
+                    contextType
                   )),
-              "function" === typeof unmaskedContext.componentDidUpdate &&
+              "function" === typeof instance.componentDidUpdate &&
                 (workInProgress.effectTag |= 4),
-              "function" === typeof unmaskedContext.getSnapshotBeforeUpdate &&
+              "function" === typeof instance.getSnapshotBeforeUpdate &&
                 (workInProgress.effectTag |= 256))
-            : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
+            : ("function" !== typeof instance.componentDidUpdate ||
+                (oldProps === current$$1.memoizedProps &&
                   oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 4),
-              "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
+              "function" !== typeof instance.getSnapshotBeforeUpdate ||
+                (oldProps === current$$1.memoizedProps &&
                   oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 256),
               (workInProgress.memoizedProps = nextProps),
               (workInProgress.memoizedState = oldState)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldState),
-          (unmaskedContext.context = context),
+          (instance.props = nextProps),
+          (instance.state = oldState),
+          (instance.context = contextType),
           (nextProps = getDerivedStateFromProps))
-        : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+        : ("function" !== typeof instance.componentDidUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 4),
-          "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+          "function" !== typeof instance.getSnapshotBeforeUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 256),
           (nextProps = !1));
@@ -3699,7 +4096,6 @@ function finishClassComponent(
         renderExpirationTime
       );
   workInProgress.memoizedState = shouldUpdate.state;
-  workInProgress.memoizedProps = shouldUpdate.props;
   hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
@@ -3715,15 +4111,123 @@ function pushHostRootContext(workInProgress) {
       pushTopLevelContextObject(workInProgress, root.context, !1);
   pushHostContainer(workInProgress, root.containerInfo);
 }
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    baseProps = Object.assign({}, baseProps);
-    Component = Component.defaultProps;
-    for (var propName in Component)
-      void 0 === baseProps[propName] &&
-        (baseProps[propName] = Component[propName]);
-  }
-  return baseProps;
+function updateSuspenseComponent(
+  current$$1,
+  workInProgress,
+  renderExpirationTime
+) {
+  var mode = workInProgress.mode,
+    nextProps = workInProgress.pendingProps,
+    nextState = workInProgress.memoizedState;
+  if (0 === (workInProgress.effectTag & 64)) {
+    nextState = null;
+    var nextDidTimeout = !1;
+  } else
+    (nextState = { timedOutAt: null !== nextState ? nextState.timedOutAt : 0 }),
+      (nextDidTimeout = !0),
+      (workInProgress.effectTag &= -65);
+  if (null === current$$1)
+    nextDidTimeout
+      ? ((nextDidTimeout = nextProps.fallback),
+        (nextProps = createFiberFromFragment(null, mode, 0, null)),
+        0 === (workInProgress.mode & 1) &&
+          (nextProps.child =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child),
+        (renderExpirationTime = createFiberFromFragment(
+          nextDidTimeout,
+          mode,
+          renderExpirationTime,
+          null
+        )),
+        (nextProps.sibling = renderExpirationTime),
+        (mode = nextProps),
+        (mode.return = renderExpirationTime.return = workInProgress))
+      : (mode = renderExpirationTime = mountChildFibers(
+          workInProgress,
+          null,
+          nextProps.children,
+          renderExpirationTime
+        ));
+  else if (null !== current$$1.memoizedState)
+    if (
+      ((current$$1 = current$$1.child),
+      (mode = current$$1.sibling),
+      nextDidTimeout)
+    ) {
+      nextProps = nextProps.fallback;
+      renderExpirationTime = createWorkInProgress(
+        current$$1,
+        current$$1.pendingProps,
+        0
+      );
+      0 === (workInProgress.mode & 1) &&
+        ((nextDidTimeout =
+          null !== workInProgress.memoizedState
+            ? workInProgress.child.child
+            : workInProgress.child),
+        nextDidTimeout !== current$$1.child &&
+          (renderExpirationTime.child = nextDidTimeout));
+      if (workInProgress.mode & 4) {
+        nextDidTimeout = 0;
+        for (current$$1 = renderExpirationTime.child; null !== current$$1; )
+          (nextDidTimeout += current$$1.treeBaseDuration),
+            (current$$1 = current$$1.sibling);
+        renderExpirationTime.treeBaseDuration = nextDidTimeout;
+      }
+      nextProps = renderExpirationTime.sibling = createWorkInProgress(
+        mode,
+        nextProps,
+        mode.expirationTime
+      );
+      mode = renderExpirationTime;
+      renderExpirationTime.childExpirationTime = 0;
+      renderExpirationTime = nextProps;
+      mode.return = renderExpirationTime.return = workInProgress;
+    } else
+      mode = renderExpirationTime = reconcileChildFibers(
+        workInProgress,
+        current$$1.child,
+        nextProps.children,
+        renderExpirationTime
+      );
+  else if (((current$$1 = current$$1.child), nextDidTimeout)) {
+    nextDidTimeout = nextProps.fallback;
+    nextProps = createFiberFromFragment(null, mode, 0, null);
+    nextProps.child = current$$1;
+    0 === (workInProgress.mode & 1) &&
+      (nextProps.child =
+        null !== workInProgress.memoizedState
+          ? workInProgress.child.child
+          : workInProgress.child);
+    if (workInProgress.mode & 4) {
+      current$$1 = 0;
+      for (var _hiddenChild = nextProps.child; null !== _hiddenChild; )
+        (current$$1 += _hiddenChild.treeBaseDuration),
+          (_hiddenChild = _hiddenChild.sibling);
+      nextProps.treeBaseDuration = current$$1;
+    }
+    renderExpirationTime = nextProps.sibling = createFiberFromFragment(
+      nextDidTimeout,
+      mode,
+      renderExpirationTime,
+      null
+    );
+    renderExpirationTime.effectTag |= 2;
+    mode = nextProps;
+    nextProps.childExpirationTime = 0;
+    mode.return = renderExpirationTime.return = workInProgress;
+  } else
+    renderExpirationTime = mode = reconcileChildFibers(
+      workInProgress,
+      current$$1,
+      nextProps.children,
+      renderExpirationTime
+    );
+  workInProgress.memoizedState = nextState;
+  workInProgress.child = mode;
+  return renderExpirationTime;
 }
 function bailoutOnAlreadyFinishedWork(
   current$$1,
@@ -3733,9 +4237,7 @@ function bailoutOnAlreadyFinishedWork(
   null !== current$$1 &&
     (workInProgress.firstContextDependency = current$$1.firstContextDependency);
   profilerStartTime = -1;
-  var childExpirationTime = workInProgress.childExpirationTime;
-  if (0 === childExpirationTime || childExpirationTime > renderExpirationTime)
-    return null;
+  if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
     null === current$$1 || workInProgress.child === current$$1.child,
     "Resuming work not yet implemented."
@@ -3764,522 +4266,563 @@ function bailoutOnAlreadyFinishedWork(
   }
   return workInProgress.child;
 }
-function beginWork(current$$1, workInProgress, renderExpirationTime) {
+function beginWork(current$$1, workInProgress, renderExpirationTime$jscomp$0) {
   var updateExpirationTime = workInProgress.expirationTime;
   if (
     null !== current$$1 &&
     current$$1.memoizedProps === workInProgress.pendingProps &&
     !didPerformWorkStackCursor.current &&
-    (0 === updateExpirationTime || updateExpirationTime > renderExpirationTime)
+    updateExpirationTime < renderExpirationTime$jscomp$0
   ) {
     switch (workInProgress.tag) {
-      case 5:
+      case 3:
         pushHostRootContext(workInProgress);
         break;
-      case 7:
+      case 5:
         pushHostContext(workInProgress);
         break;
-      case 2:
+      case 1:
         isContextProvider(workInProgress.type) &&
           pushContextProvider(workInProgress);
         break;
-      case 3:
-        isContextProvider(workInProgress.type._reactResult) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 6:
+      case 4:
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         );
         break;
-      case 12:
+      case 10:
         pushProvider(workInProgress, workInProgress.memoizedProps.value);
         break;
-      case 15:
+      case 12:
         workInProgress.effectTag |= 4;
+        break;
+      case 13:
+        if (null !== workInProgress.memoizedState) {
+          updateExpirationTime = workInProgress.child.childExpirationTime;
+          if (
+            0 !== updateExpirationTime &&
+            updateExpirationTime >= renderExpirationTime$jscomp$0
+          )
+            return updateSuspenseComponent(
+              current$$1,
+              workInProgress,
+              renderExpirationTime$jscomp$0
+            );
+          workInProgress = bailoutOnAlreadyFinishedWork(
+            current$$1,
+            workInProgress,
+            renderExpirationTime$jscomp$0
+          );
+          return null !== workInProgress ? workInProgress.sibling : null;
+        }
     }
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
-      renderExpirationTime
+      renderExpirationTime$jscomp$0
     );
   }
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
-    case 4:
-      var Component = workInProgress.type;
-      invariant(
-        null === current$$1,
-        "An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue."
+    case 2:
+      updateExpirationTime = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      current$$1 = workInProgress.pendingProps;
+      var context = getMaskedContext(
+        workInProgress,
+        contextStackCursor.current
       );
-      var props = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+      renderExpirationTime = renderExpirationTime$jscomp$0;
+      currentlyRenderingFiber$1 = workInProgress;
+      firstCurrentHook = null;
+      var value = updateExpirationTime(current$$1, context);
+      workInProgress.effectTag |= 1;
       if (
-        "object" === typeof Component &&
-        null !== Component &&
-        "function" === typeof Component.then
+        "object" === typeof value &&
+        null !== value &&
+        "function" === typeof value.render &&
+        void 0 === value.$$typeof
       ) {
-        Component = readLazyComponentType(Component);
-        var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(
+        workInProgress.tag = 1;
+        resetHooks();
+        isContextProvider(updateExpirationTime)
+          ? ((context = !0), pushContextProvider(workInProgress))
+          : (context = !1);
+        workInProgress.memoizedState =
+          null !== value.state && void 0 !== value.state ? value.state : null;
+        var getDerivedStateFromProps =
+          updateExpirationTime.getDerivedStateFromProps;
+        "function" === typeof getDerivedStateFromProps &&
+          applyDerivedStateFromProps(
             workInProgress,
-            Component
-          )),
-          resolvedProps = resolveDefaultProps(Component, props),
-          child = void 0;
-        switch (resolvedTag) {
-          case 1:
-            child = updateFunctionComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 3:
-            child = updateClassComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 14:
-            child = updateForwardRef(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 18:
-            child = updatePureComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              updateExpirationTime,
-              renderExpirationTime
-            );
-            break;
-          default:
-            invariant(
-              !1,
-              "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
-              Component
-            );
-        }
-        workInProgress.memoizedProps = props;
-        workInProgress = child;
-      } else
-        (updateExpirationTime = getMaskedContext(
+            updateExpirationTime,
+            getDerivedStateFromProps,
+            current$$1
+          );
+        value.updater = classComponentUpdater;
+        workInProgress.stateNode = value;
+        value._reactInternalFiber = workInProgress;
+        mountClassInstance(
           workInProgress,
-          contextStackCursor.current
-        )),
-          prepareToReadContext(workInProgress, renderExpirationTime),
-          (updateExpirationTime = Component(props, updateExpirationTime)),
-          (workInProgress.effectTag |= 1),
-          "object" === typeof updateExpirationTime &&
-          null !== updateExpirationTime &&
-          "function" === typeof updateExpirationTime.render &&
-          void 0 === updateExpirationTime.$$typeof
-            ? ((workInProgress.tag = 2),
-              isContextProvider(Component)
-                ? ((resolvedTag = !0), pushContextProvider(workInProgress))
-                : (resolvedTag = !1),
-              (workInProgress.memoizedState =
-                null !== updateExpirationTime.state &&
-                void 0 !== updateExpirationTime.state
-                  ? updateExpirationTime.state
-                  : null),
-              (resolvedProps = Component.getDerivedStateFromProps),
-              "function" === typeof resolvedProps &&
-                applyDerivedStateFromProps(
-                  workInProgress,
-                  Component,
-                  resolvedProps,
-                  props
-                ),
-              (updateExpirationTime.updater = classComponentUpdater),
-              (workInProgress.stateNode = updateExpirationTime),
-              (updateExpirationTime._reactInternalFiber = workInProgress),
-              mountClassInstance(
-                workInProgress,
-                Component,
-                props,
-                renderExpirationTime
-              ),
-              (workInProgress = finishClassComponent(
-                current$$1,
-                workInProgress,
-                Component,
-                !0,
-                resolvedTag,
-                renderExpirationTime
-              )))
-            : ((workInProgress.tag = 0),
-              reconcileChildren(
-                current$$1,
-                workInProgress,
-                updateExpirationTime,
-                renderExpirationTime
-              ),
-              (workInProgress.memoizedProps = props),
-              (workInProgress = workInProgress.child));
+          updateExpirationTime,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        );
+        workInProgress = finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          context,
+          renderExpirationTime$jscomp$0
+        );
+      } else
+        (workInProgress.tag = 0),
+          (value = finishHooks(
+            updateExpirationTime,
+            current$$1,
+            value,
+            context
+          )),
+          reconcileChildren(
+            null,
+            workInProgress,
+            value,
+            renderExpirationTime$jscomp$0
+          ),
+          (workInProgress = workInProgress.child);
       return workInProgress;
+    case 16:
+      value = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      context = workInProgress.pendingProps;
+      current$$1 = readLazyComponentType(value);
+      workInProgress.type = current$$1;
+      value = workInProgress.tag = resolveLazyComponentTag(current$$1);
+      context = resolveDefaultProps(current$$1, context);
+      getDerivedStateFromProps = void 0;
+      switch (value) {
+        case 0:
+          getDerivedStateFromProps = updateFunctionComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 1:
+          getDerivedStateFromProps = updateClassComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 11:
+          getDerivedStateFromProps = updateForwardRef(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 14:
+          getDerivedStateFromProps = updateMemoComponent(
+            null,
+            workInProgress,
+            current$$1,
+            resolveDefaultProps(current$$1.type, context),
+            updateExpirationTime,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        default:
+          invariant(
+            !1,
+            "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
+            current$$1
+          );
+      }
+      return getDerivedStateFromProps;
     case 0:
-      return updateFunctionComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateFunctionComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateFunctionComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
-      );
-    case 2:
-      return updateClassComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 3:
+    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateClassComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateClassComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 5:
+    case 3:
       return (
         pushHostRootContext(workInProgress),
-        (Component = workInProgress.updateQueue),
+        (updateExpirationTime = workInProgress.updateQueue),
         invariant(
-          null !== Component,
+          null !== updateExpirationTime,
           "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
         ),
-        (props = workInProgress.memoizedState),
-        (props = null !== props ? props.element : null),
+        (value = workInProgress.memoizedState),
+        (value = null !== value ? value.element : null),
         processUpdateQueue(
           workInProgress,
-          Component,
+          updateExpirationTime,
           workInProgress.pendingProps,
           null,
-          renderExpirationTime
+          renderExpirationTime$jscomp$0
         ),
-        (Component = workInProgress.memoizedState.element),
-        Component === props
+        (updateExpirationTime = workInProgress.memoizedState.element),
+        updateExpirationTime === value
           ? (workInProgress = bailoutOnAlreadyFinishedWork(
               current$$1,
               workInProgress,
-              renderExpirationTime
+              renderExpirationTime$jscomp$0
             ))
           : (reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
             (workInProgress = workInProgress.child)),
         workInProgress
       );
-    case 7:
+    case 5:
       return (
         pushHostContext(workInProgress),
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
+        (updateExpirationTime = workInProgress.pendingProps.children),
         markRef(current$$1, workInProgress),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         (workInProgress = workInProgress.child),
         workInProgress
       );
-    case 8:
+    case 6:
       return (
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (workInProgress.memoizedProps = workInProgress.pendingProps),
         null
       );
-    case 16:
-      return null;
-    case 6:
+    case 13:
+      return updateSuspenseComponent(
+        current$$1,
+        workInProgress,
+        renderExpirationTime$jscomp$0
+      );
+    case 4:
       return (
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         ),
-        (Component = workInProgress.pendingProps),
+        (updateExpirationTime = workInProgress.pendingProps),
         null === current$$1
           ? (workInProgress.child = reconcileChildFibers(
               workInProgress,
               null,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ))
           : reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 13:
-      return updateForwardRef(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 14:
+    case 11:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateForwardRef(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateForwardRef(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 9:
+    case 7:
       return (
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 10:
+    case 8:
       return (
-        (Component = workInProgress.pendingProps.children),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 15:
+    case 12:
       return (
         (workInProgress.effectTag |= 4),
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component.children,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 12:
+    case 10:
       a: {
-        Component = workInProgress.type._context;
-        props = workInProgress.pendingProps;
-        resolvedTag = workInProgress.memoizedProps;
-        updateExpirationTime = props.value;
-        workInProgress.memoizedProps = props;
-        pushProvider(workInProgress, updateExpirationTime);
-        if (null !== resolvedTag)
-          if (
-            ((resolvedProps = resolvedTag.value),
-            (updateExpirationTime =
-              (resolvedProps === updateExpirationTime &&
-                (0 !== resolvedProps ||
-                  1 / resolvedProps === 1 / updateExpirationTime)) ||
-              (resolvedProps !== resolvedProps &&
-                updateExpirationTime !== updateExpirationTime)
-                ? 0
-                : ("function" === typeof Component._calculateChangedBits
-                    ? Component._calculateChangedBits(
-                        resolvedProps,
-                        updateExpirationTime
-                      )
-                    : 1073741823) | 0),
-            0 === updateExpirationTime)
-          ) {
+        updateExpirationTime = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        getDerivedStateFromProps = workInProgress.memoizedProps;
+        context = value.value;
+        pushProvider(workInProgress, context);
+        if (null !== getDerivedStateFromProps) {
+          var oldValue = getDerivedStateFromProps.value;
+          context =
+            (oldValue === context &&
+              (0 !== oldValue || 1 / oldValue === 1 / context)) ||
+            (oldValue !== oldValue && context !== context)
+              ? 0
+              : ("function" ===
+                typeof updateExpirationTime._calculateChangedBits
+                  ? updateExpirationTime._calculateChangedBits(
+                      oldValue,
+                      context
+                    )
+                  : 1073741823) | 0;
+          if (0 === context) {
             if (
-              resolvedTag.children === props.children &&
+              getDerivedStateFromProps.children === value.children &&
               !didPerformWorkStackCursor.current
             ) {
               workInProgress = bailoutOnAlreadyFinishedWork(
                 current$$1,
                 workInProgress,
-                renderExpirationTime
+                renderExpirationTime$jscomp$0
               );
               break a;
             }
           } else
             for (
-              resolvedTag = workInProgress.child,
-                null !== resolvedTag && (resolvedTag.return = workInProgress);
-              null !== resolvedTag;
+              getDerivedStateFromProps = workInProgress.child,
+                null !== getDerivedStateFromProps &&
+                  (getDerivedStateFromProps.return = workInProgress);
+              null !== getDerivedStateFromProps;
 
             ) {
-              resolvedProps = resolvedTag.firstContextDependency;
-              if (null !== resolvedProps) {
+              oldValue = getDerivedStateFromProps.firstContextDependency;
+              if (null !== oldValue) {
                 do {
                   if (
-                    resolvedProps.context === Component &&
-                    0 !== (resolvedProps.observedBits & updateExpirationTime)
+                    oldValue.context === updateExpirationTime &&
+                    0 !== (oldValue.observedBits & context)
                   ) {
-                    if (2 === resolvedTag.tag || 3 === resolvedTag.tag)
-                      (child = createUpdate(renderExpirationTime)),
-                        (child.tag = 2),
-                        enqueueUpdate(resolvedTag, child);
-                    if (
-                      0 === resolvedTag.expirationTime ||
-                      resolvedTag.expirationTime > renderExpirationTime
-                    )
-                      resolvedTag.expirationTime = renderExpirationTime;
-                    child = resolvedTag.alternate;
-                    null !== child &&
-                      (0 === child.expirationTime ||
-                        child.expirationTime > renderExpirationTime) &&
-                      (child.expirationTime = renderExpirationTime);
-                    for (var node = resolvedTag.return; null !== node; ) {
-                      child = node.alternate;
+                    if (1 === getDerivedStateFromProps.tag) {
+                      var nextFiber = createUpdate(
+                        renderExpirationTime$jscomp$0
+                      );
+                      nextFiber.tag = 2;
+                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
+                    }
+                    getDerivedStateFromProps.expirationTime <
+                      renderExpirationTime$jscomp$0 &&
+                      (getDerivedStateFromProps.expirationTime = renderExpirationTime$jscomp$0);
+                    nextFiber = getDerivedStateFromProps.alternate;
+                    null !== nextFiber &&
+                      nextFiber.expirationTime <
+                        renderExpirationTime$jscomp$0 &&
+                      (nextFiber.expirationTime = renderExpirationTime$jscomp$0);
+                    for (
+                      var node = getDerivedStateFromProps.return;
+                      null !== node;
+
+                    ) {
+                      nextFiber = node.alternate;
                       if (
-                        0 === node.childExpirationTime ||
-                        node.childExpirationTime > renderExpirationTime
+                        node.childExpirationTime < renderExpirationTime$jscomp$0
                       )
-                        (node.childExpirationTime = renderExpirationTime),
-                          null !== child &&
-                            (0 === child.childExpirationTime ||
-                              child.childExpirationTime >
-                                renderExpirationTime) &&
-                            (child.childExpirationTime = renderExpirationTime);
+                        (node.childExpirationTime = renderExpirationTime$jscomp$0),
+                          null !== nextFiber &&
+                            nextFiber.childExpirationTime <
+                              renderExpirationTime$jscomp$0 &&
+                            (nextFiber.childExpirationTime = renderExpirationTime$jscomp$0);
                       else if (
-                        null !== child &&
-                        (0 === child.childExpirationTime ||
-                          child.childExpirationTime > renderExpirationTime)
+                        null !== nextFiber &&
+                        nextFiber.childExpirationTime <
+                          renderExpirationTime$jscomp$0
                       )
-                        child.childExpirationTime = renderExpirationTime;
+                        nextFiber.childExpirationTime = renderExpirationTime$jscomp$0;
                       else break;
                       node = node.return;
                     }
                   }
-                  child = resolvedTag.child;
-                  resolvedProps = resolvedProps.next;
-                } while (null !== resolvedProps);
+                  nextFiber = getDerivedStateFromProps.child;
+                  oldValue = oldValue.next;
+                } while (null !== oldValue);
               } else
-                child =
-                  12 === resolvedTag.tag
-                    ? resolvedTag.type === workInProgress.type
+                nextFiber =
+                  10 === getDerivedStateFromProps.tag
+                    ? getDerivedStateFromProps.type === workInProgress.type
                       ? null
-                      : resolvedTag.child
-                    : resolvedTag.child;
-              if (null !== child) child.return = resolvedTag;
+                      : getDerivedStateFromProps.child
+                    : getDerivedStateFromProps.child;
+              if (null !== nextFiber)
+                nextFiber.return = getDerivedStateFromProps;
               else
-                for (child = resolvedTag; null !== child; ) {
-                  if (child === workInProgress) {
-                    child = null;
+                for (
+                  nextFiber = getDerivedStateFromProps;
+                  null !== nextFiber;
+
+                ) {
+                  if (nextFiber === workInProgress) {
+                    nextFiber = null;
                     break;
                   }
-                  resolvedTag = child.sibling;
-                  if (null !== resolvedTag) {
-                    resolvedTag.return = child.return;
-                    child = resolvedTag;
+                  getDerivedStateFromProps = nextFiber.sibling;
+                  if (null !== getDerivedStateFromProps) {
+                    getDerivedStateFromProps.return = nextFiber.return;
+                    nextFiber = getDerivedStateFromProps;
                     break;
                   }
-                  child = child.return;
+                  nextFiber = nextFiber.return;
                 }
-              resolvedTag = child;
+              getDerivedStateFromProps = nextFiber;
             }
+        }
         reconcileChildren(
           current$$1,
           workInProgress,
-          props.children,
-          renderExpirationTime
+          value.children,
+          renderExpirationTime$jscomp$0
         );
         workInProgress = workInProgress.child;
       }
       return workInProgress;
-    case 11:
+    case 9:
       return (
-        (updateExpirationTime = workInProgress.type),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
-        prepareToReadContext(workInProgress, renderExpirationTime),
-        (updateExpirationTime = readContext(
-          updateExpirationTime,
-          Component.unstable_observedBits
-        )),
-        (props = props(updateExpirationTime)),
+        (value = workInProgress.type),
+        (context = workInProgress.pendingProps),
+        (updateExpirationTime = context.children),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        (value = readContext(value, context.unstable_observedBits)),
+        (updateExpirationTime = updateExpirationTime(value)),
         (workInProgress.effectTag |= 1),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 17:
-      return updatePureComponent(
+    case 14:
+      return (
+        (value = workInProgress.type),
+        (context = resolveDefaultProps(
+          value.type,
+          workInProgress.pendingProps
+        )),
+        updateMemoComponent(
+          current$$1,
+          workInProgress,
+          value,
+          context,
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
         current$$1,
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
         updateExpirationTime,
-        renderExpirationTime
+        renderExpirationTime$jscomp$0
       );
-    case 18:
+    case 17:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updatePureComponent(
-          current$$1,
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        null !== current$$1 &&
+          ((current$$1.alternate = null),
+          (workInProgress.alternate = null),
+          (workInProgress.effectTag |= 2)),
+        (workInProgress.tag = 1),
+        isContextProvider(updateExpirationTime)
+          ? ((current$$1 = !0), pushContextProvider(workInProgress))
+          : (current$$1 = !1),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        constructClassInstance(
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
           updateExpirationTime,
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        mountClassInstance(
+          workInProgress,
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        )
       );
     default:
       invariant(
@@ -4288,14 +4831,113 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
-function appendAllChildren(parent, workInProgress) {
+var appendAllChildren = void 0,
+  updateHostContainer = void 0,
+  updateHostComponent$1 = void 0,
+  updateHostText$1 = void 0;
+appendAllChildren = function(
+  parent,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
   for (var node = workInProgress.child; null !== node; ) {
-    if (7 === node.tag || 8 === node.tag)
-      FabricUIManager.appendChild(parent.node, node.stateNode.node);
-    else if (6 !== node.tag && null !== node.child) {
-      node.child.return = node;
-      node = node.child;
-      continue;
+    a: if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        var props = node.memoizedProps,
+          type = node.type;
+        instance = isHidden
+          ? cloneHiddenInstance(instance, type, props, node)
+          : cloneUnhiddenInstance(instance, type, props, node);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChild(parent.node, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        instance = node.memoizedProps;
+        props = requiredContext(rootInstanceStackCursor.current);
+        type = requiredContext(contextStackCursor$1.current);
+        if (isHidden) throw Error("Not yet implemented.");
+        instance = createTextInstance(instance, props, type, workInProgress);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChild(parent.node, instance.node);
+    } else if (4 !== node.tag) {
+      if (
+        13 === node.tag &&
+        ((props = node.alternate),
+        null !== props &&
+          ((instance = null !== node.memoizedState),
+          (null !== props.memoizedState) !== instance))
+      ) {
+        props = instance ? node.child : node;
+        null !== props && appendAllChildren(parent, props, !0, instance);
+        break a;
+      }
+      if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    }
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+};
+function appendAllChildrenToContainer(
+  containerChildSet,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
+  for (var node = workInProgress.child; null !== node; ) {
+    a: if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        var props = node.memoizedProps,
+          type = node.type;
+        instance = isHidden
+          ? cloneHiddenInstance(instance, type, props, node)
+          : cloneUnhiddenInstance(instance, type, props, node);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChildToSet(containerChildSet, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle) {
+        instance = node.memoizedProps;
+        props = requiredContext(rootInstanceStackCursor.current);
+        type = requiredContext(contextStackCursor$1.current);
+        if (isHidden) throw Error("Not yet implemented.");
+        instance = createTextInstance(instance, props, type, workInProgress);
+        node.stateNode = instance;
+      }
+      FabricUIManager.appendChildToSet(containerChildSet, instance.node);
+    } else if (4 !== node.tag) {
+      if (
+        13 === node.tag &&
+        ((props = node.alternate),
+        null !== props &&
+          ((instance = null !== node.memoizedState),
+          (null !== props.memoizedState) !== instance))
+      ) {
+        props = instance ? node.child : node;
+        null !== props &&
+          appendAllChildrenToContainer(containerChildSet, props, !0, instance);
+        break a;
+      }
+      if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
     }
     if (node === workInProgress) break;
     for (; null === node.sibling; ) {
@@ -4306,30 +4948,12 @@ function appendAllChildren(parent, workInProgress) {
     node = node.sibling;
   }
 }
-var updateHostContainer = void 0,
-  updateHostComponent$1 = void 0,
-  updateHostText$1 = void 0;
 updateHostContainer = function(workInProgress) {
   var portalOrRoot = workInProgress.stateNode;
   if (null !== workInProgress.firstEffect) {
     var container = portalOrRoot.containerInfo,
       newChildSet = FabricUIManager.createChildSet(container);
-    a: for (var node = workInProgress.child; null !== node; ) {
-      if (7 === node.tag || 8 === node.tag)
-        FabricUIManager.appendChildToSet(newChildSet, node.stateNode.node);
-      else if (6 !== node.tag && null !== node.child) {
-        node.child.return = node;
-        node = node.child;
-        continue;
-      }
-      if (node === workInProgress) break a;
-      for (; null === node.sibling; ) {
-        if (null === node.return || node.return === workInProgress) break a;
-        node = node.return;
-      }
-      node.sibling.return = node.return;
-      node = node.sibling;
-    }
+    appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
     portalOrRoot.pendingChildren = newChildSet;
     workInProgress.effectTag |= 4;
     FabricUIManager.completeRoot(container, newChildSet);
@@ -4376,7 +5000,7 @@ updateHostComponent$1 = function(current, workInProgress, type, newProps) {
         (workInProgress.stateNode = type),
         current
           ? (workInProgress.effectTag |= 4)
-          : appendAllChildren(type, workInProgress));
+          : appendAllChildren(type, workInProgress, !1, !1));
   }
 };
 updateHostText$1 = function(current, workInProgress, oldText, newText) {
@@ -4426,7 +5050,7 @@ function logError(boundary, errorInfo) {
     willRetry: !1
   };
   null !== boundary &&
-    2 === boundary.tag &&
+    1 === boundary.tag &&
     ((errorInfo.errorBoundary = boundary.stateNode),
     (errorInfo.errorBoundaryName = getComponentName(boundary.type)),
     (errorInfo.errorBoundaryFound = !0),
@@ -4450,18 +5074,45 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if (0 !== (effect.tag & unmountTag)) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      0 !== (effect.tag & mountTag) &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
 function commitWork(current$$1, finishedWork) {
   switch (finishedWork.tag) {
-    case 2:
-    case 3:
-      break;
-    case 7:
-      break;
-    case 8:
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      commitHookEffectList(4, 8, finishedWork);
+      return;
+  }
+  switch (finishedWork.tag) {
+    case 1:
       break;
     case 5:
+      break;
     case 6:
       break;
+    case 3:
+    case 4:
+      break;
     default:
       invariant(
         !1,
@@ -4514,41 +5165,121 @@ function throwException(
   value,
   renderExpirationTime
 ) {
-  sourceFiber.effectTag |= 512;
+  sourceFiber.effectTag |= 1024;
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+  if (
+    null !== value &&
+    "object" === typeof value &&
+    "function" === typeof value.then
+  ) {
+    var thenable = value;
+    value = returnFiber;
+    var earliestTimeoutMs = -1,
+      startTimeMs = -1;
+    do {
+      if (13 === value.tag) {
+        var current$$1 = value.alternate;
+        if (
+          null !== current$$1 &&
+          ((current$$1 = current$$1.memoizedState), null !== current$$1)
+        ) {
+          startTimeMs = 10 * (1073741822 - current$$1.timedOutAt);
+          break;
+        }
+        current$$1 = value.pendingProps.maxDuration;
+        if ("number" === typeof current$$1)
+          if (0 >= current$$1) earliestTimeoutMs = 0;
+          else if (-1 === earliestTimeoutMs || current$$1 < earliestTimeoutMs)
+            earliestTimeoutMs = current$$1;
+      }
+      value = value.return;
+    } while (null !== value);
+    value = returnFiber;
+    do {
+      if ((current$$1 = 13 === value.tag))
+        current$$1 =
+          void 0 === value.memoizedProps.fallback
+            ? !1
+            : null === value.memoizedState;
+      if (current$$1) {
+        returnFiber = retrySuspendedRoot.bind(
+          null,
+          root,
+          value,
+          sourceFiber,
+          0 === (value.mode & 1) ? 1073741823 : renderExpirationTime
+        );
+        returnFiber = tracing.unstable_wrap(returnFiber);
+        thenable.then(returnFiber, returnFiber);
+        if (0 === (value.mode & 1)) {
+          value.effectTag |= 64;
+          sourceFiber.effectTag &= -1957;
+          1 === sourceFiber.tag &&
+            null === sourceFiber.alternate &&
+            (sourceFiber.tag = 17);
+          sourceFiber.expirationTime = renderExpirationTime;
+          return;
+        }
+        -1 === earliestTimeoutMs
+          ? (root = 1073741823)
+          : (-1 === startTimeMs &&
+              (startTimeMs =
+                10 *
+                  (1073741822 -
+                    findEarliestOutstandingPriorityLevel(
+                      root,
+                      renderExpirationTime
+                    )) -
+                5e3),
+            (root = startTimeMs + earliestTimeoutMs));
+        0 <= root &&
+          nextLatestAbsoluteTimeoutMs < root &&
+          (nextLatestAbsoluteTimeoutMs = root);
+        value.effectTag |= 2048;
+        value.expirationTime = renderExpirationTime;
+        return;
+      }
+      value = value.return;
+    } while (null !== value);
+    value = Error(
+      (getComponentName(sourceFiber.type) || "A React component") +
+        " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
+        getStackByFiberInDevAndProd(sourceFiber)
+    );
+  }
   nextRenderDidError = !0;
   value = createCapturedValue(value, sourceFiber);
   root = returnFiber;
   do {
     switch (root.tag) {
-      case 5:
-        root.effectTag |= 1024;
+      case 3:
+        sourceFiber = value;
+        root.effectTag |= 2048;
         root.expirationTime = renderExpirationTime;
         renderExpirationTime = createRootErrorUpdate(
           root,
-          value,
+          sourceFiber,
           renderExpirationTime
         );
         enqueueCapturedUpdate(root, renderExpirationTime);
         return;
-      case 2:
-      case 3:
-        returnFiber = value;
-        sourceFiber = root.type;
-        var instance = root.stateNode;
+      case 1:
         if (
+          ((sourceFiber = value),
+          (returnFiber = root.type),
+          (thenable = root.stateNode),
           0 === (root.effectTag & 64) &&
-          ("function" === typeof sourceFiber.getDerivedStateFromError ||
-            (null !== instance &&
-              "function" === typeof instance.componentDidCatch &&
-              (null === legacyErrorBoundariesThatAlreadyFailed ||
-                !legacyErrorBoundariesThatAlreadyFailed.has(instance))))
+            ("function" === typeof returnFiber.getDerivedStateFromError ||
+              (null !== thenable &&
+                "function" === typeof thenable.componentDidCatch &&
+                (null === legacyErrorBoundariesThatAlreadyFailed ||
+                  !legacyErrorBoundariesThatAlreadyFailed.has(thenable)))))
         ) {
-          root.effectTag |= 1024;
+          root.effectTag |= 2048;
           root.expirationTime = renderExpirationTime;
           renderExpirationTime = createClassErrorUpdate(
             root,
-            returnFiber,
+            sourceFiber,
             renderExpirationTime
           );
           enqueueCapturedUpdate(root, renderExpirationTime);
@@ -4560,24 +5291,14 @@ function throwException(
 }
 function unwindWork(workInProgress) {
   switch (workInProgress.tag) {
-    case 2:
+    case 1:
       isContextProvider(workInProgress.type) && popContext(workInProgress);
       var effectTag = workInProgress.effectTag;
-      return effectTag & 1024
-        ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+      return effectTag & 2048
+        ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
           workInProgress)
         : null;
     case 3:
-      return (
-        isContextProvider(workInProgress.type._reactResult) &&
-          popContext(workInProgress),
-        (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
-            workInProgress)
-          : null
-      );
-    case 5:
       return (
         popHostContainer(workInProgress),
         popTopLevelContextObject(workInProgress),
@@ -4586,41 +5307,122 @@ function unwindWork(workInProgress) {
           0 === (effectTag & 64),
           "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
         ),
-        (workInProgress.effectTag = (effectTag & -1025) | 64),
+        (workInProgress.effectTag = (effectTag & -2049) | 64),
         workInProgress
       );
-    case 7:
+    case 5:
       return popHostContext(workInProgress), null;
-    case 16:
+    case 13:
       return (
         (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+        effectTag & 2048
+          ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
             workInProgress)
           : null
       );
-    case 6:
+    case 4:
       return popHostContainer(workInProgress), null;
-    case 12:
+    case 10:
       return popProvider(workInProgress), null;
     default:
       return null;
   }
 }
-var Dispatcher = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [callback];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, inputs];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, inputs) {
+      useEffectImpl(516, 192, create, inputs);
+    },
+    useImperativeMethods: function(ref, create, inputs) {
+      inputs =
+        null !== inputs && void 0 !== inputs
+          ? inputs.concat([ref])
+          : [ref, create];
+      useEffectImpl(
+        4,
+        36,
+        function() {
+          if ("function" === typeof ref) {
+            var _inst = create();
+            ref(_inst);
+            return function() {
+              return ref(null);
+            };
+          }
+          if (null !== ref && void 0 !== ref)
+            return (
+              (_inst = create()),
+              (ref.current = _inst),
+              function() {
+                ref.current = null;
+              }
+            );
+        },
+        inputs
+      );
+    },
+    useLayoutEffect: function(create, inputs) {
+      useEffectImpl(4, 36, create, inputs);
+    },
+    useMemo: function(nextCreate, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [nextCreate];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      nextCreate = nextCreate();
+      workInProgressHook.memoizedState = [nextCreate, inputs];
+      return nextCreate;
+    },
+    useMutationEffect: function(create, inputs) {
+      useEffectImpl(260, 10, create, inputs);
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
 invariant(
   null != tracing.__interactionsRef &&
     null != tracing.__interactionsRef.current,
-  "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"
+  "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"
 );
 var isWorking = !1,
   nextUnitOfWork = null,
   nextRoot = null,
   nextRenderExpirationTime = 0,
+  nextLatestAbsoluteTimeoutMs = -1,
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
+  passiveEffectCallbackHandle = null,
+  passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
 function resetStack() {
   if (null !== nextUnitOfWork)
@@ -4631,7 +5433,7 @@ function resetStack() {
     ) {
       var interruptedWork$jscomp$0 = interruptedWork;
       switch (interruptedWork$jscomp$0.tag) {
-        case 2:
+        case 1:
           var childContextTypes =
             interruptedWork$jscomp$0.type.childContextTypes;
           null !== childContextTypes &&
@@ -4639,29 +5441,23 @@ function resetStack() {
             popContext(interruptedWork$jscomp$0);
           break;
         case 3:
-          childContextTypes =
-            interruptedWork$jscomp$0.type._reactResult.childContextTypes;
-          null !== childContextTypes &&
-            void 0 !== childContextTypes &&
-            popContext(interruptedWork$jscomp$0);
-          break;
-        case 5:
           popHostContainer(interruptedWork$jscomp$0);
           popTopLevelContextObject(interruptedWork$jscomp$0);
           break;
-        case 7:
+        case 5:
           popHostContext(interruptedWork$jscomp$0);
           break;
-        case 6:
+        case 4:
           popHostContainer(interruptedWork$jscomp$0);
           break;
-        case 12:
+        case 10:
           popProvider(interruptedWork$jscomp$0);
       }
       interruptedWork = interruptedWork.return;
     }
   nextRoot = null;
   nextRenderExpirationTime = 0;
+  nextLatestAbsoluteTimeoutMs = -1;
   nextRenderDidError = !1;
   nextUnitOfWork = null;
 }
@@ -4695,23 +5491,46 @@ function commitAllHostEffects() {
           "function" === typeof onCommitFiberUnmount &&
             onCommitFiberUnmount(current$$1$jscomp$0);
           switch (current$$1$jscomp$0.tag) {
-            case 2:
-            case 3:
+            case 0:
+            case 11:
+            case 14:
+            case 15:
+              var updateQueue = current$$1$jscomp$0.updateQueue;
+              if (
+                null !== updateQueue &&
+                ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
+              ) {
+                var effect = (updateQueue = updateQueue.next);
+                do {
+                  var destroy = effect.destroy;
+                  if (null !== destroy) {
+                    var current$$1$jscomp$1 = current$$1$jscomp$0;
+                    try {
+                      destroy();
+                    } catch (error) {
+                      captureCommitPhaseError(current$$1$jscomp$1, error);
+                    }
+                  }
+                  effect = effect.next;
+                } while (effect !== updateQueue);
+              }
+              break;
+            case 1:
               safelyDetachRef(current$$1$jscomp$0);
-              var instance = current$$1$jscomp$0.stateNode;
-              if ("function" === typeof instance.componentWillUnmount)
+              updateQueue = current$$1$jscomp$0.stateNode;
+              if ("function" === typeof updateQueue.componentWillUnmount)
                 try {
-                  (instance.props = current$$1$jscomp$0.memoizedProps),
-                    (instance.state = current$$1$jscomp$0.memoizedState),
-                    instance.componentWillUnmount();
+                  (updateQueue.props = current$$1$jscomp$0.memoizedProps),
+                    (updateQueue.state = current$$1$jscomp$0.memoizedState),
+                    updateQueue.componentWillUnmount();
                 } catch (unmountError) {
                   captureCommitPhaseError(current$$1$jscomp$0, unmountError);
                 }
               break;
-            case 7:
+            case 5:
               safelyDetachRef(current$$1$jscomp$0);
               break;
-            case 6:
+            case 4:
               FabricUIManager.createChildSet(
                 current$$1$jscomp$0.stateNode.containerInfo
               );
@@ -4739,30 +5558,35 @@ function commitAllHostEffects() {
 }
 function commitBeforeMutationLifecycles() {
   for (; null !== nextEffect; ) {
-    if (nextEffect.effectTag & 256) {
-      var current$$1 = nextEffect.alternate;
+    if (nextEffect.effectTag & 256)
       a: {
-        var finishedWork = nextEffect;
+        var current$$1 = nextEffect.alternate,
+          finishedWork = nextEffect;
         switch (finishedWork.tag) {
-          case 2:
-          case 3:
+          case 0:
+          case 11:
+          case 15:
+            commitHookEffectList(2, 0, finishedWork);
+            break a;
+          case 1:
             if (finishedWork.effectTag & 256 && null !== current$$1) {
               var prevProps = current$$1.memoizedProps,
                 prevState = current$$1.memoizedState;
               current$$1 = finishedWork.stateNode;
-              current$$1.props = finishedWork.memoizedProps;
-              current$$1.state = finishedWork.memoizedState;
               finishedWork = current$$1.getSnapshotBeforeUpdate(
-                prevProps,
+                finishedWork.elementType === finishedWork.type
+                  ? prevProps
+                  : resolveDefaultProps(finishedWork.type, prevProps),
                 prevState
               );
               current$$1.__reactInternalSnapshotBeforeUpdate = finishedWork;
             }
             break a;
+          case 3:
           case 5:
-          case 7:
-          case 8:
           case 6:
+          case 4:
+          case 17:
             break a;
           default:
             invariant(
@@ -4771,7 +5595,6 @@ function commitBeforeMutationLifecycles() {
             );
         }
       }
-    }
     nextEffect = nextEffect.nextEffect;
   }
 }
@@ -4787,47 +5610,48 @@ function commitAllLifeCycles(
         finishedWork = nextEffect,
         committedExpirationTime = committedExpirationTime$jscomp$0;
       switch (finishedWork.tag) {
-        case 2:
-        case 3:
+        case 0:
+        case 11:
+        case 15:
+          commitHookEffectList(16, 32, finishedWork);
+          break;
+        case 1:
           finishedRoot = finishedWork.stateNode;
           if (finishedWork.effectTag & 4)
-            if (null === current$$1)
-              (finishedRoot.props = finishedWork.memoizedProps),
-                (finishedRoot.state = finishedWork.memoizedState),
-                finishedRoot.componentDidMount();
+            if (null === current$$1) finishedRoot.componentDidMount();
             else {
-              var prevProps = current$$1.memoizedProps;
-              current$$1 = current$$1.memoizedState;
-              finishedRoot.props = finishedWork.memoizedProps;
-              finishedRoot.state = finishedWork.memoizedState;
+              var prevProps =
+                finishedWork.elementType === finishedWork.type
+                  ? current$$1.memoizedProps
+                  : resolveDefaultProps(
+                      finishedWork.type,
+                      current$$1.memoizedProps
+                    );
               finishedRoot.componentDidUpdate(
                 prevProps,
-                current$$1,
+                current$$1.memoizedState,
                 finishedRoot.__reactInternalSnapshotBeforeUpdate
               );
             }
           current$$1 = finishedWork.updateQueue;
           null !== current$$1 &&
-            ((finishedRoot.props = finishedWork.memoizedProps),
-            (finishedRoot.state = finishedWork.memoizedState),
             commitUpdateQueue(
               finishedWork,
               current$$1,
               finishedRoot,
               committedExpirationTime
-            ));
+            );
           break;
-        case 5:
+        case 3:
           current$$1 = finishedWork.updateQueue;
           if (null !== current$$1) {
             finishedRoot = null;
             if (null !== finishedWork.child)
               switch (finishedWork.child.tag) {
-                case 7:
+                case 5:
                   finishedRoot = finishedWork.child.stateNode.canonical;
                   break;
-                case 2:
-                case 3:
+                case 1:
                   finishedRoot = finishedWork.child.stateNode;
               }
             commitUpdateQueue(
@@ -4838,7 +5662,7 @@ function commitAllLifeCycles(
             );
           }
           break;
-        case 7:
+        case 5:
           null === current$$1 &&
             finishedWork.effectTag & 4 &&
             invariant(
@@ -4846,11 +5670,11 @@ function commitAllLifeCycles(
               "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
             );
           break;
-        case 8:
-          break;
         case 6:
           break;
-        case 15:
+        case 4:
+          break;
+        case 12:
           committedExpirationTime = finishedWork.memoizedProps.onRender;
           committedExpirationTime(
             finishedWork.memoizedProps.id,
@@ -4862,7 +5686,9 @@ function commitAllLifeCycles(
             finishedRoot.memoizedInteractions
           );
           break;
-        case 16:
+        case 13:
+          break;
+        case 17:
           break;
         default:
           invariant(
@@ -4871,21 +5697,51 @@ function commitAllLifeCycles(
           );
       }
     }
-    if (effectTag & 128 && ((effectTag = nextEffect.ref), null !== effectTag)) {
-      finishedWork = nextEffect.stateNode;
+    if (
+      effectTag & 128 &&
+      ((finishedWork = nextEffect.ref), null !== finishedWork)
+    ) {
+      committedExpirationTime = nextEffect.stateNode;
       switch (nextEffect.tag) {
-        case 7:
-          finishedWork = finishedWork.canonical;
+        case 5:
+          committedExpirationTime = committedExpirationTime.canonical;
       }
-      "function" === typeof effectTag
-        ? effectTag(finishedWork)
-        : (effectTag.current = finishedWork);
+      "function" === typeof finishedWork
+        ? finishedWork(committedExpirationTime)
+        : (finishedWork.current = committedExpirationTime);
     }
-    effectTag = nextEffect.nextEffect;
-    nextEffect.nextEffect = null;
-    nextEffect = effectTag;
+    effectTag & 512 && (rootWithPendingPassiveEffects = finishedRoot$jscomp$0);
+    nextEffect = nextEffect.nextEffect;
   }
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(128, 0, finishedWork);
+        commitHookEffectList(0, 64, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
+function flushPassiveEffects() {
+  null !== passiveEffectCallback &&
+    (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
+    passiveEffectCallback());
+}
 function commitRoot(root, finishedWork) {
   isCommitting$1 = isWorking = !0;
   invariant(
@@ -4902,9 +5758,7 @@ function commitRoot(root, finishedWork) {
     childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
   markCommittedPriorityLevels(
     root,
-    0 === updateExpirationTimeBeforeCommit ||
-    (0 !== childExpirationTimeBeforeCommit &&
-      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit)
+    childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit
       ? childExpirationTimeBeforeCommit
       : updateExpirationTimeBeforeCommit
   );
@@ -4954,29 +5808,42 @@ function commitRoot(root, finishedWork) {
   }
   root.current = finishedWork;
   for (nextEffect = childExpirationTimeBeforeCommit; null !== nextEffect; ) {
-    childExpirationTimeBeforeCommit = !1;
-    didError = void 0;
+    didError = !1;
+    error$jscomp$0 = void 0;
     try {
       commitAllLifeCycles(root, committedExpirationTime);
     } catch (e) {
-      (childExpirationTimeBeforeCommit = !0), (didError = e);
+      (didError = !0), (error$jscomp$0 = e);
     }
-    childExpirationTimeBeforeCommit &&
+    didError &&
       (invariant(
         null !== nextEffect,
         "Should have next effect. This error is likely caused by a bug in React. Please file an issue."
       ),
-      captureCommitPhaseError(nextEffect, didError),
+      captureCommitPhaseError(nextEffect, error$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== childExpirationTimeBeforeCommit &&
+    null !== rootWithPendingPassiveEffects &&
+    ((childExpirationTimeBeforeCommit = commitPassiveEffects.bind(
+      null,
+      root,
+      childExpirationTimeBeforeCommit
+    )),
+    (childExpirationTimeBeforeCommit = tracing.unstable_wrap(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallback = childExpirationTimeBeforeCommit));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork.stateNode);
   childExpirationTimeBeforeCommit = finishedWork.expirationTime;
   finishedWork = finishedWork.childExpirationTime;
   var earliestRemainingTimeAfterCommit =
-    0 === childExpirationTimeBeforeCommit ||
-    (0 !== finishedWork && finishedWork < childExpirationTimeBeforeCommit)
+    finishedWork > childExpirationTimeBeforeCommit
       ? finishedWork
       : childExpirationTimeBeforeCommit;
   0 === earliestRemainingTimeAfterCommit &&
@@ -5001,21 +5868,18 @@ function commitRoot(root, finishedWork) {
       scheduledInteractions,
       scheduledExpirationTime
     ) {
-      if (
-        0 === earliestRemainingTimeAfterCommit ||
-        scheduledExpirationTime < earliestRemainingTimeAfterCommit
-      )
-        pendingInteractionMap.delete(scheduledExpirationTime),
-          scheduledInteractions.forEach(function(interaction) {
-            interaction.__count--;
-            if (null !== subscriber && 0 === interaction.__count)
-              try {
-                subscriber.onInteractionScheduledWorkCompleted(interaction);
-              } catch (error) {
-                hasUnhandledError ||
-                  ((hasUnhandledError = !0), (unhandledError = error));
-              }
-          });
+      scheduledExpirationTime > earliestRemainingTimeAfterCommit &&
+        (pendingInteractionMap.delete(scheduledExpirationTime),
+        scheduledInteractions.forEach(function(interaction) {
+          interaction.__count--;
+          if (null !== subscriber && 0 === interaction.__count)
+            try {
+              subscriber.onInteractionScheduledWorkCompleted(interaction);
+            } catch (error) {
+              hasUnhandledError ||
+                ((hasUnhandledError = !0), (unhandledError = error));
+            }
+        }));
     });
   }
 }
@@ -5024,198 +5888,210 @@ function completeUnitOfWork(workInProgress) {
     var current$$1 = workInProgress.alternate,
       returnFiber = workInProgress.return,
       siblingFiber = workInProgress.sibling;
-    if (0 === (workInProgress.effectTag & 512)) {
+    if (0 === (workInProgress.effectTag & 1024)) {
+      nextUnitOfWork = workInProgress;
       if (workInProgress.mode & 4) {
         var fiber = workInProgress;
         profilerStartTime = now$1();
         0 > fiber.actualStartTime && (fiber.actualStartTime = now$1());
       }
-      var current = current$$1;
-      current$$1 = workInProgress;
-      fiber = current$$1.pendingProps;
-      switch (current$$1.tag) {
-        case 0:
-        case 1:
-          break;
-        case 2:
-          isContextProvider(current$$1.type) && popContext(current$$1);
-          break;
-        case 3:
-          isContextProvider(current$$1.type._reactResult) &&
-            popContext(current$$1);
-          break;
-        case 5:
-          popHostContainer(current$$1);
-          popTopLevelContextObject(current$$1);
-          fiber = current$$1.stateNode;
-          fiber.pendingContext &&
-            ((fiber.context = fiber.pendingContext),
-            (fiber.pendingContext = null));
-          if (null === current || null === current.child)
-            current$$1.effectTag &= -3;
-          updateHostContainer(current$$1);
-          break;
-        case 7:
-          popHostContext(current$$1);
-          var rootContainerInstance = requiredContext(
+      a: {
+        var current = current$$1;
+        current$$1 = workInProgress;
+        var renderExpirationTime = nextRenderExpirationTime;
+        fiber = current$$1.pendingProps;
+        switch (current$$1.tag) {
+          case 2:
+            break;
+          case 16:
+            break;
+          case 15:
+          case 0:
+            break;
+          case 1:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          case 3:
+            popHostContainer(current$$1);
+            popTopLevelContextObject(current$$1);
+            fiber = current$$1.stateNode;
+            fiber.pendingContext &&
+              ((fiber.context = fiber.pendingContext),
+              (fiber.pendingContext = null));
+            if (null === current || null === current.child)
+              current$$1.effectTag &= -3;
+            updateHostContainer(current$$1);
+            break;
+          case 5:
+            popHostContext(current$$1);
+            renderExpirationTime = requiredContext(
               rootInstanceStackCursor.current
-            ),
-            type = current$$1.type;
-          if (null !== current && null != current$$1.stateNode)
-            updateHostComponent$1(
-              current,
-              current$$1,
-              type,
-              fiber,
-              rootContainerInstance
-            ),
-              current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
-          else if (fiber) {
-            var currentHostContext = requiredContext(
-                contextStackCursor$1.current
-              ),
-              internalInstanceHandle = current$$1;
-            current = nextReactTag;
-            nextReactTag += 2;
-            var viewConfig = ReactNativeViewConfigRegistry.get(type);
-            invariant(
-              "RCTView" !== type || !currentHostContext.isInAParentText,
-              "Nesting of <View> within <Text> is not currently supported."
-            );
-            type = diffProperties(
-              null,
-              emptyObject,
-              fiber,
-              viewConfig.validAttributes
-            );
-            rootContainerInstance = FabricUIManager.createNode(
-              current,
-              viewConfig.uiViewClassName,
-              rootContainerInstance,
-              type,
-              internalInstanceHandle
             );
-            fiber = new ReactFabricHostComponent(current, viewConfig, fiber);
-            fiber = { node: rootContainerInstance, canonical: fiber };
-            appendAllChildren(fiber, current$$1);
-            current$$1.stateNode = fiber;
-            null !== current$$1.ref && (current$$1.effectTag |= 128);
-          } else
-            invariant(
-              null !== current$$1.stateNode,
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-            );
-          break;
-        case 8:
-          current && null != current$$1.stateNode
-            ? updateHostText$1(
+            var type = current$$1.type;
+            if (null !== current && null != current$$1.stateNode)
+              updateHostComponent$1(
                 current,
                 current$$1,
-                current.memoizedProps,
-                fiber
-              )
-            : ("string" !== typeof fiber &&
-                invariant(
-                  null !== current$$1.stateNode,
-                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                type,
+                fiber,
+                renderExpirationTime
+              ),
+                current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
+            else if (fiber) {
+              var currentHostContext = requiredContext(
+                  contextStackCursor$1.current
                 ),
-              (rootContainerInstance = requiredContext(
-                rootInstanceStackCursor.current
-              )),
-              (current = requiredContext(contextStackCursor$1.current)),
-              (current$$1.stateNode = createTextInstance(
+                internalInstanceHandle = current$$1;
+              current = nextReactTag;
+              nextReactTag += 2;
+              var viewConfig = ReactNativeViewConfigRegistry.get(type);
+              invariant(
+                "RCTView" !== type || !currentHostContext.isInAParentText,
+                "Nesting of <View> within <Text> is not currently supported."
+              );
+              type = diffProperties(
+                null,
+                emptyObject,
                 fiber,
-                rootContainerInstance,
+                viewConfig.validAttributes
+              );
+              renderExpirationTime = FabricUIManager.createNode(
                 current,
-                current$$1
-              )));
-          break;
-        case 13:
-        case 14:
-          break;
-        case 16:
-          break;
-        case 9:
-          break;
-        case 10:
-          break;
-        case 15:
-          break;
-        case 6:
-          popHostContainer(current$$1);
-          updateHostContainer(current$$1);
-          break;
-        case 12:
-          popProvider(current$$1);
-          break;
-        case 11:
-          break;
-        case 17:
-        case 18:
-          break;
-        case 4:
-          invariant(
-            !1,
-            "An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue."
-          );
-        default:
-          invariant(
-            !1,
-            "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
-          );
+                viewConfig.uiViewClassName,
+                renderExpirationTime,
+                type,
+                internalInstanceHandle
+              );
+              fiber = new ReactFabricHostComponent(current, viewConfig, fiber);
+              fiber = { node: renderExpirationTime, canonical: fiber };
+              appendAllChildren(fiber, current$$1, !1, !1);
+              current$$1.stateNode = fiber;
+              null !== current$$1.ref && (current$$1.effectTag |= 128);
+            } else
+              invariant(
+                null !== current$$1.stateNode,
+                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+              );
+            break;
+          case 6:
+            current && null != current$$1.stateNode
+              ? updateHostText$1(
+                  current,
+                  current$$1,
+                  current.memoizedProps,
+                  fiber
+                )
+              : ("string" !== typeof fiber &&
+                  invariant(
+                    null !== current$$1.stateNode,
+                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                  ),
+                (current = requiredContext(rootInstanceStackCursor.current)),
+                (renderExpirationTime = requiredContext(
+                  contextStackCursor$1.current
+                )),
+                (current$$1.stateNode = createTextInstance(
+                  fiber,
+                  current,
+                  renderExpirationTime,
+                  current$$1
+                )));
+            break;
+          case 11:
+            break;
+          case 13:
+            fiber = current$$1.memoizedState;
+            if (0 !== (current$$1.effectTag & 64)) {
+              current$$1.expirationTime = renderExpirationTime;
+              nextUnitOfWork = current$$1;
+              break a;
+            }
+            fiber = null !== fiber;
+            renderExpirationTime =
+              null !== current && null !== current.memoizedState;
+            null !== current &&
+              !fiber &&
+              renderExpirationTime &&
+              ((current = current.child.sibling),
+              null !== current &&
+                ((viewConfig = current$$1.firstEffect),
+                null !== viewConfig
+                  ? ((current$$1.firstEffect = current),
+                    (current.nextEffect = viewConfig))
+                  : ((current$$1.firstEffect = current$$1.lastEffect = current),
+                    (current.nextEffect = null)),
+                (current.effectTag = 8)));
+            if (
+              fiber !== renderExpirationTime ||
+              (0 === (current$$1.effectTag & 1) && fiber)
+            )
+              current$$1.effectTag |= 4;
+            break;
+          case 7:
+            break;
+          case 8:
+            break;
+          case 12:
+            break;
+          case 4:
+            popHostContainer(current$$1);
+            updateHostContainer(current$$1);
+            break;
+          case 10:
+            popProvider(current$$1);
+            break;
+          case 9:
+            break;
+          case 14:
+            break;
+          case 17:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          default:
+            invariant(
+              !1,
+              "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
+        nextUnitOfWork = null;
       }
-      nextUnitOfWork = null;
       workInProgress.mode & 4 &&
         stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !1);
       current$$1 = workInProgress;
       if (
-        1073741823 === nextRenderExpirationTime ||
-        1073741823 !== current$$1.childExpirationTime
+        1 === nextRenderExpirationTime ||
+        1 !== current$$1.childExpirationTime
       ) {
         fiber = 0;
         if (current$$1.mode & 4) {
-          rootContainerInstance = current$$1.actualDuration;
-          current = current$$1.selfBaseDuration;
+          current = current$$1.actualDuration;
+          renderExpirationTime = current$$1.selfBaseDuration;
           viewConfig =
             null === current$$1.alternate ||
             current$$1.child !== current$$1.alternate.child;
-          for (type = current$$1.child; null !== type; ) {
-            internalInstanceHandle = type.expirationTime;
-            currentHostContext = type.childExpirationTime;
-            if (
-              0 === fiber ||
-              (0 !== internalInstanceHandle && internalInstanceHandle < fiber)
-            )
-              fiber = internalInstanceHandle;
-            if (
-              0 === fiber ||
-              (0 !== currentHostContext && currentHostContext < fiber)
-            )
-              fiber = currentHostContext;
-            viewConfig && (rootContainerInstance += type.actualDuration);
-            current += type.treeBaseDuration;
-            type = type.sibling;
-          }
-          current$$1.actualDuration = rootContainerInstance;
-          current$$1.treeBaseDuration = current;
+          for (type = current$$1.child; null !== type; )
+            (internalInstanceHandle = type.expirationTime),
+              (currentHostContext = type.childExpirationTime),
+              internalInstanceHandle > fiber &&
+                (fiber = internalInstanceHandle),
+              currentHostContext > fiber && (fiber = currentHostContext),
+              viewConfig && (current += type.actualDuration),
+              (renderExpirationTime += type.treeBaseDuration),
+              (type = type.sibling);
+          current$$1.actualDuration = current;
+          current$$1.treeBaseDuration = renderExpirationTime;
         } else
-          for (
-            rootContainerInstance = current$$1.child;
-            null !== rootContainerInstance;
-
-          ) {
-            current = rootContainerInstance.expirationTime;
-            viewConfig = rootContainerInstance.childExpirationTime;
-            if (0 === fiber || (0 !== current && current < fiber))
-              fiber = current;
-            if (0 === fiber || (0 !== viewConfig && viewConfig < fiber))
-              fiber = viewConfig;
-            rootContainerInstance = rootContainerInstance.sibling;
-          }
+          for (current = current$$1.child; null !== current; )
+            (renderExpirationTime = current.expirationTime),
+              (viewConfig = current.childExpirationTime),
+              renderExpirationTime > fiber && (fiber = renderExpirationTime),
+              viewConfig > fiber && (fiber = viewConfig),
+              (current = current.sibling);
         current$$1.childExpirationTime = fiber;
       }
+      if (null !== nextUnitOfWork) return nextUnitOfWork;
       null !== returnFiber &&
-        0 === (returnFiber.effectTag & 512) &&
+        0 === (returnFiber.effectTag & 1024) &&
         (null === returnFiber.firstEffect &&
           (returnFiber.firstEffect = workInProgress.firstEffect),
         null !== workInProgress.lastEffect &&
@@ -5228,23 +6104,19 @@ function completeUnitOfWork(workInProgress) {
             : (returnFiber.firstEffect = workInProgress),
           (returnFiber.lastEffect = workInProgress)));
     } else {
-      workInProgress.mode & 4 &&
+      if (workInProgress.mode & 4) {
         stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !1);
-      workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
-      if (null !== workInProgress) {
-        if (workInProgress.mode & 4) {
-          returnFiber = workInProgress.actualDuration;
-          for (siblingFiber = workInProgress.child; null !== siblingFiber; )
-            (returnFiber += siblingFiber.actualDuration),
-              (siblingFiber = siblingFiber.sibling);
-          workInProgress.actualDuration = returnFiber;
-        }
-        workInProgress.effectTag &= 511;
-        return workInProgress;
+        current$$1 = workInProgress.actualDuration;
+        for (fiber = workInProgress.child; null !== fiber; )
+          (current$$1 += fiber.actualDuration), (fiber = fiber.sibling);
+        workInProgress.actualDuration = current$$1;
       }
+      workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
+      if (null !== workInProgress)
+        return (workInProgress.effectTag &= 1023), workInProgress;
       null !== returnFiber &&
         ((returnFiber.firstEffect = returnFiber.lastEffect = null),
-        (returnFiber.effectTag |= 512));
+        (returnFiber.effectTag |= 1024));
     }
     if (null !== siblingFiber) return siblingFiber;
     if (null !== returnFiber) workInProgress = returnFiber;
@@ -5259,17 +6131,19 @@ function performUnitOfWork(workInProgress) {
     0 > workInProgress.actualStartTime &&
       (workInProgress.actualStartTime = now$1()));
   current$$1 = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
+  workInProgress.memoizedProps = workInProgress.pendingProps;
   workInProgress.mode & 4 &&
     stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !0);
   null === current$$1 && (current$$1 = completeUnitOfWork(workInProgress));
   ReactCurrentOwner$2.current = null;
   return current$$1;
 }
-function renderRoot(root, isYieldy, isExpired) {
+function renderRoot(root, isYieldy) {
   invariant(
     !isWorking,
     "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
+  flushPassiveEffects();
   isWorking = !0;
   ReactCurrentOwner$2.currentDispatcher = Dispatcher;
   var expirationTime = root.nextExpirationTimeToWorkOn;
@@ -5292,7 +6166,7 @@ function renderRoot(root, isYieldy, isExpired) {
       scheduledInteractions,
       scheduledExpirationTime
     ) {
-      scheduledExpirationTime <= expirationTime &&
+      scheduledExpirationTime >= expirationTime &&
         scheduledInteractions.forEach(function(interaction) {
           return interactions.add(interaction);
         });
@@ -5318,15 +6192,21 @@ function renderRoot(root, isYieldy, isExpired) {
   do {
     try {
       if (isYieldy)
-        for (; null !== nextUnitOfWork && !shouldYield(); )
+        for (; null !== nextUnitOfWork && !shouldYieldToRenderer(); )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
       else
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (null === nextUnitOfWork)
+      if (
+        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
+        resetHooks(),
+        null === nextUnitOfWork)
+      )
         (threadID = !0), onUncaughtError(thrownValue);
       else {
+        nextUnitOfWork.mode & 4 &&
+          stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, !0);
         invariant(
           null !== nextUnitOfWork,
           "Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it."
@@ -5352,134 +6232,162 @@ function renderRoot(root, isYieldy, isExpired) {
   tracing.__interactionsRef.current = subscriber;
   isWorking = !1;
   lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
+  resetHooks();
   if (threadID) (nextRoot = null), (root.finishedWork = null);
   else if (null !== nextUnitOfWork) root.finishedWork = null;
   else {
-    isYieldy = root.current.alternate;
+    subscriber = root.current.alternate;
     invariant(
-      null !== isYieldy,
+      null !== subscriber,
       "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue."
     );
     nextRoot = null;
     if (nextRenderDidError) {
       if (hasLowerPriorityWork(root, expirationTime)) {
         markSuspendedPriorityLevel(root, expirationTime);
-        onSuspend(root, isYieldy, expirationTime, root.expirationTime, -1);
+        onSuspend(root, subscriber, expirationTime, root.expirationTime, -1);
         return;
       }
-      if (!root.didError && !isExpired) {
+      if (!root.didError && isYieldy) {
         root.didError = !0;
-        isExpired = root.nextExpirationTimeToWorkOn = expirationTime;
-        subscriber = root.expirationTime = 1;
-        onSuspend(root, isYieldy, isExpired, subscriber, -1);
+        isYieldy = root.nextExpirationTimeToWorkOn = expirationTime;
+        threadID = root.expirationTime = 1073741823;
+        onSuspend(root, subscriber, isYieldy, threadID, -1);
         return;
       }
     }
-    onComplete(root, isYieldy, expirationTime);
+    isYieldy && -1 !== nextLatestAbsoluteTimeoutMs
+      ? (markSuspendedPriorityLevel(root, expirationTime),
+        (isYieldy =
+          10 *
+          (1073741822 -
+            findEarliestOutstandingPriorityLevel(root, expirationTime))),
+        isYieldy < nextLatestAbsoluteTimeoutMs &&
+          (nextLatestAbsoluteTimeoutMs = isYieldy),
+        (isYieldy = 10 * (1073741822 - requestCurrentTime())),
+        (isYieldy = nextLatestAbsoluteTimeoutMs - isYieldy),
+        onSuspend(
+          root,
+          subscriber,
+          expirationTime,
+          root.expirationTime,
+          0 > isYieldy ? 0 : isYieldy
+        ))
+      : onComplete(root, subscriber, expirationTime);
   }
 }
-function captureCommitPhaseError(fiber, error) {
-  var JSCompiler_inline_result;
-  a: {
-    invariant(
-      !isWorking || isCommitting$1,
-      "dispatch: Cannot dispatch during the render phase."
-    );
-    for (
-      JSCompiler_inline_result = fiber.return;
-      null !== JSCompiler_inline_result;
-
-    ) {
-      switch (JSCompiler_inline_result.tag) {
-        case 2:
-        case 3:
-          var instance = JSCompiler_inline_result.stateNode;
-          if (
-            "function" ===
-              typeof JSCompiler_inline_result.type.getDerivedStateFromError ||
-            ("function" === typeof instance.componentDidCatch &&
-              (null === legacyErrorBoundariesThatAlreadyFailed ||
-                !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
-          ) {
-            fiber = createCapturedValue(error, fiber);
-            fiber = createClassErrorUpdate(JSCompiler_inline_result, fiber, 1);
-            enqueueUpdate(JSCompiler_inline_result, fiber);
-            scheduleWork(JSCompiler_inline_result, 1);
-            JSCompiler_inline_result = void 0;
-            break a;
-          }
-          break;
-        case 5:
-          fiber = createCapturedValue(error, fiber);
-          fiber = createRootErrorUpdate(JSCompiler_inline_result, fiber, 1);
-          enqueueUpdate(JSCompiler_inline_result, fiber);
-          scheduleWork(JSCompiler_inline_result, 1);
-          JSCompiler_inline_result = void 0;
-          break a;
-      }
-      JSCompiler_inline_result = JSCompiler_inline_result.return;
+function captureCommitPhaseError(sourceFiber, value) {
+  for (var fiber = sourceFiber.return; null !== fiber; ) {
+    switch (fiber.tag) {
+      case 1:
+        var instance = fiber.stateNode;
+        if (
+          "function" === typeof fiber.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValue(value, sourceFiber);
+          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
+          enqueueUpdate(fiber, sourceFiber);
+          scheduleWork(fiber, 1073741823);
+          return;
+        }
+        break;
+      case 3:
+        sourceFiber = createCapturedValue(value, sourceFiber);
+        sourceFiber = createRootErrorUpdate(fiber, sourceFiber, 1073741823);
+        enqueueUpdate(fiber, sourceFiber);
+        scheduleWork(fiber, 1073741823);
+        return;
     }
-    5 === fiber.tag &&
-      ((JSCompiler_inline_result = createCapturedValue(error, fiber)),
-      (JSCompiler_inline_result = createRootErrorUpdate(
-        fiber,
-        JSCompiler_inline_result,
-        1
-      )),
-      enqueueUpdate(fiber, JSCompiler_inline_result),
-      scheduleWork(fiber, 1));
-    JSCompiler_inline_result = void 0;
+    fiber = fiber.return;
   }
-  return JSCompiler_inline_result;
+  3 === sourceFiber.tag &&
+    ((fiber = createCapturedValue(value, sourceFiber)),
+    (fiber = createRootErrorUpdate(sourceFiber, fiber, 1073741823)),
+    enqueueUpdate(sourceFiber, fiber),
+    scheduleWork(sourceFiber, 1073741823));
 }
 function computeExpirationForFiber(currentTime, fiber) {
   isWorking
-    ? (currentTime = isCommitting$1 ? 1 : nextRenderExpirationTime)
+    ? (currentTime = isCommitting$1 ? 1073741823 : nextRenderExpirationTime)
     : fiber.mode & 1
       ? ((currentTime = isBatchingInteractiveUpdates
-          ? 2 + 10 * ((((currentTime - 2 + 15) / 10) | 0) + 1)
-          : 2 + 25 * ((((currentTime - 2 + 500) / 25) | 0) + 1)),
+          ? 1073741822 - 10 * ((((1073741822 - currentTime + 15) / 10) | 0) + 1)
+          : 1073741822 -
+            25 * ((((1073741822 - currentTime + 500) / 25) | 0) + 1)),
         null !== nextRoot &&
           currentTime === nextRenderExpirationTime &&
-          (currentTime += 1))
-      : (currentTime = 1);
+          --currentTime)
+      : (currentTime = 1073741823);
   isBatchingInteractiveUpdates &&
-    currentTime > lowestPriorityPendingInteractiveExpirationTime &&
+    (0 === lowestPriorityPendingInteractiveExpirationTime ||
+      currentTime < lowestPriorityPendingInteractiveExpirationTime) &&
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
+function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
+  var retryTime = root.earliestSuspendedTime;
+  var latestSuspendedTime = root.latestSuspendedTime;
+  if (
+    0 !== retryTime &&
+    suspendedTime <= retryTime &&
+    suspendedTime >= latestSuspendedTime
+  ) {
+    latestSuspendedTime = retryTime = suspendedTime;
+    root.didError = !1;
+    var latestPingedTime = root.latestPingedTime;
+    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
+      root.latestPingedTime = latestSuspendedTime;
+    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
+  } else
+    (retryTime = requestCurrentTime()),
+      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
+      markPendingPriorityLevel(root, retryTime);
+  0 !== (boundaryFiber.mode & 1) &&
+    root === nextRoot &&
+    nextRenderExpirationTime === suspendedTime &&
+    (nextRoot = null);
+  scheduleWorkToRoot(boundaryFiber, retryTime);
+  0 === (boundaryFiber.mode & 1) &&
+    (scheduleWorkToRoot(sourceFiber, retryTime),
+    1 === sourceFiber.tag &&
+      null !== sourceFiber.stateNode &&
+      ((boundaryFiber = createUpdate(retryTime)),
+      (boundaryFiber.tag = 2),
+      enqueueUpdate(sourceFiber, boundaryFiber)));
+  sourceFiber = root.expirationTime;
+  0 !== sourceFiber && requestWork(root, sourceFiber);
+}
 function scheduleWorkToRoot(fiber, expirationTime) {
-  if (0 === fiber.expirationTime || fiber.expirationTime > expirationTime)
-    fiber.expirationTime = expirationTime;
+  fiber.expirationTime < expirationTime &&
+    (fiber.expirationTime = expirationTime);
   var alternate = fiber.alternate;
   null !== alternate &&
-    (0 === alternate.expirationTime ||
-      alternate.expirationTime > expirationTime) &&
+    alternate.expirationTime < expirationTime &&
     (alternate.expirationTime = expirationTime);
   var node = fiber.return,
     root = null;
-  if (null === node && 5 === fiber.tag) root = fiber.stateNode;
+  if (null === node && 3 === fiber.tag) root = fiber.stateNode;
   else
     for (; null !== node; ) {
       alternate = node.alternate;
-      if (
-        0 === node.childExpirationTime ||
-        node.childExpirationTime > expirationTime
-      )
-        node.childExpirationTime = expirationTime;
+      node.childExpirationTime < expirationTime &&
+        (node.childExpirationTime = expirationTime);
       null !== alternate &&
-        (0 === alternate.childExpirationTime ||
-          alternate.childExpirationTime > expirationTime) &&
+        alternate.childExpirationTime < expirationTime &&
         (alternate.childExpirationTime = expirationTime);
-      if (null === node.return && 5 === node.tag) {
+      if (null === node.return && 3 === node.tag) {
         root = node.stateNode;
         break;
       }
       node = node.return;
     }
-  if (null === root) return null;
-  fiber = tracing.__interactionsRef.current;
-  if (0 < fiber.size) {
+  if (
+    null !== root &&
+    ((fiber = tracing.__interactionsRef.current), 0 < fiber.size)
+  ) {
     alternate = root.pendingInteractionMap;
     var pendingInteractions = alternate.get(expirationTime);
     null != pendingInteractions
@@ -5502,46 +6410,20 @@ function scheduleWorkToRoot(fiber, expirationTime) {
 }
 function scheduleWork(fiber, expirationTime) {
   fiber = scheduleWorkToRoot(fiber, expirationTime);
-  if (null !== fiber) {
-    !isWorking &&
+  null !== fiber &&
+    (!isWorking &&
       0 !== nextRenderExpirationTime &&
-      expirationTime < nextRenderExpirationTime &&
-      resetStack();
-    markPendingPriorityLevel(fiber, expirationTime);
-    if (!isWorking || isCommitting$1 || nextRoot !== fiber) {
-      expirationTime = fiber.expirationTime;
-      if (null === fiber.nextScheduledRoot)
-        (fiber.expirationTime = expirationTime),
-          null === lastScheduledRoot
-            ? ((firstScheduledRoot = lastScheduledRoot = fiber),
-              (fiber.nextScheduledRoot = fiber))
-            : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = fiber),
-              (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot));
-      else {
-        var remainingExpirationTime = fiber.expirationTime;
-        if (
-          0 === remainingExpirationTime ||
-          expirationTime < remainingExpirationTime
-        )
-          fiber.expirationTime = expirationTime;
-      }
-      isRendering ||
-        (isBatchingUpdates
-          ? isUnbatchingUpdates &&
-            ((nextFlushedRoot = fiber),
-            (nextFlushedExpirationTime = 1),
-            performWorkOnRoot(fiber, 1, !0))
-          : 1 === expirationTime
-            ? performWork(1, null)
-            : scheduleCallbackWithExpirationTime(fiber, expirationTime));
-    }
+      expirationTime > nextRenderExpirationTime &&
+      resetStack(),
+    markPendingPriorityLevel(fiber, expirationTime),
+    (isWorking && !isCommitting$1 && nextRoot === fiber) ||
+      requestWork(fiber, fiber.expirationTime),
     nestedUpdateCount > NESTED_UPDATE_LIMIT &&
       ((nestedUpdateCount = 0),
       invariant(
         !1,
         "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-      ));
-  }
+      )));
 }
 var firstScheduledRoot = null,
   lastScheduledRoot = null,
@@ -5551,27 +6433,25 @@ var firstScheduledRoot = null,
   nextFlushedRoot = null,
   nextFlushedExpirationTime = 0,
   lowestPriorityPendingInteractiveExpirationTime = 0,
-  deadlineDidExpire = !1,
   hasUnhandledError = !1,
   unhandledError = null,
-  deadline = null,
   isBatchingUpdates = !1,
   isUnbatchingUpdates = !1,
   isBatchingInteractiveUpdates = !1,
   completedBatches = null,
   originalStartTimeMs = now$1(),
-  currentRendererTime = ((originalStartTimeMs / 10) | 0) + 2,
+  currentRendererTime = 1073741822 - ((originalStartTimeMs / 10) | 0),
   currentSchedulerTime = currentRendererTime,
   NESTED_UPDATE_LIMIT = 50,
   nestedUpdateCount = 0,
-  lastCommittedRootDuringThisBatch = null,
-  timeHeuristicForUnitOfWork = 1;
+  lastCommittedRootDuringThisBatch = null;
 function recomputeCurrentRendererTime() {
-  currentRendererTime = (((now$1() - originalStartTimeMs) / 10) | 0) + 2;
+  currentRendererTime =
+    1073741822 - (((now$1() - originalStartTimeMs) / 10) | 0);
 }
 function scheduleCallbackWithExpirationTime(root, expirationTime) {
   if (0 !== callbackExpirationTime) {
-    if (expirationTime > callbackExpirationTime) return;
+    if (expirationTime < callbackExpirationTime) return;
     null !== callbackID &&
       ((root = callbackID), (scheduledCallback = null), clearTimeout(root));
   }
@@ -5592,13 +6472,29 @@ function onSuspend(
   msUntilTimeout
 ) {
   root.expirationTime = rootExpirationTime;
-  0 < msUntilTimeout &&
-    (root.timeoutHandle = scheduleTimeout(
-      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
-      msUntilTimeout
-    ));
+  0 !== msUntilTimeout || shouldYieldToRenderer()
+    ? 0 < msUntilTimeout &&
+      (root.timeoutHandle = scheduleTimeout(
+        onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
+        msUntilTimeout
+      ))
+    : ((root.pendingCommitExpirationTime = suspendedExpirationTime),
+      (root.finishedWork = finishedWork));
+}
+function onTimeout(root, finishedWork, suspendedExpirationTime) {
+  root.pendingCommitExpirationTime = suspendedExpirationTime;
+  root.finishedWork = finishedWork;
+  recomputeCurrentRendererTime();
+  currentSchedulerTime = currentRendererTime;
+  invariant(
+    !isRendering,
+    "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method."
+  );
+  nextFlushedRoot = root;
+  nextFlushedExpirationTime = suspendedExpirationTime;
+  performWorkOnRoot(root, suspendedExpirationTime, !1);
+  performWork(1073741823, !1);
 }
-function onTimeout() {}
 function onCommit(root, expirationTime) {
   root.expirationTime = expirationTime;
   root.finishedWork = null;
@@ -5606,14 +6502,31 @@ function onCommit(root, expirationTime) {
 function requestCurrentTime() {
   if (isRendering) return currentSchedulerTime;
   findHighestPriorityRoot();
-  if (
-    0 === nextFlushedExpirationTime ||
-    1073741823 === nextFlushedExpirationTime
-  )
+  if (0 === nextFlushedExpirationTime || 1 === nextFlushedExpirationTime)
     recomputeCurrentRendererTime(),
       (currentSchedulerTime = currentRendererTime);
   return currentSchedulerTime;
 }
+function requestWork(root, expirationTime) {
+  null === root.nextScheduledRoot
+    ? ((root.expirationTime = expirationTime),
+      null === lastScheduledRoot
+        ? ((firstScheduledRoot = lastScheduledRoot = root),
+          (root.nextScheduledRoot = root))
+        : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root),
+          (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot)))
+    : expirationTime > root.expirationTime &&
+      (root.expirationTime = expirationTime);
+  isRendering ||
+    (isBatchingUpdates
+      ? isUnbatchingUpdates &&
+        ((nextFlushedRoot = root),
+        (nextFlushedExpirationTime = 1073741823),
+        performWorkOnRoot(root, 1073741823, !1))
+      : 1073741823 === expirationTime
+        ? performWork(1073741823, !1)
+        : scheduleCallbackWithExpirationTime(root, expirationTime));
+}
 function findHighestPriorityRoot() {
   var highestPriorityWork = 0,
     highestPriorityRoot = null;
@@ -5647,14 +6560,11 @@ function findHighestPriorityRoot() {
             (root.nextScheduledRoot = null);
         root = previousScheduledRoot.nextScheduledRoot;
       } else {
-        if (
-          0 === highestPriorityWork ||
-          remainingExpirationTime < highestPriorityWork
-        )
-          (highestPriorityWork = remainingExpirationTime),
-            (highestPriorityRoot = root);
+        remainingExpirationTime > highestPriorityWork &&
+          ((highestPriorityWork = remainingExpirationTime),
+          (highestPriorityRoot = root));
         if (root === lastScheduledRoot) break;
-        if (1 === highestPriorityWork) break;
+        if (1073741823 === highestPriorityWork) break;
         previousScheduledRoot = root;
         root = root.nextScheduledRoot;
       }
@@ -5662,38 +6572,44 @@ function findHighestPriorityRoot() {
   nextFlushedRoot = highestPriorityRoot;
   nextFlushedExpirationTime = highestPriorityWork;
 }
-function performAsyncWork(dl) {
-  if (dl.didTimeout && null !== firstScheduledRoot) {
-    recomputeCurrentRendererTime();
-    var root = firstScheduledRoot;
-    do {
-      var expirationTime = root.expirationTime;
-      0 !== expirationTime &&
-        currentRendererTime >= expirationTime &&
-        (root.nextExpirationTimeToWorkOn = currentRendererTime);
-      root = root.nextScheduledRoot;
-    } while (root !== firstScheduledRoot);
+var didYield = !1;
+function shouldYieldToRenderer() {
+  return didYield ? !0 : frameDeadline <= now$1() ? (didYield = !0) : !1;
+}
+function performAsyncWork() {
+  try {
+    if (!shouldYieldToRenderer() && null !== firstScheduledRoot) {
+      recomputeCurrentRendererTime();
+      var root = firstScheduledRoot;
+      do {
+        var expirationTime = root.expirationTime;
+        0 !== expirationTime &&
+          currentRendererTime <= expirationTime &&
+          (root.nextExpirationTimeToWorkOn = currentRendererTime);
+        root = root.nextScheduledRoot;
+      } while (root !== firstScheduledRoot);
+    }
+    performWork(0, !0);
+  } finally {
+    didYield = !1;
   }
-  performWork(0, dl);
 }
-function performWork(minExpirationTime, dl) {
-  deadline = dl;
+function performWork(minExpirationTime, isYieldy) {
   findHighestPriorityRoot();
-  if (null !== deadline)
+  if (isYieldy)
     for (
       recomputeCurrentRendererTime(),
         currentSchedulerTime = currentRendererTime;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime) &&
-      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime &&
+      !(didYield && currentRendererTime > nextFlushedExpirationTime);
 
     )
       performWorkOnRoot(
         nextFlushedRoot,
         nextFlushedExpirationTime,
-        currentRendererTime >= nextFlushedExpirationTime
+        currentRendererTime > nextFlushedExpirationTime
       ),
         findHighestPriorityRoot(),
         recomputeCurrentRendererTime(),
@@ -5703,29 +6619,28 @@ function performWork(minExpirationTime, dl) {
       ;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime;
 
     )
-      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !0),
+      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !1),
         findHighestPriorityRoot();
-  null !== deadline && ((callbackExpirationTime = 0), (callbackID = null));
+  isYieldy && ((callbackExpirationTime = 0), (callbackID = null));
   0 !== nextFlushedExpirationTime &&
     scheduleCallbackWithExpirationTime(
       nextFlushedRoot,
       nextFlushedExpirationTime
     );
-  deadline = null;
-  deadlineDidExpire = !1;
   nestedUpdateCount = 0;
   lastCommittedRootDuringThisBatch = null;
   if (null !== completedBatches)
     for (
-      minExpirationTime = completedBatches, completedBatches = null, dl = 0;
-      dl < minExpirationTime.length;
-      dl++
+      minExpirationTime = completedBatches,
+        completedBatches = null,
+        isYieldy = 0;
+      isYieldy < minExpirationTime.length;
+      isYieldy++
     ) {
-      var batch = minExpirationTime[dl];
+      var batch = minExpirationTime[isYieldy];
       try {
         batch._onComplete();
       } catch (error) {
@@ -5739,39 +6654,45 @@ function performWork(minExpirationTime, dl) {
     (hasUnhandledError = !1),
     minExpirationTime);
 }
-function performWorkOnRoot(root, expirationTime, isExpired) {
+function performWorkOnRoot(root, expirationTime, isYieldy) {
   invariant(
     !isRendering,
     "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
   isRendering = !0;
-  if (null === deadline || isExpired) {
-    var finishedWork = root.finishedWork;
-    null !== finishedWork
-      ? completeRoot$1(root, finishedWork, expirationTime)
+  if (isYieldy) {
+    var _finishedWork = root.finishedWork;
+    null !== _finishedWork
+      ? completeRoot$1(root, _finishedWork, expirationTime)
       : ((root.finishedWork = null),
-        renderRoot(root, !1, isExpired),
-        (finishedWork = root.finishedWork),
-        null !== finishedWork &&
-          completeRoot$1(root, finishedWork, expirationTime));
+        (_finishedWork = root.timeoutHandle),
+        -1 !== _finishedWork &&
+          ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+        renderRoot(root, isYieldy),
+        (_finishedWork = root.finishedWork),
+        null !== _finishedWork &&
+          (shouldYieldToRenderer()
+            ? (root.finishedWork = _finishedWork)
+            : completeRoot$1(root, _finishedWork, expirationTime)));
   } else
-    (finishedWork = root.finishedWork),
-      null !== finishedWork
-        ? completeRoot$1(root, finishedWork, expirationTime)
+    (_finishedWork = root.finishedWork),
+      null !== _finishedWork
+        ? completeRoot$1(root, _finishedWork, expirationTime)
         : ((root.finishedWork = null),
-          renderRoot(root, !0, isExpired),
-          (finishedWork = root.finishedWork),
-          null !== finishedWork &&
-            (shouldYield()
-              ? (root.finishedWork = finishedWork)
-              : completeRoot$1(root, finishedWork, expirationTime)));
+          (_finishedWork = root.timeoutHandle),
+          -1 !== _finishedWork &&
+            ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+          renderRoot(root, isYieldy),
+          (_finishedWork = root.finishedWork),
+          null !== _finishedWork &&
+            completeRoot$1(root, _finishedWork, expirationTime));
   isRendering = !1;
 }
 function completeRoot$1(root, finishedWork, expirationTime) {
   var firstBatch = root.firstBatch;
   if (
     null !== firstBatch &&
-    firstBatch._expirationTime <= expirationTime &&
+    firstBatch._expirationTime >= expirationTime &&
     (null === completedBatches
       ? (completedBatches = [firstBatch])
       : completedBatches.push(firstBatch),
@@ -5787,13 +6708,6 @@ function completeRoot$1(root, finishedWork, expirationTime) {
     : ((lastCommittedRootDuringThisBatch = root), (nestedUpdateCount = 0));
   commitRoot(root, finishedWork);
 }
-function shouldYield() {
-  return deadlineDidExpire
-    ? !0
-    : null === deadline || deadline.timeRemaining() > timeHeuristicForUnitOfWork
-      ? !1
-      : (deadlineDidExpire = !0);
-}
 function onUncaughtError(error) {
   invariant(
     null !== nextFlushedRoot,
@@ -5802,55 +6716,6 @@ function onUncaughtError(error) {
   nextFlushedRoot.expirationTime = 0;
   hasUnhandledError || ((hasUnhandledError = !0), (unhandledError = error));
 }
-function getContextForSubtree(parentComponent) {
-  if (!parentComponent) return emptyContextObject;
-  parentComponent = parentComponent._reactInternalFiber;
-  a: {
-    invariant(
-      2 === isFiberMountedImpl(parentComponent) &&
-        (2 === parentComponent.tag || 3 === parentComponent.tag),
-      "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-    );
-    var parentContext = parentComponent;
-    do {
-      switch (parentContext.tag) {
-        case 5:
-          parentContext = parentContext.stateNode.context;
-          break a;
-        case 2:
-          if (isContextProvider(parentContext.type)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-          break;
-        case 3:
-          if (isContextProvider(parentContext.type._reactResult)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-      }
-      parentContext = parentContext.return;
-    } while (null !== parentContext);
-    invariant(
-      !1,
-      "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-    );
-    parentContext = void 0;
-  }
-  if (2 === parentComponent.tag) {
-    var Component = parentComponent.type;
-    if (isContextProvider(Component))
-      return processChildContext(parentComponent, Component, parentContext);
-  } else if (
-    3 === parentComponent.tag &&
-    ((Component = parentComponent.type._reactResult),
-    isContextProvider(Component))
-  )
-    return processChildContext(parentComponent, Component, parentContext);
-  return parentContext;
-}
 function findHostInstance$1(component) {
   var fiber = component._reactInternalFiber;
   void 0 === fiber &&
@@ -5869,7 +6734,48 @@ function updateContainer(element, container, parentComponent, callback) {
     currentTime = requestCurrentTime();
   current$$1 = computeExpirationForFiber(currentTime, current$$1);
   currentTime = container.current;
-  parentComponent = getContextForSubtree(parentComponent);
+  a: if (parentComponent) {
+    parentComponent = parentComponent._reactInternalFiber;
+    b: {
+      invariant(
+        2 === isFiberMountedImpl(parentComponent) && 1 === parentComponent.tag,
+        "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
+      );
+      var parentContext = parentComponent;
+      do {
+        switch (parentContext.tag) {
+          case 3:
+            parentContext = parentContext.stateNode.context;
+            break b;
+          case 1:
+            if (isContextProvider(parentContext.type)) {
+              parentContext =
+                parentContext.stateNode
+                  .__reactInternalMemoizedMergedChildContext;
+              break b;
+            }
+        }
+        parentContext = parentContext.return;
+      } while (null !== parentContext);
+      invariant(
+        !1,
+        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
+      );
+      parentContext = void 0;
+    }
+    if (1 === parentComponent.tag) {
+      var Component = parentComponent.type;
+      if (isContextProvider(Component)) {
+        parentComponent = processChildContext(
+          parentComponent,
+          Component,
+          parentContext
+        );
+        break a;
+      }
+    }
+    parentComponent = parentContext;
+  } else parentComponent = emptyContextObject;
   null === container.context
     ? (container.context = parentComponent)
     : (container.pendingContext = parentComponent);
@@ -5878,6 +6784,7 @@ function updateContainer(element, container, parentComponent, callback) {
   callback.payload = { element: element };
   container = void 0 === container ? null : container;
   null !== container && (callback.callback = container);
+  flushPassiveEffects();
   enqueueUpdate(currentTime, callback);
   scheduleWork(currentTime, current$$1);
   return current$$1;
@@ -5937,13 +6844,13 @@ _batchedUpdatesImpl = function(fn, a) {
   } finally {
     (isBatchingUpdates = previousIsBatchingUpdates) ||
       isRendering ||
-      performWork(1, null);
+      performWork(1073741823, !1);
   }
 };
 _flushInteractiveUpdatesImpl = function() {
   isRendering ||
     0 === lowestPriorityPendingInteractiveExpirationTime ||
-    (performWork(lowestPriorityPendingInteractiveExpirationTime, null),
+    (performWork(lowestPriorityPendingInteractiveExpirationTime, !1),
     (lowestPriorityPendingInteractiveExpirationTime = 0));
 };
 var roots = new Map(),
@@ -6025,7 +6932,7 @@ var roots = new Map(),
       if (!root) {
         root = 0;
         isDevToolsPresent && (root |= 4);
-        root = new FiberNode(5, null, null, root);
+        root = createFiber(3, null, null, root);
         var root$jscomp$0 = {
           current: root,
           containerInfo: containerTag,
@@ -6056,7 +6963,7 @@ var roots = new Map(),
       updateContainer(element, root, null, callback);
       a: if (((element = root.current), element.child))
         switch (element.child.tag) {
-          case 7:
+          case 5:
             element = element.child.stateNode.canonical;
             break a;
           default:
@@ -6153,7 +7060,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromInstance,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.5.2",
+  version: "16.6.1",
   rendererPackageName: "react-native-renderer"
 });
 var ReactFabric$2 = { default: ReactFabric },
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js
@@ -27,6 +27,7 @@ var flattenStyle = require("flattenStyle");
 var TextInputState = require("TextInputState");
 var checkPropTypes = require("prop-types/checkPropTypes");
 var tracing = require("scheduler/tracing");
+var scheduler = require("scheduler");
 var ExceptionsManager = require("ExceptionsManager");
 
 /**
@@ -627,67 +628,26 @@ var warningWithoutStack = function() {};
       return;
     }
     if (typeof console !== "undefined") {
-      var _args$map = args.map(function(item) {
-          return "" + item;
-        }),
-        a = _args$map[0],
-        b = _args$map[1],
-        c = _args$map[2],
-        d = _args$map[3],
-        e = _args$map[4],
-        f = _args$map[5],
-        g = _args$map[6],
-        h = _args$map[7];
-
-      var message = "Warning: " + format;
-
-      // We intentionally don't use spread (or .apply) because it breaks IE9:
-      // https://github.com/facebook/react/issues/13610
-      switch (args.length) {
-        case 0:
-          console.error(message);
-          break;
-        case 1:
-          console.error(message, a);
-          break;
-        case 2:
-          console.error(message, a, b);
-          break;
-        case 3:
-          console.error(message, a, b, c);
-          break;
-        case 4:
-          console.error(message, a, b, c, d);
-          break;
-        case 5:
-          console.error(message, a, b, c, d, e);
-          break;
-        case 6:
-          console.error(message, a, b, c, d, e, f);
-          break;
-        case 7:
-          console.error(message, a, b, c, d, e, f, g);
-          break;
-        case 8:
-          console.error(message, a, b, c, d, e, f, g, h);
-          break;
-        default:
-          throw new Error(
-            "warningWithoutStack() currently supports at most 8 arguments."
-          );
-      }
+      var argsWithFormat = args.map(function(item) {
+        return "" + item;
+      });
+      argsWithFormat.unshift("Warning: " + format);
+
+      // We intentionally don't use spread (or .apply) directly because it
+      // breaks IE9: https://github.com/facebook/react/issues/13610
+      Function.prototype.apply.call(console.error, console, argsWithFormat);
     }
     try {
       // --- Welcome to debugging React ---
       // This error was thrown as a convenience so that you can use this stack
       // to find the callsite that caused this warning to fire.
       var argIndex = 0;
-      var _message =
+      var message =
         "Warning: " +
         format.replace(/%s/g, function() {
           return args[argIndex++];
         });
-      throw new Error(_message);
+      throw new Error(message);
     } catch (x) {}
   };
 }
@@ -746,11 +706,10 @@ var validateEventDispatches = void 0;
 /**
  * Dispatch the event to the listener.
  * @param {SyntheticEvent} event SyntheticEvent to handle
- * @param {boolean} simulated If the event is simulated (changes exn behavior)
  * @param {function} listener Application-level callback
  * @param {*} inst Internal component instance
  */
-function executeDispatch(event, simulated, listener, inst) {
+function executeDispatch(event, listener, inst) {
   var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
   invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
@@ -760,7 +719,7 @@ function executeDispatch(event, simulated, listener, inst) {
 /**
  * Standard/simple iteration through an event's collected dispatches.
  */
-function executeDispatchesInOrder(event, simulated) {
+function executeDispatchesInOrder(event) {
   var dispatchListeners = event._dispatchListeners;
   var dispatchInstances = event._dispatchInstances;
   {
@@ -772,15 +731,10 @@ function executeDispatchesInOrder(event, simulated) {
         break;
       }
       // Listeners and Instances are two parallel arrays that are always in sync.
-      executeDispatch(
-        event,
-        simulated,
-        dispatchListeners[i],
-        dispatchInstances[i]
-      );
+      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
     }
   } else if (dispatchListeners) {
-    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
+    executeDispatch(event, dispatchListeners, dispatchInstances);
   }
   event._dispatchListeners = null;
   event._dispatchInstances = null;
@@ -933,23 +887,19 @@ var eventQueue = null;
  * Dispatches an event and releases it back into the pool, unless persistent.
  *
  * @param {?object} event Synthetic event to be dispatched.
- * @param {boolean} simulated If the event is simulated (changes exn behavior)
  * @private
  */
-var executeDispatchesAndRelease = function(event, simulated) {
+var executeDispatchesAndRelease = function(event) {
   if (event) {
-    executeDispatchesInOrder(event, simulated);
+    executeDispatchesInOrder(event);
 
     if (!event.isPersistent()) {
       event.constructor.release(event);
     }
   }
 };
-var executeDispatchesAndReleaseSimulated = function(e) {
-  return executeDispatchesAndRelease(e, true);
-};
 var executeDispatchesAndReleaseTopLevel = function(e) {
-  return executeDispatchesAndRelease(e, false);
+  return executeDispatchesAndRelease(e);
 };
 
 function isInteractive(tag) {
@@ -1083,7 +1033,7 @@ function extractEvents(
   return events;
 }
 
-function runEventsInBatch(events, simulated) {
+function runEventsInBatch(events) {
   if (events !== null) {
     eventQueue = accumulateInto(eventQueue, events);
   }
@@ -1097,17 +1047,7 @@ function runEventsInBatch(events, simulated) {
     return;
   }
 
-  if (simulated) {
-    forEachAccumulated(
-      processingEventQueue,
-      executeDispatchesAndReleaseSimulated
-    );
-  } else {
-    forEachAccumulated(
-      processingEventQueue,
-      executeDispatchesAndReleaseTopLevel
-    );
-  }
+  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
   invariant(
     !eventQueue,
     "processEventQueue(): Additional events were enqueued while processing " +
@@ -1129,28 +1069,27 @@ function runExtractedEventsInBatch(
     nativeEvent,
     nativeEventTarget
   );
-  runEventsInBatch(events, false);
+  runEventsInBatch(events);
 }
 
 var FunctionComponent = 0;
-var FunctionComponentLazy = 1;
-var ClassComponent = 2;
-var ClassComponentLazy = 3;
-var IndeterminateComponent = 4; // Before we know whether it is function or class
-var HostRoot = 5; // Root of a host tree. Could be nested inside another node.
-var HostPortal = 6; // A subtree. Could be an entry point to a different renderer.
-var HostComponent = 7;
-var HostText = 8;
-var Fragment = 9;
-var Mode = 10;
-var ContextConsumer = 11;
-var ContextProvider = 12;
-var ForwardRef = 13;
-var ForwardRefLazy = 14;
-var Profiler = 15;
-var PlaceholderComponent = 16;
-var PureComponent = 17;
-var PureComponentLazy = 18;
+var ClassComponent = 1;
+var IndeterminateComponent = 2; // Before we know whether it is function or class
+var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
+var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
+var HostComponent = 5;
+var HostText = 6;
+var Fragment = 7;
+var Mode = 8;
+var ContextConsumer = 9;
+var ContextProvider = 10;
+var ForwardRef = 11;
+var Profiler = 12;
+var SuspenseComponent = 13;
+var MemoComponent = 14;
+var SimpleMemoComponent = 15;
+var LazyComponent = 16;
+var IncompleteClassComponent = 17;
 
 function getParent(inst) {
   do {
@@ -2923,16 +2862,16 @@ var REACT_STRICT_MODE_TYPE = hasSymbol
 var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
 var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
 var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace;
+
 var REACT_CONCURRENT_MODE_TYPE = hasSymbol
   ? Symbol.for("react.concurrent_mode")
   : 0xeacf;
 var REACT_FORWARD_REF_TYPE = hasSymbol
   ? Symbol.for("react.forward_ref")
   : 0xead0;
-var REACT_PLACEHOLDER_TYPE = hasSymbol
-  ? Symbol.for("react.placeholder")
-  : 0xead1;
-var REACT_PURE_TYPE = hasSymbol ? Symbol.for("react.pure") : 0xead3;
+var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
+var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
+var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
 
 var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
 var FAUX_ITERATOR_SYMBOL = "@@iterator";
@@ -2954,12 +2893,16 @@ var Pending = 0;
 var Resolved = 1;
 var Rejected = 2;
 
-function getResultFromResolvedThenable(thenable) {
-  return thenable._reactResult;
+function refineResolvedLazyComponent(lazyComponent) {
+  return lazyComponent._status === Resolved ? lazyComponent._result : null;
 }
 
-function refineResolvedThenable(thenable) {
-  return thenable._reactStatus === Resolved ? thenable._reactResult : null;
+function getWrappedName(outerType, innerType, wrapperName) {
+  var functionName = innerType.displayName || innerType.name || "";
+  return (
+    outerType.displayName ||
+    (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName)
+  );
 }
 
 function getComponentName(type) {
@@ -2993,8 +2936,8 @@ function getComponentName(type) {
       return "Profiler";
     case REACT_STRICT_MODE_TYPE:
       return "StrictMode";
-    case REACT_PLACEHOLDER_TYPE:
-      return "Placeholder";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
   }
   if (typeof type === "object") {
     switch (type.$$typeof) {
@@ -3003,20 +2946,15 @@ function getComponentName(type) {
       case REACT_PROVIDER_TYPE:
         return "Context.Provider";
       case REACT_FORWARD_REF_TYPE:
-        var renderFn = type.render;
-        var functionName = renderFn.displayName || renderFn.name || "";
-        return (
-          type.displayName ||
-          (functionName !== ""
-            ? "ForwardRef(" + functionName + ")"
-            : "ForwardRef")
-        );
-    }
-    if (typeof type.then === "function") {
-      var thenable = type;
-      var resolvedThenable = refineResolvedThenable(thenable);
-      if (resolvedThenable) {
-        return getComponentName(resolvedThenable);
+        return getWrappedName(type, type.render, "ForwardRef");
+      case REACT_MEMO_TYPE:
+        return getComponentName(type.type);
+      case REACT_LAZY_TYPE: {
+        var thenable = type;
+        var resolvedThenable = refineResolvedLazyComponent(thenable);
+        if (resolvedThenable) {
+          return getComponentName(resolvedThenable);
+        }
       }
     }
   }
@@ -3037,15 +2975,16 @@ var Callback = /*              */ 32;
 var DidCapture = /*            */ 64;
 var Ref = /*                   */ 128;
 var Snapshot = /*              */ 256;
+var Passive = /*               */ 512;
 
-// Update & Callback & Ref & Snapshot
-var LifecycleEffectMask = /*   */ 420;
+// Passive & Update & Callback & Ref & Snapshot
+var LifecycleEffectMask = /*   */ 932;
 
 // Union of all host effects
-var HostEffectMask = /*        */ 511;
+var HostEffectMask = /*        */ 1023;
 
-var Incomplete = /*            */ 512;
-var ShouldCapture = /*         */ 1024;
+var Incomplete = /*            */ 1024;
+var ShouldCapture = /*         */ 2048;
 
 var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
 
@@ -3089,10 +3028,7 @@ function isFiberMounted(fiber) {
 function isMounted(component) {
   {
     var owner = ReactCurrentOwner$1.current;
-    if (
-      owner !== null &&
-      (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)
-    ) {
+    if (owner !== null && owner.tag === ClassComponent) {
       var ownerFiber = owner;
       var instance = ownerFiber.stateNode;
       !instance._warnedAboutRefsInRender
@@ -3887,13 +3823,6 @@ var now$1 = hasNativePerformanceNow
 var scheduledCallback = null;
 var frameDeadline = 0;
 
-var frameDeadlineObject = {
-  timeRemaining: function() {
-    return frameDeadline - now$1();
-  },
-  didTimeout: false
-};
-
 function setTimeoutCallback() {
   // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.
   // React API probably changing to boolean rather than time remaining.
@@ -3904,7 +3833,7 @@ function setTimeoutCallback() {
   var callback = scheduledCallback;
   scheduledCallback = null;
   if (callback !== null) {
-    callback(frameDeadlineObject);
+    callback();
   }
 }
 
@@ -3923,6 +3852,10 @@ function cancelDeferredCallback$1(callbackID) {
   clearTimeout(callbackID); // Timeouts are always numbers on RN
 }
 
+function shouldYield$1() {
+  return frameDeadline <= now$1();
+}
+
 // Renderers that don't support persistence
 // can re-export everything from this module.
 
@@ -3942,6 +3875,9 @@ var createContainerChildSet = shim;
 var appendChildToContainerChildSet = shim;
 var finalizeContainerChildren = shim;
 var replaceContainerChildren = shim;
+var cloneHiddenInstance = shim;
+var cloneUnhiddenInstance = shim;
+var createHiddenTextInstance = shim;
 
 // Renderers that don't support hydration
 // can re-export everything from this module.
@@ -3949,7 +3885,7 @@ var replaceContainerChildren = shim;
 function shim$1() {
   invariant(
     false,
-    "The current renderer does not support hyration. " +
+    "The current renderer does not support hydration. " +
       "This error is likely caused by a bug in React. " +
       "Please file an issue."
   );
@@ -4150,6 +4086,7 @@ var now = now$1;
 var isPrimaryRenderer = true;
 var scheduleDeferredCallback = scheduleDeferredCallback$1;
 var cancelDeferredCallback = cancelDeferredCallback$1;
+var shouldYield = shouldYield$1;
 
 var scheduleTimeout = setTimeout;
 var cancelTimeout = clearTimeout;
@@ -4327,6 +4264,41 @@ function resetTextContent(instance) {
   // Noop
 }
 
+function hideInstance(instance) {
+  var viewConfig = instance.viewConfig;
+  var updatePayload = create(
+    { style: { display: "none" } },
+    viewConfig.validAttributes
+  );
+  UIManager.updateView(
+    instance._nativeTag,
+    viewConfig.uiViewClassName,
+    updatePayload
+  );
+}
+
+function hideTextInstance(textInstance) {
+  throw new Error("Not yet implemented.");
+}
+
+function unhideInstance(instance, props) {
+  var viewConfig = instance.viewConfig;
+  var updatePayload = diff(
+    Object.assign({}, props, { style: [props.style, { display: "none" }] }),
+    props,
+    viewConfig.validAttributes
+  );
+  UIManager.updateView(
+    instance._nativeTag,
+    viewConfig.uiViewClassName,
+    updatePayload
+  );
+}
+
+function unhideTextInstance(textInstance, text) {
+  throw new Error("Not yet implemented.");
+}
+
 var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 
 var describeComponentFrame = function(name, source, ownerName) {
@@ -4360,12 +4332,12 @@ var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
 function describeFiber(fiber) {
   switch (fiber.tag) {
     case IndeterminateComponent:
+    case LazyComponent:
     case FunctionComponent:
-    case FunctionComponentLazy:
     case ClassComponent:
-    case ClassComponentLazy:
     case HostComponent:
     case Mode:
+    case SuspenseComponent:
       var owner = fiber._debugOwner;
       var source = fiber._debugSource;
       var name = getComponentName(fiber.type);
@@ -4441,7 +4413,7 @@ function setCurrentPhase(lifeCyclePhase) {
 
 var debugRenderPhaseSideEffects = false;
 var debugRenderPhaseSideEffectsForStrictMode = false;
-var enableSuspense = false;
+var enableHooks = true;
 var enableUserTimingAPI = true;
 var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
 var warnAboutDeprecatedLifecycles = false;
@@ -4720,7 +4692,10 @@ function stopFailedWorkTimer(fiber) {
       return;
     }
     fiber._debugIsCurrentlyTiming = false;
-    var warning = "An error was thrown inside this error boundary";
+    var warning =
+      fiber.tag === SuspenseComponent
+        ? "Rendering was suspended"
+        : "An error was thrown inside this error boundary";
     endFiberMark(fiber, null, warning);
   }
 }
@@ -5211,8 +5186,7 @@ function findCurrentUnmaskedContext(fiber) {
   // Currently this is only used with renderSubtreeIntoContainer; not sure if it
   // makes sense elsewhere
   invariant(
-    isFiberMounted(fiber) &&
-      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy),
+    isFiberMounted(fiber) && fiber.tag === ClassComponent,
     "Expected subtree parent to be a mounted class component. " +
       "This error is likely caused by a bug in React. Please file an issue."
   );
@@ -5229,13 +5203,6 @@ function findCurrentUnmaskedContext(fiber) {
         }
         break;
       }
-      case ClassComponentLazy: {
-        var _Component = getResultFromResolvedThenable(node.type);
-        if (isContextProvider(_Component)) {
-          return node.stateNode.__reactInternalMemoizedMergedChildContext;
-        }
-        break;
-      }
     }
     node = node.return;
   } while (node !== null);
@@ -5334,20 +5301,20 @@ function onCommitUnmount(fiber) {
 var maxSigned31BitInt = 1073741823;
 
 var NoWork = 0;
-var Sync = 1;
-var Never = maxSigned31BitInt;
+var Never = 1;
+var Sync = maxSigned31BitInt;
 
 var UNIT_SIZE = 10;
-var MAGIC_NUMBER_OFFSET = 2;
+var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;
 
 // 1 unit of expiration time represents 10ms.
 function msToExpirationTime(ms) {
   // Always add an offset so that we don't clash with the magic number for NoWork.
-  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;
+  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
 }
 
 function expirationTimeToMs(expirationTime) {
-  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
+  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
 }
 
 function ceiling(num, precision) {
@@ -5356,9 +5323,9 @@ function ceiling(num, precision) {
 
 function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
   return (
-    MAGIC_NUMBER_OFFSET +
+    MAGIC_NUMBER_OFFSET -
     ceiling(
-      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,
+      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
       bucketSizeMs / UNIT_SIZE
     )
   );
@@ -5434,6 +5401,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   // Instance
   this.tag = tag;
   this.key = key;
+  this.elementType = null;
   this.type = null;
   this.stateNode = null;
 
@@ -5506,18 +5474,24 @@ function shouldConstruct(Component) {
   return !!(prototype && prototype.isReactComponent);
 }
 
-function resolveLazyComponentTag(fiber, Component) {
+function isSimpleFunctionComponent(type) {
+  return (
+    typeof type === "function" &&
+    !shouldConstruct(type) &&
+    type.defaultProps === undefined
+  );
+}
+
+function resolveLazyComponentTag(Component) {
   if (typeof Component === "function") {
-    return shouldConstruct(Component)
-      ? ClassComponentLazy
-      : FunctionComponentLazy;
+    return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
   } else if (Component !== undefined && Component !== null) {
     var $$typeof = Component.$$typeof;
     if ($$typeof === REACT_FORWARD_REF_TYPE) {
-      return ForwardRefLazy;
+      return ForwardRef;
     }
-    if ($$typeof === REACT_PURE_TYPE) {
-      return PureComponentLazy;
+    if ($$typeof === REACT_MEMO_TYPE) {
+      return MemoComponent;
     }
   }
   return IndeterminateComponent;
@@ -5538,6 +5512,7 @@ function createWorkInProgress(current, pendingProps, expirationTime) {
       current.key,
       current.mode
     );
+    workInProgress.elementType = current.elementType;
     workInProgress.type = current.type;
     workInProgress.stateNode = current.stateNode;
 
@@ -5607,20 +5582,23 @@ function createHostRootFiber(isConcurrent) {
   return createFiber(HostRoot, null, null, mode);
 }
 
-function createFiberFromElement(element, mode, expirationTime) {
-  var owner = null;
-  {
-    owner = element._owner;
-  }
-
+function createFiberFromTypeAndProps(
+  type, // React$ElementType
+  key,
+  pendingProps,
+  owner,
+  mode,
+  expirationTime
+) {
   var fiber = void 0;
-  var type = element.type;
-  var key = element.key;
-  var pendingProps = element.props;
 
-  var fiberTag = void 0;
+  var fiberTag = IndeterminateComponent;
+  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
+  var resolvedType = type;
   if (typeof type === "function") {
-    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;
+    if (shouldConstruct(type)) {
+      fiberTag = ClassComponent;
+    }
   } else if (typeof type === "string") {
     fiberTag = HostComponent;
   } else {
@@ -5633,18 +5611,23 @@ function createFiberFromElement(element, mode, expirationTime) {
           key
         );
       case REACT_CONCURRENT_MODE_TYPE:
-        fiberTag = Mode;
-        mode |= ConcurrentMode | StrictMode;
-        break;
+        return createFiberFromMode(
+          pendingProps,
+          mode | ConcurrentMode | StrictMode,
+          expirationTime,
+          key
+        );
       case REACT_STRICT_MODE_TYPE:
-        fiberTag = Mode;
-        mode |= StrictMode;
-        break;
+        return createFiberFromMode(
+          pendingProps,
+          mode | StrictMode,
+          expirationTime,
+          key
+        );
       case REACT_PROFILER_TYPE:
         return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
-      case REACT_PLACEHOLDER_TYPE:
-        fiberTag = PlaceholderComponent;
-        break;
+      case REACT_SUSPENSE_TYPE:
+        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
       default: {
         if (typeof type === "object" && type !== null) {
           switch (type.$$typeof) {
@@ -5658,15 +5641,13 @@ function createFiberFromElement(element, mode, expirationTime) {
             case REACT_FORWARD_REF_TYPE:
               fiberTag = ForwardRef;
               break getTag;
-            case REACT_PURE_TYPE:
-              fiberTag = PureComponent;
+            case REACT_MEMO_TYPE:
+              fiberTag = MemoComponent;
+              break getTag;
+            case REACT_LAZY_TYPE:
+              fiberTag = LazyComponent;
+              resolvedType = null;
               break getTag;
-            default: {
-              if (typeof type.then === "function") {
-                fiberTag = IndeterminateComponent;
-                break getTag;
-              }
-            }
           }
         }
         var info = "";
@@ -5700,14 +5681,33 @@ function createFiberFromElement(element, mode, expirationTime) {
   }
 
   fiber = createFiber(fiberTag, pendingProps, key, mode);
-  fiber.type = type;
+  fiber.elementType = type;
+  fiber.type = resolvedType;
   fiber.expirationTime = expirationTime;
 
+  return fiber;
+}
+
+function createFiberFromElement(element, mode, expirationTime) {
+  var owner = null;
+  {
+    owner = element._owner;
+  }
+  var type = element.type;
+  var key = element.key;
+  var pendingProps = element.props;
+  var fiber = createFiberFromTypeAndProps(
+    type,
+    key,
+    pendingProps,
+    owner,
+    mode,
+    expirationTime
+  );
   {
     fiber._debugSource = element._source;
     fiber._debugOwner = element._owner;
   }
-
   return fiber;
 }
 
@@ -5731,12 +5731,41 @@ function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
   }
 
   var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
+  // TODO: The Profiler fiber shouldn't have a type. It has a tag.
+  fiber.elementType = REACT_PROFILER_TYPE;
   fiber.type = REACT_PROFILER_TYPE;
   fiber.expirationTime = expirationTime;
 
   return fiber;
 }
 
+function createFiberFromMode(pendingProps, mode, expirationTime, key) {
+  var fiber = createFiber(Mode, pendingProps, key, mode);
+
+  // TODO: The Mode fiber shouldn't have a type. It has a tag.
+  var type =
+    (mode & ConcurrentMode) === NoContext
+      ? REACT_STRICT_MODE_TYPE
+      : REACT_CONCURRENT_MODE_TYPE;
+  fiber.elementType = type;
+  fiber.type = type;
+
+  fiber.expirationTime = expirationTime;
+  return fiber;
+}
+
+function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
+  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
+
+  // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
+  var type = REACT_SUSPENSE_TYPE;
+  fiber.elementType = type;
+  fiber.type = type;
+
+  fiber.expirationTime = expirationTime;
+  return fiber;
+}
+
 function createFiberFromText(content, mode, expirationTime) {
   var fiber = createFiber(HostText, content, null, mode);
   fiber.expirationTime = expirationTime;
@@ -5745,6 +5774,8 @@ function createFiberFromText(content, mode, expirationTime) {
 
 function createFiberFromHostInstanceForDeletion() {
   var fiber = createFiber(HostComponent, null, null, NoContext);
+  // TODO: These should not need a type.
+  fiber.elementType = "DELETED";
   fiber.type = "DELETED";
   return fiber;
 }
@@ -5777,6 +5808,7 @@ function assignFiberPropertiesInDEV(target, source) {
 
   target.tag = source.tag;
   target.key = source.key;
+  target.elementType = source.elementType;
   target.type = source.type;
   target.stateNode = source.stateNode;
   target.return = source.return;
@@ -6319,12 +6351,12 @@ function markPendingPriorityLevel(root, expirationTime) {
     // No other pending updates.
     root.earliestPendingTime = root.latestPendingTime = expirationTime;
   } else {
-    if (earliestPendingTime > expirationTime) {
+    if (earliestPendingTime < expirationTime) {
       // This is the earliest pending update.
       root.earliestPendingTime = expirationTime;
     } else {
       var latestPendingTime = root.latestPendingTime;
-      if (latestPendingTime < expirationTime) {
+      if (latestPendingTime > expirationTime) {
         // This is the latest pending update
         root.latestPendingTime = expirationTime;
       }
@@ -6350,12 +6382,12 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
   // Let's see if the previous latest known pending level was just flushed.
   var latestPendingTime = root.latestPendingTime;
   if (latestPendingTime !== NoWork) {
-    if (latestPendingTime < earliestRemainingTime) {
+    if (latestPendingTime > earliestRemainingTime) {
       // We've flushed all the known pending levels.
       root.earliestPendingTime = root.latestPendingTime = NoWork;
     } else {
       var earliestPendingTime = root.earliestPendingTime;
-      if (earliestPendingTime < earliestRemainingTime) {
+      if (earliestPendingTime > earliestRemainingTime) {
         // We've flushed the earliest known pending level. Set this to the
         // latest pending time.
         root.earliestPendingTime = root.latestPendingTime;
@@ -6377,7 +6409,7 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
   }
 
   var latestSuspendedTime = root.latestSuspendedTime;
-  if (earliestRemainingTime > latestSuspendedTime) {
+  if (earliestRemainingTime < latestSuspendedTime) {
     // The earliest remaining level is later than all the suspended work. That
     // means we've flushed all the suspended work.
     root.earliestSuspendedTime = NoWork;
@@ -6391,7 +6423,7 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
     return;
   }
 
-  if (earliestRemainingTime < earliestSuspendedTime) {
+  if (earliestRemainingTime > earliestSuspendedTime) {
     // The earliest remaining time is earlier than all the suspended work.
     // Treat it as a pending update.
     markPendingPriorityLevel(root, earliestRemainingTime);
@@ -6410,10 +6442,10 @@ function hasLowerPriorityWork(root, erroredExpirationTime) {
   var latestPingedTime = root.latestPingedTime;
   return (
     (latestPendingTime !== NoWork &&
-      latestPendingTime > erroredExpirationTime) ||
+      latestPendingTime < erroredExpirationTime) ||
     (latestSuspendedTime !== NoWork &&
-      latestSuspendedTime > erroredExpirationTime) ||
-    (latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime)
+      latestSuspendedTime < erroredExpirationTime) ||
+    (latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime)
   );
 }
 
@@ -6422,8 +6454,8 @@ function isPriorityLevelSuspended(root, expirationTime) {
   var latestSuspendedTime = root.latestSuspendedTime;
   return (
     earliestSuspendedTime !== NoWork &&
-    expirationTime >= earliestSuspendedTime &&
-    expirationTime <= latestSuspendedTime
+    expirationTime <= earliestSuspendedTime &&
+    expirationTime >= latestSuspendedTime
   );
 }
 
@@ -6456,10 +6488,10 @@ function markSuspendedPriorityLevel(root, suspendedTime) {
     // No other suspended levels.
     root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
   } else {
-    if (earliestSuspendedTime > suspendedTime) {
+    if (earliestSuspendedTime < suspendedTime) {
       // This is the earliest suspended level.
       root.earliestSuspendedTime = suspendedTime;
-    } else if (latestSuspendedTime < suspendedTime) {
+    } else if (latestSuspendedTime > suspendedTime) {
       // This is the latest suspended level
       root.latestSuspendedTime = suspendedTime;
     }
@@ -6475,7 +6507,7 @@ function markPingedPriorityLevel(root, pingedTime) {
   // is thrown out and not reused during the restarted render. One way to
   // invalidate the progressed work is to restart at expirationTime + 1.
   var latestPingedTime = root.latestPingedTime;
-  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {
+  if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
     root.latestPingedTime = pingedTime;
   }
   findNextExpirationTimeToWorkOn(pingedTime, root);
@@ -6485,7 +6517,7 @@ function clearPing(root, completedTime) {
   // TODO: Track whether the root was pinged during the render phase. If so,
   // we need to make sure we don't lose track of it.
   var latestPingedTime = root.latestPingedTime;
-  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {
+  if (latestPingedTime !== NoWork && latestPingedTime >= completedTime) {
     root.latestPingedTime = NoWork;
   }
 }
@@ -6495,18 +6527,10 @@ function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
 
   var earliestPendingTime = root.earliestPendingTime;
   var earliestSuspendedTime = root.earliestSuspendedTime;
-  if (
-    earliestExpirationTime === NoWork ||
-    (earliestPendingTime !== NoWork &&
-      earliestPendingTime < earliestExpirationTime)
-  ) {
+  if (earliestPendingTime > earliestExpirationTime) {
     earliestExpirationTime = earliestPendingTime;
   }
-  if (
-    earliestExpirationTime === NoWork ||
-    (earliestSuspendedTime !== NoWork &&
-      earliestSuspendedTime < earliestExpirationTime)
-  ) {
+  if (earliestSuspendedTime > earliestExpirationTime) {
     earliestExpirationTime = earliestSuspendedTime;
   }
   return earliestExpirationTime;
@@ -6514,7 +6538,7 @@ function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
 
 function didExpireAtExpirationTime(root, currentTime) {
   var expirationTime = root.expirationTime;
-  if (expirationTime !== NoWork && currentTime >= expirationTime) {
+  if (expirationTime !== NoWork && currentTime <= expirationTime) {
     // The root has expired. Flush all work up to the current time.
     root.nextExpirationTimeToWorkOn = currentTime;
   }
@@ -6536,7 +6560,7 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   if (
     nextExpirationTimeToWorkOn === NoWork &&
     (completedExpirationTime === NoWork ||
-      latestSuspendedTime > completedExpirationTime)
+      latestSuspendedTime < completedExpirationTime)
   ) {
     // The lowest priority suspended work is the work most likely to be
     // committed next. Let's start rendering it again, so that if it times out,
@@ -6545,11 +6569,7 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   }
 
   var expirationTime = nextExpirationTimeToWorkOn;
-  if (
-    expirationTime !== NoWork &&
-    earliestSuspendedTime !== NoWork &&
-    earliestSuspendedTime < expirationTime
-  ) {
+  if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
     // Expire using the earliest known expiration time.
     expirationTime = earliestSuspendedTime;
   }
@@ -6773,7 +6793,7 @@ function enqueueUpdate(fiber, update) {
 
   {
     if (
-      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &&
+      fiber.tag === ClassComponent &&
       (currentlyProcessingQueue === queue1 ||
         (queue2 !== null && currentlyProcessingQueue === queue2)) &&
       !didWarnUpdateInsideUpdate
@@ -6921,7 +6941,7 @@ function processUpdateQueue(
   var resultState = newBaseState;
   while (update !== null) {
     var updateExpirationTime = update.expirationTime;
-    if (updateExpirationTime > renderExpirationTime) {
+    if (updateExpirationTime < renderExpirationTime) {
       // This update does not have sufficient priority. Skip it.
       if (newFirstUpdate === null) {
         // This is the first skipped update. It will be the first update in
@@ -6933,10 +6953,7 @@ function processUpdateQueue(
       }
       // Since this update will remain in the list, update the remaining
       // expiration time.
-      if (
-        newExpirationTime === NoWork ||
-        newExpirationTime > updateExpirationTime
-      ) {
+      if (newExpirationTime < updateExpirationTime) {
         newExpirationTime = updateExpirationTime;
       }
     } else {
@@ -6972,7 +6989,7 @@ function processUpdateQueue(
   update = queue.firstCapturedUpdate;
   while (update !== null) {
     var _updateExpirationTime = update.expirationTime;
-    if (_updateExpirationTime > renderExpirationTime) {
+    if (_updateExpirationTime < renderExpirationTime) {
       // This update does not have sufficient priority. Skip it.
       if (newFirstCapturedUpdate === null) {
         // This is the first skipped captured update. It will be the first
@@ -6986,10 +7003,7 @@ function processUpdateQueue(
       }
       // Since this update will remain in the list, update the remaining
       // expiration time.
-      if (
-        newExpirationTime === NoWork ||
-        newExpirationTime > _updateExpirationTime
-      ) {
+      if (newExpirationTime < _updateExpirationTime) {
         newExpirationTime = _updateExpirationTime;
       }
     } else {
@@ -7287,10 +7301,7 @@ function propagateContextChange(
         ) {
           // Match! Schedule an update on this fiber.
 
-          if (
-            fiber.tag === ClassComponent ||
-            fiber.tag === ClassComponentLazy
-          ) {
+          if (fiber.tag === ClassComponent) {
             // Schedule a force update on the work-in-progress.
             var update = createUpdate(renderExpirationTime);
             update.tag = ForceUpdate;
@@ -7301,17 +7312,13 @@ function propagateContextChange(
             enqueueUpdate(fiber, update);
           }
 
-          if (
-            fiber.expirationTime === NoWork ||
-            fiber.expirationTime > renderExpirationTime
-          ) {
+          if (fiber.expirationTime < renderExpirationTime) {
             fiber.expirationTime = renderExpirationTime;
           }
           var alternate = fiber.alternate;
           if (
             alternate !== null &&
-            (alternate.expirationTime === NoWork ||
-              alternate.expirationTime > renderExpirationTime)
+            alternate.expirationTime < renderExpirationTime
           ) {
             alternate.expirationTime = renderExpirationTime;
           }
@@ -7320,22 +7327,17 @@ function propagateContextChange(
           var node = fiber.return;
           while (node !== null) {
             alternate = node.alternate;
-            if (
-              node.childExpirationTime === NoWork ||
-              node.childExpirationTime > renderExpirationTime
-            ) {
+            if (node.childExpirationTime < renderExpirationTime) {
               node.childExpirationTime = renderExpirationTime;
               if (
                 alternate !== null &&
-                (alternate.childExpirationTime === NoWork ||
-                  alternate.childExpirationTime > renderExpirationTime)
+                alternate.childExpirationTime < renderExpirationTime
               ) {
                 alternate.childExpirationTime = renderExpirationTime;
               }
             } else if (
               alternate !== null &&
-              (alternate.childExpirationTime === NoWork ||
-                alternate.childExpirationTime > renderExpirationTime)
+              alternate.childExpirationTime < renderExpirationTime
             ) {
               alternate.childExpirationTime = renderExpirationTime;
             } else {
@@ -7420,7 +7422,7 @@ function readContext(context, observedBits) {
     if (lastContextDependency === null) {
       invariant(
         currentlyRenderingFiber !== null,
-        "Context.unstable_read(): Context can only be read while React is " +
+        "Context can only be read while React is " +
           "rendering, e.g. inside the render method or getDerivedStateFromProps."
       );
       // This is the first dependency in the list
@@ -7433,137 +7435,779 @@ function readContext(context, observedBits) {
   return isPrimaryRenderer ? context._currentValue : context._currentValue2;
 }
 
-var NO_CONTEXT = {};
+var NoEffect$1 = /*             */ 0;
+var UnmountSnapshot = /*      */ 2;
+var UnmountMutation = /*      */ 4;
+var MountMutation = /*        */ 8;
+var UnmountLayout = /*        */ 16;
+var MountLayout = /*          */ 32;
+var MountPassive = /*         */ 64;
+var UnmountPassive = /*       */ 128;
 
-var contextStackCursor$1 = createCursor(NO_CONTEXT);
-var contextFiberStackCursor = createCursor(NO_CONTEXT);
-var rootInstanceStackCursor = createCursor(NO_CONTEXT);
+function areHookInputsEqual(arr1, arr2) {
+  // Don't bother comparing lengths in prod because these arrays should be
+  // passed inline.
+  {
+    !(arr1.length === arr2.length)
+      ? warning$1(
+          false,
+          "Detected a variable number of hook dependencies. The length of the " +
+            "dependencies array should be constant between renders.\n\n" +
+            "Previous: %s\n" +
+            "Incoming: %s",
+          arr1.join(", "),
+          arr2.join(", ")
+        )
+      : void 0;
+  }
+  for (var i = 0; i < arr1.length; i++) {
+    // Inlined Object.is polyfill.
+    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+    var val1 = arr1[i];
+    var val2 = arr2[i];
+    if (
+      (val1 === val2 && (val1 !== 0 || 1 / val1 === 1 / val2)) ||
+      (val1 !== val1 && val2 !== val2) // eslint-disable-line no-self-compare
+    ) {
+      continue;
+    }
+    return false;
+  }
+  return true;
+}
 
-function requiredContext(c) {
+// These are set right before calling the component.
+var renderExpirationTime = NoWork;
+// The work-in-progress fiber. I've named it differently to distinguish it from
+// the work-in-progress hook.
+var currentlyRenderingFiber$1 = null;
+
+// Hooks are stored as a linked list on the fiber's memoizedState field. The
+// current hook list is the list that belongs to the current fiber. The
+// work-in-progress hook list is a new list that will be added to the
+// work-in-progress fiber.
+var firstCurrentHook = null;
+var currentHook = null;
+var firstWorkInProgressHook = null;
+var workInProgressHook = null;
+
+var remainingExpirationTime = NoWork;
+var componentUpdateQueue = null;
+
+// Updates scheduled during render will trigger an immediate re-render at the
+// end of the current pass. We can't store these updates on the normal queue,
+// because if the work is aborted, they should be discarded. Because this is
+// a relatively rare case, we also don't want to add an additional field to
+// either the hook or queue object types. So we store them in a lazily create
+// map of queue -> render-phase updates, which are discarded once the component
+// completes without re-rendering.
+
+// Whether the work-in-progress hook is a re-rendered hook
+var isReRender = false;
+// Whether an update was scheduled during the currently executing render pass.
+var didScheduleRenderPhaseUpdate = false;
+// Lazily created map of render-phase updates
+var renderPhaseUpdates = null;
+// Counter to prevent infinite loops.
+var numberOfReRenders = 0;
+var RE_RENDER_LIMIT = 25;
+
+function resolveCurrentlyRenderingFiber() {
   invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug " +
-      "in React. Please file an issue."
+    currentlyRenderingFiber$1 !== null,
+    "Hooks can only be called inside the body of a function component."
   );
-  return c;
+  return currentlyRenderingFiber$1;
 }
 
-function getRootHostContainer() {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  return rootInstance;
-}
+function prepareToUseHooks(current, workInProgress, nextRenderExpirationTime) {
+  if (!enableHooks) {
+    return;
+  }
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = current !== null ? current.memoizedState : null;
 
-function pushHostContainer(fiber, nextRootInstance) {
-  // Push current root instance onto the stack;
-  // This allows us to reset root when portals are popped.
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
+  // The following should have already been reset
+  // currentHook = null;
+  // workInProgressHook = null;
 
-  // Finally, we need to push the host context to the stack.
-  // However, we can't just call getRootHostContext() and push it because
-  // we'd have a different number of entries on the stack depending on
-  // whether getRootHostContext() throws somewhere in renderer code or not.
-  // So we push an empty value first. This lets us safely unwind on errors.
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  var nextRootContext = getRootHostContext(nextRootInstance);
-  // Now that we know this function doesn't throw, replace it.
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, nextRootContext, fiber);
-}
+  // remainingExpirationTime = NoWork;
+  // componentUpdateQueue = null;
 
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
+  // isReRender = false;
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = 0;
 }
 
-function getHostContext() {
-  var context = requiredContext(contextStackCursor$1.current);
-  return context;
-}
+function finishHooks(Component, props, children, refOrContext) {
+  if (!enableHooks) {
+    return children;
+  }
 
-function pushHostContext(fiber) {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+  // This must be called after every function component to prevent hooks from
+  // being used in classes.
 
-  // Don't push this Fiber's context unless it's unique.
-  if (context === nextContext) {
-    return;
-  }
+  while (didScheduleRenderPhaseUpdate) {
+    // Updates were scheduled during the render phase. They are stored in
+    // the `renderPhaseUpdates` map. Call the component again, reusing the
+    // work-in-progress hooks and applying the additional updates on top. Keep
+    // restarting until no more updates are scheduled.
+    didScheduleRenderPhaseUpdate = false;
+    numberOfReRenders += 1;
 
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, nextContext, fiber);
-}
+    // Start over from the beginning of the list
+    currentHook = null;
+    workInProgressHook = null;
+    componentUpdateQueue = null;
 
-function popHostContext(fiber) {
-  // Do not pop unless this Fiber provided the current context.
-  // pushHostContext() only pushes Fibers that provide unique contexts.
-  if (contextFiberStackCursor.current !== fiber) {
-    return;
+    children = Component(props, refOrContext);
   }
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
 
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-}
+  var renderedWork = currentlyRenderingFiber$1;
 
-var commitTime = 0;
-var profilerStartTime = -1;
+  renderedWork.memoizedState = firstWorkInProgressHook;
+  renderedWork.expirationTime = remainingExpirationTime;
+  renderedWork.updateQueue = componentUpdateQueue;
 
-function getCommitTime() {
-  return commitTime;
-}
+  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
 
-function recordCommitTime() {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  commitTime = now();
-}
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-function startProfilerTimer(fiber) {
-  if (!enableProfilerTimer) {
-    return;
-  }
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-  profilerStartTime = now();
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-  if (fiber.actualStartTime < 0) {
-    fiber.actualStartTime = now();
-  }
+  // Always set during createWorkInProgress
+  // isReRender = false;
+
+  // These were reset above
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = 0;
+
+  invariant(
+    !didRenderTooFewHooks,
+    "Rendered fewer hooks than expected. This may be caused by an accidental " +
+      "early return statement."
+  );
+
+  return children;
 }
 
-function stopProfilerTimerIfRunning(fiber) {
-  if (!enableProfilerTimer) {
+function resetHooks() {
+  if (!enableHooks) {
     return;
   }
-  profilerStartTime = -1;
+
+  // This is called instead of `finishHooks` if the component throws. It's also
+  // called inside mountIndeterminateComponent if we determine the component
+  // is a module-style component.
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
+
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
+
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
+
+  // Always set during createWorkInProgress
+  // isReRender = false;
+
+  didScheduleRenderPhaseUpdate = false;
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
 }
 
-function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
-  if (!enableProfilerTimer) {
-    return;
-  }
+function createHook() {
+  return {
+    memoizedState: null,
 
-  if (profilerStartTime >= 0) {
-    var elapsedTime = now() - profilerStartTime;
-    fiber.actualDuration += elapsedTime;
-    if (overrideBaseTime) {
-      fiber.selfBaseDuration = elapsedTime;
-    }
-    profilerStartTime = -1;
-  }
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+
+    next: null
+  };
 }
 
-/*eslint-disable no-self-compare */
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
 
-var hasOwnProperty = Object.prototype.hasOwnProperty;
+    baseState: hook.memoizedState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
 
-/**
+    next: null
+  };
+}
+
+function createWorkInProgressHook() {
+  if (workInProgressHook === null) {
+    // This is the first hook in the list
+    if (firstWorkInProgressHook === null) {
+      isReRender = false;
+      currentHook = firstCurrentHook;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        workInProgressHook = createHook();
+      } else {
+        // Clone the current hook.
+        workInProgressHook = cloneHook(currentHook);
+      }
+      firstWorkInProgressHook = workInProgressHook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      isReRender = true;
+      currentHook = firstCurrentHook;
+      workInProgressHook = firstWorkInProgressHook;
+    }
+  } else {
+    if (workInProgressHook.next === null) {
+      isReRender = false;
+      var hook = void 0;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        hook = createHook();
+      } else {
+        currentHook = currentHook.next;
+        if (currentHook === null) {
+          // This is a newly mounted hook
+          hook = createHook();
+        } else {
+          // Clone the current hook.
+          hook = cloneHook(currentHook);
+        }
+      }
+      // Append to the end of the list
+      workInProgressHook = workInProgressHook.next = hook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      isReRender = true;
+      workInProgressHook = workInProgressHook.next;
+      currentHook = currentHook !== null ? currentHook.next : null;
+    }
+  }
+  return workInProgressHook;
+}
+
+function createFunctionComponentUpdateQueue() {
+  return {
+    lastEffect: null
+  };
+}
+
+function basicStateReducer(state, action) {
+  return typeof action === "function" ? action(state) : action;
+}
+
+function useContext(context, observedBits) {
+  // Ensure we're in a function component (class components support only the
+  // .unstable_read() form)
+  resolveCurrentlyRenderingFiber();
+  return readContext(context, observedBits);
+}
+
+function useState(initialState) {
+  return useReducer(
+    basicStateReducer,
+    // useReducer has a special case to support lazy useState initializers
+    initialState
+  );
+}
+
+function useReducer(reducer, initialState, initialAction) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (queue !== null) {
+    // Already have a queue, so this is an update.
+    if (isReRender) {
+      // This is a re-render. Apply the new render phase updates to the previous
+      var _dispatch2 = queue.dispatch;
+      if (renderPhaseUpdates !== null) {
+        // Render phase updates are stored in a map of queue -> linked list
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (firstRenderPhaseUpdate !== undefined) {
+          renderPhaseUpdates.delete(queue);
+          var newState = workInProgressHook.memoizedState;
+          var update = firstRenderPhaseUpdate;
+          do {
+            // Process this render phase update. We don't have to check the
+            // priority because it will always be the same as the current
+            // render's.
+            var _action = update.action;
+            newState = reducer(newState, _action);
+            update = update.next;
+          } while (update !== null);
+
+          workInProgressHook.memoizedState = newState;
+
+          // Don't persist the state accumlated from the render phase updates to
+          // the base state unless the queue is empty.
+          // TODO: Not sure if this is the desired semantics, but it's what we
+          // do for gDSFP. I can't remember why.
+          if (workInProgressHook.baseUpdate === queue.last) {
+            workInProgressHook.baseState = newState;
+          }
+
+          return [newState, _dispatch2];
+        }
+      }
+      return [workInProgressHook.memoizedState, _dispatch2];
+    }
+
+    // The last update in the entire queue
+    var _last = queue.last;
+    // The last update that is part of the base state.
+    var _baseUpdate = workInProgressHook.baseUpdate;
+
+    // Find the first unprocessed update.
+    var first = void 0;
+    if (_baseUpdate !== null) {
+      if (_last !== null) {
+        // For the first update, the queue is a circular linked list where
+        // `queue.last.next = queue.first`. Once the first update commits, and
+        // the `baseUpdate` is no longer empty, we can unravel the list.
+        _last.next = null;
+      }
+      first = _baseUpdate.next;
+    } else {
+      first = _last !== null ? _last.next : null;
+    }
+    if (first !== null) {
+      var _newState = workInProgressHook.baseState;
+      var newBaseState = null;
+      var newBaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      var _update = first;
+      var didSkip = false;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        if (updateExpirationTime < renderExpirationTime) {
+          // Priority is insufficient. Skip this update. If this is the first
+          // skipped update, the previous update/state is the new base
+          // update/state.
+          if (!didSkip) {
+            didSkip = true;
+            newBaseUpdate = prevUpdate;
+            newBaseState = _newState;
+          }
+          // Update the remaining priority in the queue.
+          if (updateExpirationTime > remainingExpirationTime) {
+            remainingExpirationTime = updateExpirationTime;
+          }
+        } else {
+          // Process this update.
+          var _action2 = _update.action;
+          _newState = reducer(_newState, _action2);
+        }
+        prevUpdate = _update;
+        _update = _update.next;
+      } while (_update !== null && _update !== first);
+
+      if (!didSkip) {
+        newBaseUpdate = prevUpdate;
+        newBaseState = _newState;
+      }
+
+      workInProgressHook.memoizedState = _newState;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = newBaseState;
+    }
+
+    var _dispatch = queue.dispatch;
+    return [workInProgressHook.memoizedState, _dispatch];
+  }
+
+  // There's no existing queue, so this is the initial render.
+  if (reducer === basicStateReducer) {
+    // Special case for `useState`.
+    if (typeof initialState === "function") {
+      initialState = initialState();
+    }
+  } else if (initialAction !== undefined && initialAction !== null) {
+    initialState = reducer(initialState, initialAction);
+  }
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null
+  };
+  var dispatch = (queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  ));
+  return [workInProgressHook.memoizedState, dispatch];
+}
+
+function pushEffect(tag, create, destroy, inputs) {
+  var effect = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    inputs: inputs,
+    // Circular
+    next: null
+  };
+  if (componentUpdateQueue === null) {
+    componentUpdateQueue = createFunctionComponentUpdateQueue();
+    componentUpdateQueue.lastEffect = effect.next = effect;
+  } else {
+    var _lastEffect = componentUpdateQueue.lastEffect;
+    if (_lastEffect === null) {
+      componentUpdateQueue.lastEffect = effect.next = effect;
+    } else {
+      var firstEffect = _lastEffect.next;
+      _lastEffect.next = effect;
+      effect.next = firstEffect;
+      componentUpdateQueue.lastEffect = effect;
+    }
+  }
+  return effect;
+}
+
+function useRef(initialValue) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var ref = void 0;
+
+  if (workInProgressHook.memoizedState === null) {
+    ref = { current: initialValue };
+    {
+      Object.seal(ref);
+    }
+    workInProgressHook.memoizedState = ref;
+  } else {
+    ref = workInProgressHook.memoizedState;
+  }
+  return ref;
+}
+
+function useMutationEffect(create, inputs) {
+  useEffectImpl(
+    Snapshot | Update,
+    UnmountSnapshot | MountMutation,
+    create,
+    inputs
+  );
+}
+
+function useLayoutEffect(create, inputs) {
+  useEffectImpl(Update, UnmountMutation | MountLayout, create, inputs);
+}
+
+function useEffect(create, inputs) {
+  useEffectImpl(
+    Update | Passive,
+    UnmountPassive | MountPassive,
+    create,
+    inputs
+  );
+}
+
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextInputs = inputs !== undefined && inputs !== null ? inputs : [create];
+  var destroy = null;
+  if (currentHook !== null) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (areHookInputsEqual(nextInputs, prevEffect.inputs)) {
+      pushEffect(NoEffect$1, create, destroy, nextInputs);
+      return;
+    }
+  }
+
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    nextInputs
+  );
+}
+
+function useImperativeMethods(ref, create, inputs) {
+  // TODO: If inputs are provided, should we skip comparing the ref itself?
+  var nextInputs =
+    inputs !== null && inputs !== undefined
+      ? inputs.concat([ref])
+      : [ref, create];
+
+  // TODO: I've implemented this on top of useEffect because it's almost the
+  // same thing, and it would require an equal amount of code. It doesn't seem
+  // like a common enough use case to justify the additional size.
+  useEffectImpl(
+    Update,
+    UnmountMutation | MountLayout,
+    function() {
+      if (typeof ref === "function") {
+        var refCallback = ref;
+        var _inst = create();
+        refCallback(_inst);
+        return function() {
+          return refCallback(null);
+        };
+      } else if (ref !== null && ref !== undefined) {
+        var refObject = ref;
+        var _inst2 = create();
+        refObject.current = _inst2;
+        return function() {
+          refObject.current = null;
+        };
+      }
+    },
+    nextInputs
+  );
+}
+
+function useCallback(callback, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextInputs =
+    inputs !== undefined && inputs !== null ? inputs : [callback];
+
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    var prevInputs = prevState[1];
+    if (areHookInputsEqual(nextInputs, prevInputs)) {
+      return prevState[0];
+    }
+  }
+  workInProgressHook.memoizedState = [callback, nextInputs];
+  return callback;
+}
+
+function useMemo(nextCreate, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextInputs =
+    inputs !== undefined && inputs !== null ? inputs : [nextCreate];
+
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    var prevInputs = prevState[1];
+    if (areHookInputsEqual(nextInputs, prevInputs)) {
+      return prevState[0];
+    }
+  }
+
+  var nextValue = nextCreate();
+  workInProgressHook.memoizedState = [nextValue, nextInputs];
+  return nextValue;
+}
+
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    numberOfReRenders < RE_RENDER_LIMIT,
+    "Too many re-renders. React limits the number of renders to prevent " +
+      "an infinite loop."
+  );
+
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (alternate !== null && alternate === currentlyRenderingFiber$1)
+  ) {
+    // This is a render phase update. Stash it in a lazily-created map of
+    // queue -> linked list of updates. After this render pass, we'll restart
+    // and apply the stashed updates on top of the work-in-progress hook.
+    didScheduleRenderPhaseUpdate = true;
+    var update = {
+      expirationTime: renderExpirationTime,
+      action: action,
+      next: null
+    };
+    if (renderPhaseUpdates === null) {
+      renderPhaseUpdates = new Map();
+    }
+    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+    if (firstRenderPhaseUpdate === undefined) {
+      renderPhaseUpdates.set(queue, update);
+    } else {
+      // Append the update to the end of the list.
+      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
+      while (lastRenderPhaseUpdate.next !== null) {
+        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
+      }
+      lastRenderPhaseUpdate.next = update;
+    }
+  } else {
+    var currentTime = requestCurrentTime();
+    var _expirationTime = computeExpirationForFiber(currentTime, fiber);
+    var _update2 = {
+      expirationTime: _expirationTime,
+      action: action,
+      next: null
+    };
+    flushPassiveEffects();
+    // Append the update to the end of the list.
+    var _last2 = queue.last;
+    if (_last2 === null) {
+      // This is the first update. Create a circular list.
+      _update2.next = _update2;
+    } else {
+      var first = _last2.next;
+      if (first !== null) {
+        // Still circular.
+        _update2.next = first;
+      }
+      _last2.next = _update2;
+    }
+    queue.last = _update2;
+    scheduleWork(fiber, _expirationTime);
+  }
+}
+
+var NO_CONTEXT = {};
+
+var contextStackCursor$1 = createCursor(NO_CONTEXT);
+var contextFiberStackCursor = createCursor(NO_CONTEXT);
+var rootInstanceStackCursor = createCursor(NO_CONTEXT);
+
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug " +
+      "in React. Please file an issue."
+  );
+  return c;
+}
+
+function getRootHostContainer() {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  return rootInstance;
+}
+
+function pushHostContainer(fiber, nextRootInstance) {
+  // Push current root instance onto the stack;
+  // This allows us to reset root when portals are popped.
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+
+  // Finally, we need to push the host context to the stack.
+  // However, we can't just call getRootHostContext() and push it because
+  // we'd have a different number of entries on the stack depending on
+  // whether getRootHostContext() throws somewhere in renderer code or not.
+  // So we push an empty value first. This lets us safely unwind on errors.
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  var nextRootContext = getRootHostContext(nextRootInstance);
+  // Now that we know this function doesn't throw, replace it.
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, nextRootContext, fiber);
+}
+
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+
+function getHostContext() {
+  var context = requiredContext(contextStackCursor$1.current);
+  return context;
+}
+
+function pushHostContext(fiber) {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+
+  // Don't push this Fiber's context unless it's unique.
+  if (context === nextContext) {
+    return;
+  }
+
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, nextContext, fiber);
+}
+
+function popHostContext(fiber) {
+  // Do not pop unless this Fiber provided the current context.
+  // pushHostContext() only pushes Fibers that provide unique contexts.
+  if (contextFiberStackCursor.current !== fiber) {
+    return;
+  }
+
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+}
+
+var commitTime = 0;
+var profilerStartTime = -1;
+
+function getCommitTime() {
+  return commitTime;
+}
+
+function recordCommitTime() {
+  if (!enableProfilerTimer) {
+    return;
+  }
+  commitTime = now();
+}
+
+function startProfilerTimer(fiber) {
+  if (!enableProfilerTimer) {
+    return;
+  }
+
+  profilerStartTime = now();
+
+  if (fiber.actualStartTime < 0) {
+    fiber.actualStartTime = now();
+  }
+}
+
+function stopProfilerTimerIfRunning(fiber) {
+  if (!enableProfilerTimer) {
+    return;
+  }
+  profilerStartTime = -1;
+}
+
+function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
+  if (!enableProfilerTimer) {
+    return;
+  }
+
+  if (profilerStartTime >= 0) {
+    var elapsedTime = now() - profilerStartTime;
+    fiber.actualDuration += elapsedTime;
+    if (overrideBaseTime) {
+      fiber.selfBaseDuration = elapsedTime;
+    }
+    profilerStartTime = -1;
+  }
+}
+
+/*eslint-disable no-self-compare */
+
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+/**
  * inlined Object.is polyfill to avoid requiring consumers ship their own
  * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  */
@@ -7616,7 +8260,81 @@ function shallowEqual(objA, objB) {
     }
   }
 
-  return true;
+  return true;
+}
+
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    // Resolve default props. Taken from ReactElement
+    var props = Object.assign({}, baseProps);
+    var defaultProps = Component.defaultProps;
+    for (var propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props;
+  }
+  return baseProps;
+}
+
+function readLazyComponentType(lazyComponent) {
+  var status = lazyComponent._status;
+  var result = lazyComponent._result;
+  switch (status) {
+    case Resolved: {
+      var Component = result;
+      return Component;
+    }
+    case Rejected: {
+      var error = result;
+      throw error;
+    }
+    case Pending: {
+      var thenable = result;
+      throw thenable;
+    }
+    default: {
+      lazyComponent._status = Pending;
+      var ctor = lazyComponent._ctor;
+      var _thenable = ctor();
+      _thenable.then(
+        function(moduleObject) {
+          if (lazyComponent._status === Pending) {
+            var defaultExport = moduleObject.default;
+            {
+              if (defaultExport === undefined) {
+                warning$1(
+                  false,
+                  "lazy: Expected the result of a dynamic import() call. " +
+                    "Instead received: %s\n\nYour code should look like: \n  " +
+                    "const MyComponent = lazy(() => import('./MyComponent'))",
+                  moduleObject
+                );
+              }
+            }
+            lazyComponent._status = Resolved;
+            lazyComponent._result = defaultExport;
+          }
+        },
+        function(error) {
+          if (lazyComponent._status === Pending) {
+            lazyComponent._status = Rejected;
+            lazyComponent._result = error;
+          }
+        }
+      );
+      lazyComponent._result = _thenable;
+      throw _thenable;
+    }
+  }
+}
+
+var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner;
+
+function readContext$1(contextType) {
+  var dispatcher = ReactCurrentOwner$4.currentDispatcher;
+  return dispatcher.readContext(contextType);
 }
 
 var fakeInternalInstance = {};
@@ -7758,6 +8476,7 @@ var classComponentUpdater = {
       update.callback = callback;
     }
 
+    flushPassiveEffects();
     enqueueUpdate(fiber, update);
     scheduleWork(fiber, expirationTime);
   },
@@ -7777,6 +8496,7 @@ var classComponentUpdater = {
       update.callback = callback;
     }
 
+    flushPassiveEffects();
     enqueueUpdate(fiber, update);
     scheduleWork(fiber, expirationTime);
   },
@@ -7795,6 +8515,7 @@ var classComponentUpdater = {
       update.callback = callback;
     }
 
+    flushPassiveEffects();
     enqueueUpdate(fiber, update);
     scheduleWork(fiber, expirationTime);
   }
@@ -8111,7 +8832,7 @@ function constructClassInstance(
   if (typeof contextType === "object" && contextType !== null) {
     {
       if (
-        typeof contextType.unstable_read !== "function" &&
+        contextType.$$typeof !== REACT_CONTEXT_TYPE &&
         !didWarnAboutInvalidateContextType.has(ctor)
       ) {
         didWarnAboutInvalidateContextType.add(ctor);
@@ -8125,7 +8846,7 @@ function constructClassInstance(
       }
     }
 
-    context = contextType.unstable_read();
+    context = readContext$1(contextType);
   } else {
     unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
     var contextTypes = ctor.contextTypes;
@@ -8327,7 +9048,7 @@ function mountClassInstance(
 
   var contextType = ctor.contextType;
   if (typeof contextType === "object" && contextType !== null) {
-    instance.context = contextType.unstable_read();
+    instance.context = readContext$1(contextType);
   } else {
     var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
     instance.context = getMaskedContext(workInProgress, unmaskedContext);
@@ -8435,7 +9156,7 @@ function resumeMountClassInstance(
   var contextType = ctor.contextType;
   var nextContext = void 0;
   if (typeof contextType === "object" && contextType !== null) {
-    nextContext = contextType.unstable_read();
+    nextContext = readContext$1(contextType);
   } else {
     var nextLegacyUnmaskedContext = getUnmaskedContext(
       workInProgress,
@@ -8575,13 +9296,16 @@ function updateClassInstance(
   var instance = workInProgress.stateNode;
 
   var oldProps = workInProgress.memoizedProps;
-  instance.props = oldProps;
+  instance.props =
+    workInProgress.type === workInProgress.elementType
+      ? oldProps
+      : resolveDefaultProps(workInProgress.type, oldProps);
 
   var oldContext = instance.context;
   var contextType = ctor.contextType;
   var nextContext = void 0;
   if (typeof contextType === "object" && contextType !== null) {
-    nextContext = contextType.unstable_read();
+    nextContext = readContext$1(contextType);
   } else {
     var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
     nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
@@ -8824,8 +9548,7 @@ function coerceRef(returnFiber, current$$1, element) {
       if (owner) {
         var ownerFiber = owner;
         invariant(
-          ownerFiber.tag === ClassComponent ||
-            ownerFiber.tag === ClassComponentLazy,
+          ownerFiber.tag === ClassComponent,
           "Function components cannot have refs."
         );
         inst = ownerFiber.stateNode;
@@ -9045,7 +9768,7 @@ function ChildReconciler(shouldTrackSideEffects) {
   }
 
   function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (current$$1 !== null && current$$1.type === element.type) {
+    if (current$$1 !== null && current$$1.elementType === element.type) {
       // Move based on index
       var existing = useFiber(current$$1, element.props, expirationTime);
       existing.ref = coerceRef(returnFiber, current$$1, element);
@@ -9783,7 +10506,7 @@ function ChildReconciler(shouldTrackSideEffects) {
         if (
           child.tag === Fragment
             ? element.type === REACT_FRAGMENT_TYPE
-            : child.type === element.type
+            : child.elementType === element.type
         ) {
           deleteRemainingChildren(returnFiber, child.sibling);
           var existing = useFiber(
@@ -9966,8 +10689,7 @@ function ChildReconciler(shouldTrackSideEffects) {
       // component, throw an error. If Fiber return types are disabled,
       // we already threw above.
       switch (returnFiber.tag) {
-        case ClassComponent:
-        case ClassComponentLazy: {
+        case ClassComponent: {
           {
             var instance = returnFiber.stateNode;
             if (instance.render._isMockFunction) {
@@ -10350,49 +11072,6 @@ function resetHydrationState() {
   isHydrating = false;
 }
 
-function readLazyComponentType(thenable) {
-  var status = thenable._reactStatus;
-  switch (status) {
-    case Resolved:
-      var Component = thenable._reactResult;
-      return Component;
-    case Rejected:
-      throw thenable._reactResult;
-    case Pending:
-      throw thenable;
-    default: {
-      thenable._reactStatus = Pending;
-      thenable.then(
-        function(resolvedValue) {
-          if (thenable._reactStatus === Pending) {
-            thenable._reactStatus = Resolved;
-            if (typeof resolvedValue === "object" && resolvedValue !== null) {
-              // If the `default` property is not empty, assume it's the result
-              // of an async import() and use that. Otherwise, use the
-              // resolved value itself.
-              var defaultExport = resolvedValue.default;
-              resolvedValue =
-                defaultExport !== undefined && defaultExport !== null
-                  ? defaultExport
-                  : resolvedValue;
-            } else {
-              resolvedValue = resolvedValue;
-            }
-            thenable._reactResult = resolvedValue;
-          }
-        },
-        function(error) {
-          if (thenable._reactStatus === Pending) {
-            thenable._reactStatus = Rejected;
-            thenable._reactResult = error;
-          }
-        }
-      );
-      throw thenable;
-    }
-  }
-}
-
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 
 var didWarnAboutBadClass = void 0;
@@ -10475,45 +11154,37 @@ function forceUnmountCurrentAndReconcile(
 function updateForwardRef(
   current$$1,
   workInProgress,
-  type,
+  Component,
   nextProps,
   renderExpirationTime
 ) {
-  var render = type.render;
+  var render = Component.render;
   var ref = workInProgress.ref;
-  if (hasContextChanged()) {
-    // Normally we can bail out on props equality but if context has changed
-    // we don't do the bailout and we have to reuse existing props instead.
-  } else if (workInProgress.memoizedProps === nextProps) {
-    var currentRef = current$$1 !== null ? current$$1.ref : null;
-    if (ref === currentRef) {
-      return bailoutOnAlreadyFinishedWork(
-        current$$1,
-        workInProgress,
-        renderExpirationTime
-      );
-    }
-  }
 
+  // The rest is a fork of updateFunctionComponent
   var nextChildren = void 0;
+  prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
     nextChildren = render(nextProps, ref);
     setCurrentPhase(null);
   }
+  nextChildren = finishHooks(render, nextProps, nextChildren, ref);
 
+  // React DevTools reads this flag.
+  workInProgress.effectTag |= PerformedWork;
   reconcileChildren(
     current$$1,
     workInProgress,
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
-function updatePureComponent(
+function updateMemoComponent(
   current$$1,
   workInProgress,
   Component,
@@ -10521,18 +11192,51 @@ function updatePureComponent(
   updateExpirationTime,
   renderExpirationTime
 ) {
-  var render = Component.render;
-
-  if (
-    current$$1 !== null &&
-    (updateExpirationTime === NoWork ||
-      updateExpirationTime > renderExpirationTime)
-  ) {
-    var prevProps = current$$1.memoizedProps;
+  if (current$$1 === null) {
+    var type = Component.type;
+    if (isSimpleFunctionComponent(type) && Component.compare === null) {
+      // If this is a plain function component without default props,
+      // and with only the default shallow comparison, we upgrade it
+      // to a SimpleMemoComponent to allow fast path updates.
+      workInProgress.tag = SimpleMemoComponent;
+      workInProgress.type = type;
+      {
+        validateFunctionComponentInDev(workInProgress, type);
+      }
+      return updateSimpleMemoComponent(
+        current$$1,
+        workInProgress,
+        type,
+        nextProps,
+        updateExpirationTime,
+        renderExpirationTime
+      );
+    }
+    var child = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      null,
+      workInProgress.mode,
+      renderExpirationTime
+    );
+    child.ref = workInProgress.ref;
+    child.return = workInProgress;
+    workInProgress.child = child;
+    return child;
+  }
+  var currentChild = current$$1.child; // This is always exactly one child
+  if (updateExpirationTime < renderExpirationTime) {
+    // This will be the props with resolved defaultProps,
+    // unlike current.memoizedProps which will be the unresolved ones.
+    var prevProps = currentChild.memoizedProps;
     // Default to shallow comparison
     var compare = Component.compare;
     compare = compare !== null ? compare : shallowEqual;
-    if (compare(prevProps, nextProps)) {
+    if (
+      compare(prevProps, nextProps) &&
+      current$$1.ref === workInProgress.ref
+    ) {
       return bailoutOnAlreadyFinishedWork(
         current$$1,
         workInProgress,
@@ -10540,27 +11244,47 @@ function updatePureComponent(
       );
     }
   }
-
-  // The rest is a fork of updateFunctionComponent
-  var nextChildren = void 0;
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  {
-    ReactCurrentOwner$3.current = workInProgress;
-    setCurrentPhase("render");
-    nextChildren = render(nextProps);
-    setCurrentPhase(null);
-  }
-
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
-  reconcileChildren(
+  var newChild = createWorkInProgress(
+    currentChild,
+    nextProps,
+    renderExpirationTime
+  );
+  newChild.ref = workInProgress.ref;
+  newChild.return = workInProgress;
+  workInProgress.child = newChild;
+  return newChild;
+}
+
+function updateSimpleMemoComponent(
+  current$$1,
+  workInProgress,
+  Component,
+  nextProps,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  if (current$$1 !== null && updateExpirationTime < renderExpirationTime) {
+    var prevProps = current$$1.memoizedProps;
+    if (
+      shallowEqual(prevProps, nextProps) &&
+      current$$1.ref === workInProgress.ref
+    ) {
+      return bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      );
+    }
+  }
+  return updateFunctionComponent(
     current$$1,
     workInProgress,
-    nextChildren,
+    Component,
+    nextProps,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
-  return workInProgress.child;
 }
 
 function updateFragment(current$$1, workInProgress, renderExpirationTime) {
@@ -10571,7 +11295,6 @@ function updateFragment(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextChildren);
   return workInProgress.child;
 }
 
@@ -10583,7 +11306,6 @@ function updateMode(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextChildren);
   return workInProgress.child;
 }
 
@@ -10599,7 +11321,6 @@ function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
@@ -10626,12 +11347,14 @@ function updateFunctionComponent(
 
   var nextChildren = void 0;
   prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
     nextChildren = Component(nextProps, context);
     setCurrentPhase(null);
   }
+  nextChildren = finishHooks(Component, nextProps, nextChildren, context);
 
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -10641,7 +11364,6 @@ function updateFunctionComponent(
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
@@ -10664,32 +11386,41 @@ function updateClassComponent(
   }
   prepareToReadContext(workInProgress, renderExpirationTime);
 
+  var instance = workInProgress.stateNode;
   var shouldUpdate = void 0;
-  if (current$$1 === null) {
-    if (workInProgress.stateNode === null) {
-      // In the initial pass we might need to construct the instance.
-      constructClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      );
-      mountClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      );
-      shouldUpdate = true;
-    } else {
-      // In a resume, we'll already have an instance we can reuse.
-      shouldUpdate = resumeMountClassInstance(
-        workInProgress,
-        Component,
-        nextProps,
-        renderExpirationTime
-      );
-    }
+  if (instance === null) {
+    if (current$$1 !== null) {
+      // An class component without an instance only mounts if it suspended
+      // inside a non- concurrent tree, in an inconsistent state. We want to
+      // tree it like a new mount, even though an empty version of it already
+      // committed. Disconnect the alternate pointers.
+      current$$1.alternate = null;
+      workInProgress.alternate = null;
+      // Since this is conceptually a new fiber, schedule a Placement effect
+      workInProgress.effectTag |= Placement;
+    }
+    // In the initial pass we might need to construct the instance.
+    constructClassInstance(
+      workInProgress,
+      Component,
+      nextProps,
+      renderExpirationTime
+    );
+    mountClassInstance(
+      workInProgress,
+      Component,
+      nextProps,
+      renderExpirationTime
+    );
+    shouldUpdate = true;
+  } else if (current$$1 === null) {
+    // In a resume, we'll already have an instance we can reuse.
+    shouldUpdate = resumeMountClassInstance(
+      workInProgress,
+      Component,
+      nextProps,
+      renderExpirationTime
+    );
   } else {
     shouldUpdate = updateClassInstance(
       current$$1,
@@ -10791,10 +11522,9 @@ function finishClassComponent(
     );
   }
 
-  // Memoize props and state using the values we just used to render.
+  // Memoize state using the values we just used to render.
   // TODO: Restructure so we never read values from the instance.
-  memoizeState(workInProgress, instance.state);
-  memoizeProps(workInProgress, instance.props);
+  workInProgress.memoizedState = instance.state;
 
   // The context might have changed so we need to recalculate it.
   if (hasContext) {
@@ -10928,7 +11658,6 @@ function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
   ) {
     // Schedule this fiber to re-render at offscreen priority. Then bailout.
     workInProgress.expirationTime = Never;
-    workInProgress.memoizedProps = nextProps;
     return null;
   }
 
@@ -10938,7 +11667,6 @@ function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
     nextChildren,
     renderExpirationTime
   );
-  memoizeProps(workInProgress, nextProps);
   return workInProgress.child;
 }
 
@@ -10946,116 +11674,178 @@ function updateHostText(current$$1, workInProgress) {
   if (current$$1 === null) {
     tryToClaimNextHydratableInstance(workInProgress);
   }
-  var nextProps = workInProgress.pendingProps;
-  memoizeProps(workInProgress, nextProps);
   // Nothing to do here. This is terminal. We'll do the completion step
   // immediately after.
   return null;
 }
 
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
-    var props = Object.assign({}, baseProps);
-    var defaultProps = Component.defaultProps;
-    for (var propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
-      }
+function mountLazyComponent(
+  _current,
+  workInProgress,
+  elementType,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  if (_current !== null) {
+    // An lazy component only mounts if it suspended inside a non-
+    // concurrent tree, in an inconsistent state. We want to treat it like
+    // a new mount, even though an empty version of it already committed.
+    // Disconnect the alternate pointers.
+    _current.alternate = null;
+    workInProgress.alternate = null;
+    // Since this is conceptually a new fiber, schedule a Placement effect
+    workInProgress.effectTag |= Placement;
+  }
+
+  var props = workInProgress.pendingProps;
+  // We can't start a User Timing measurement with correct label yet.
+  // Cancel and resume right after we know the tag.
+  cancelWorkTimer(workInProgress);
+  var Component = readLazyComponentType(elementType);
+  // Store the unwrapped component in the type.
+  workInProgress.type = Component;
+  var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));
+  startWorkTimer(workInProgress);
+  var resolvedProps = resolveDefaultProps(Component, props);
+  var child = void 0;
+  switch (resolvedTag) {
+    case FunctionComponent: {
+      child = updateFunctionComponent(
+        null,
+        workInProgress,
+        Component,
+        resolvedProps,
+        renderExpirationTime
+      );
+      break;
+    }
+    case ClassComponent: {
+      child = updateClassComponent(
+        null,
+        workInProgress,
+        Component,
+        resolvedProps,
+        renderExpirationTime
+      );
+      break;
+    }
+    case ForwardRef: {
+      child = updateForwardRef(
+        null,
+        workInProgress,
+        Component,
+        resolvedProps,
+        renderExpirationTime
+      );
+      break;
+    }
+    case MemoComponent: {
+      child = updateMemoComponent(
+        null,
+        workInProgress,
+        Component,
+        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
+        updateExpirationTime,
+        renderExpirationTime
+      );
+      break;
+    }
+    default: {
+      // This message intentionally doesn't mention ForwardRef or MemoComponent
+      // because the fact that it's a separate type of work is an
+      // implementation detail.
+      invariant(
+        false,
+        "Element type is invalid. Received a promise that resolves to: %s. " +
+          "Promise elements must resolve to a class or function.",
+        Component
+      );
     }
-    return props;
   }
-  return baseProps;
+  return child;
 }
 
-function mountIndeterminateComponent(
-  current$$1,
+function mountIncompleteClassComponent(
+  _current,
   workInProgress,
   Component,
-  updateExpirationTime,
+  nextProps,
   renderExpirationTime
 ) {
-  invariant(
-    current$$1 === null,
-    "An indeterminate component should never have mounted. This error is " +
-      "likely caused by a bug in React. Please file an issue."
-  );
+  if (_current !== null) {
+    // An incomplete component only mounts if it suspended inside a non-
+    // concurrent tree, in an inconsistent state. We want to treat it like
+    // a new mount, even though an empty version of it already committed.
+    // Disconnect the alternate pointers.
+    _current.alternate = null;
+    workInProgress.alternate = null;
+    // Since this is conceptually a new fiber, schedule a Placement effect
+    workInProgress.effectTag |= Placement;
+  }
 
-  var props = workInProgress.pendingProps;
-  if (
-    typeof Component === "object" &&
-    Component !== null &&
-    typeof Component.then === "function"
-  ) {
-    Component = readLazyComponentType(Component);
-    var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(
-      workInProgress,
-      Component
-    ));
-    var resolvedProps = resolveDefaultProps(Component, props);
-    var child = void 0;
-    switch (resolvedTag) {
-      case FunctionComponentLazy: {
-        child = updateFunctionComponent(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          renderExpirationTime
-        );
-        break;
-      }
-      case ClassComponentLazy: {
-        child = updateClassComponent(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          renderExpirationTime
-        );
-        break;
-      }
-      case ForwardRefLazy: {
-        child = updateForwardRef(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          renderExpirationTime
-        );
-        break;
-      }
-      case PureComponentLazy: {
-        child = updatePureComponent(
-          current$$1,
-          workInProgress,
-          Component,
-          resolvedProps,
-          updateExpirationTime,
-          renderExpirationTime
-        );
-        break;
-      }
-      default: {
-        // This message intentionally doesn't metion ForwardRef or PureComponent
-        // because the fact that it's a separate type of work is an
-        // implementation detail.
-        invariant(
-          false,
-          "Element type is invalid. Received a promise that resolves to: %s. " +
-            "Promise elements must resolve to a class or function.",
-          Component
-        );
-      }
-    }
-    workInProgress.memoizedProps = props;
-    return child;
+  // Promote the fiber to a class and try rendering again.
+  workInProgress.tag = ClassComponent;
+
+  // The rest of this function is a fork of `updateClassComponent`
+
+  // Push context providers early to prevent context stack mismatches.
+  // During mounting we don't know the child context yet as the instance doesn't exist.
+  // We will invalidate the child context in finishClassComponent() right after rendering.
+  var hasContext = void 0;
+  if (isContextProvider(Component)) {
+    hasContext = true;
+    pushContextProvider(workInProgress);
+  } else {
+    hasContext = false;
+  }
+  prepareToReadContext(workInProgress, renderExpirationTime);
+
+  constructClassInstance(
+    workInProgress,
+    Component,
+    nextProps,
+    renderExpirationTime
+  );
+  mountClassInstance(
+    workInProgress,
+    Component,
+    nextProps,
+    renderExpirationTime
+  );
+
+  return finishClassComponent(
+    null,
+    workInProgress,
+    Component,
+    true,
+    hasContext,
+    renderExpirationTime
+  );
+}
+
+function mountIndeterminateComponent(
+  _current,
+  workInProgress,
+  Component,
+  renderExpirationTime
+) {
+  if (_current !== null) {
+    // An indeterminate component only mounts if it suspended inside a non-
+    // concurrent tree, in an inconsistent state. We want to treat it like
+    // a new mount, even though an empty version of it already committed.
+    // Disconnect the alternate pointers.
+    _current.alternate = null;
+    workInProgress.alternate = null;
+    // Since this is conceptually a new fiber, schedule a Placement effect
+    workInProgress.effectTag |= Placement;
   }
 
+  var props = workInProgress.pendingProps;
   var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
   var context = getMaskedContext(workInProgress, unmaskedContext);
 
   prepareToReadContext(workInProgress, renderExpirationTime);
+  prepareToUseHooks(null, workInProgress, renderExpirationTime);
 
   var value = void 0;
 
@@ -11097,6 +11887,9 @@ function mountIndeterminateComponent(
     // Proceed under the assumption that this is a class instance
     workInProgress.tag = ClassComponent;
 
+    // Throw out any hooks that were used.
+    resetHooks();
+
     // Push context providers early to prevent context stack mismatches.
     // During mounting we don't know the child context yet as the instance doesn't exist.
     // We will invalidate the child context in finishClassComponent() right after rendering.
@@ -11124,7 +11917,7 @@ function mountIndeterminateComponent(
     adoptClassInstance(workInProgress, value);
     mountClassInstance(workInProgress, Component, props, renderExpirationTime);
     return finishClassComponent(
-      current$$1,
+      null,
       workInProgress,
       Component,
       true,
@@ -11134,147 +11927,336 @@ function mountIndeterminateComponent(
   } else {
     // Proceed under the assumption that this is a function component
     workInProgress.tag = FunctionComponent;
+    value = finishHooks(Component, props, value, context);
+    reconcileChildren(null, workInProgress, value, renderExpirationTime);
     {
-      if (Component) {
-        !!Component.childContextTypes
-          ? warningWithoutStack$1(
-              false,
-              "%s(...): childContextTypes cannot be defined on a function component.",
-              Component.displayName || Component.name || "Component"
-            )
-          : void 0;
-      }
-      if (workInProgress.ref !== null) {
-        var info = "";
-        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
-        if (ownerName) {
-          info += "\n\nCheck the render method of `" + ownerName + "`.";
-        }
+      validateFunctionComponentInDev(workInProgress, Component);
+    }
+    return workInProgress.child;
+  }
+}
 
-        var warningKey = ownerName || workInProgress._debugID || "";
-        var debugSource = workInProgress._debugSource;
-        if (debugSource) {
-          warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
-        }
-        if (!didWarnAboutFunctionRefs[warningKey]) {
-          didWarnAboutFunctionRefs[warningKey] = true;
-          warning$1(
-            false,
-            "Function components cannot be given refs. " +
-              "Attempts to access this ref will fail.%s",
-            info
-          );
-        }
-      }
+function validateFunctionComponentInDev(workInProgress, Component) {
+  if (Component) {
+    !!Component.childContextTypes
+      ? warningWithoutStack$1(
+          false,
+          "%s(...): childContextTypes cannot be defined on a function component.",
+          Component.displayName || Component.name || "Component"
+        )
+      : void 0;
+  }
+  if (workInProgress.ref !== null) {
+    var info = "";
+    var ownerName = getCurrentFiberOwnerNameInDevOrNull();
+    if (ownerName) {
+      info += "\n\nCheck the render method of `" + ownerName + "`.";
+    }
 
-      if (typeof Component.getDerivedStateFromProps === "function") {
-        var _componentName = getComponentName(Component) || "Unknown";
+    var warningKey = ownerName || workInProgress._debugID || "";
+    var debugSource = workInProgress._debugSource;
+    if (debugSource) {
+      warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
+    }
+    if (!didWarnAboutFunctionRefs[warningKey]) {
+      didWarnAboutFunctionRefs[warningKey] = true;
+      warning$1(
+        false,
+        "Function components cannot be given refs. " +
+          "Attempts to access this ref will fail.%s",
+        info
+      );
+    }
+  }
 
-        if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName]) {
-          warningWithoutStack$1(
-            false,
-            "%s: Function components do not support getDerivedStateFromProps.",
-            _componentName
-          );
-          didWarnAboutGetDerivedStateOnFunctionComponent[_componentName] = true;
-        }
-      }
+  if (typeof Component.getDerivedStateFromProps === "function") {
+    var componentName = getComponentName(Component) || "Unknown";
 
-      if (
-        typeof Component.contextType === "object" &&
-        Component.contextType !== null
-      ) {
-        var _componentName2 = getComponentName(Component) || "Unknown";
+    if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {
+      warningWithoutStack$1(
+        false,
+        "%s: Function components do not support getDerivedStateFromProps.",
+        componentName
+      );
+      didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;
+    }
+  }
 
-        if (!didWarnAboutContextTypeOnFunctionComponent[_componentName2]) {
-          warningWithoutStack$1(
-            false,
-            "%s: Function components do not support contextType.",
-            _componentName2
-          );
-          didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true;
-        }
-      }
+  if (
+    typeof Component.contextType === "object" &&
+    Component.contextType !== null
+  ) {
+    var _componentName = getComponentName(Component) || "Unknown";
+
+    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName]) {
+      warningWithoutStack$1(
+        false,
+        "%s: Function components do not support contextType.",
+        _componentName
+      );
+      didWarnAboutContextTypeOnFunctionComponent[_componentName] = true;
     }
-    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);
-    memoizeProps(workInProgress, props);
-    return workInProgress.child;
   }
 }
 
-function updatePlaceholderComponent(
+function updateSuspenseComponent(
   current$$1,
   workInProgress,
   renderExpirationTime
 ) {
-  if (enableSuspense) {
-    var nextProps = workInProgress.pendingProps;
-
-    // Check if we already attempted to render the normal state. If we did,
-    // and we timed out, render the placeholder state.
-    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;
-
-    var nextDidTimeout = void 0;
-    if (current$$1 !== null && workInProgress.updateQueue !== null) {
-      // We're outside strict mode. Something inside this Placeholder boundary
-      // suspended during the last commit. Switch to the placholder.
-      workInProgress.updateQueue = null;
-      nextDidTimeout = true;
-    } else {
-      nextDidTimeout = !alreadyCaptured;
-    }
+  var mode = workInProgress.mode;
+  var nextProps = workInProgress.pendingProps;
 
-    if ((workInProgress.mode & StrictMode) !== NoEffect) {
-      if (nextDidTimeout) {
-        // If the timed-out view commits, schedule an update effect to record
-        // the committed time.
-        workInProgress.effectTag |= Update;
-      } else {
-        // The state node points to the time at which placeholder timed out.
-        // We can clear it once we switch back to the normal children.
-        workInProgress.stateNode = null;
-      }
-    }
+  // We should attempt to render the primary children unless this boundary
+  // already suspended during this render (`alreadyCaptured` is true).
+  var nextState = workInProgress.memoizedState;
 
-    // If the `children` prop is a function, treat it like a render prop.
-    // TODO: This is temporary until we finalize a lower level API.
-    var children = nextProps.children;
-    var nextChildren = void 0;
-    if (typeof children === "function") {
-      nextChildren = children(nextDidTimeout);
-    } else {
-      nextChildren = nextDidTimeout ? nextProps.fallback : children;
-    }
+  var nextDidTimeout = void 0;
+  if ((workInProgress.effectTag & DidCapture) === NoEffect) {
+    // This is the first attempt.
+    nextState = null;
+    nextDidTimeout = false;
+  } else {
+    // Something in this boundary's subtree already suspended. Switch to
+    // rendering the fallback children.
+    nextState = {
+      timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
+    };
+    nextDidTimeout = true;
+    workInProgress.effectTag &= ~DidCapture;
+  }
+
+  // This next part is a bit confusing. If the children timeout, we switch to
+  // showing the fallback children in place of the "primary" children.
+  // However, we don't want to delete the primary children because then their
+  // state will be lost (both the React state and the host state, e.g.
+  // uncontrolled form inputs). Instead we keep them mounted and hide them.
+  // Both the fallback children AND the primary children are rendered at the
+  // same time. Once the primary children are un-suspended, we can delete
+  // the fallback children — don't need to preserve their state.
+  //
+  // The two sets of children are siblings in the host environment, but
+  // semantically, for purposes of reconciliation, they are two separate sets.
+  // So we store them using two fragment fibers.
+  //
+  // However, we want to avoid allocating extra fibers for every placeholder.
+  // They're only necessary when the children time out, because that's the
+  // only time when both sets are mounted.
+  //
+  // So, the extra fragment fibers are only used if the children time out.
+  // Otherwise, we render the primary children directly. This requires some
+  // custom reconciliation logic to preserve the state of the primary
+  // children. It's essentially a very basic form of re-parenting.
+
+  // `child` points to the child fiber. In the normal case, this is the first
+  // fiber of the primary children set. In the timed-out case, it's a
+  // a fragment fiber containing the primary children.
+  var child = void 0;
+  // `next` points to the next fiber React should render. In the normal case,
+  // it's the same as `child`: the first fiber of the primary children set.
+  // In the timed-out case, it's a fragment fiber containing the *fallback*
+  // children -- we skip over the primary children entirely.
+  var next = void 0;
+  if (current$$1 === null) {
+    // This is the initial mount. This branch is pretty simple because there's
+    // no previous state that needs to be preserved.
+    if (nextDidTimeout) {
+      // Mount separate fragments for primary and fallback children.
+      var nextFallbackChildren = nextProps.fallback;
+      var primaryChildFragment = createFiberFromFragment(
+        null,
+        mode,
+        NoWork,
+        null
+      );
 
-    if (
-      current$$1 !== null &&
-      nextDidTimeout !== workInProgress.memoizedState
-    ) {
-      // We're about to switch from the placeholder children to the normal
-      // children, or vice versa. These are two different conceptual sets that
-      // happen to be stored in the same set. Call this special function to
-      // force the new set not to match with the current set.
-      // TODO: The proper way to model this is by storing each set separately.
-      forceUnmountCurrentAndReconcile(
-        current$$1,
-        workInProgress,
-        nextChildren,
-        renderExpirationTime
+      if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+        // Outside of concurrent mode, we commit the effects from the
+        var progressedState = workInProgress.memoizedState;
+        var progressedPrimaryChild =
+          progressedState !== null
+            ? workInProgress.child.child
+            : workInProgress.child;
+        primaryChildFragment.child = progressedPrimaryChild;
+      }
+
+      var fallbackChildFragment = createFiberFromFragment(
+        nextFallbackChildren,
+        mode,
+        renderExpirationTime,
+        null
       );
+      primaryChildFragment.sibling = fallbackChildFragment;
+      child = primaryChildFragment;
+      // Skip the primary children, and continue working on the
+      // fallback children.
+      next = fallbackChildFragment;
+      child.return = next.return = workInProgress;
     } else {
-      reconcileChildren(
-        current$$1,
+      // Mount the primary children without an intermediate fragment fiber.
+      var nextPrimaryChildren = nextProps.children;
+      child = next = mountChildFibers(
         workInProgress,
-        nextChildren,
+        null,
+        nextPrimaryChildren,
         renderExpirationTime
       );
     }
-    workInProgress.memoizedProps = nextProps;
-    workInProgress.memoizedState = nextDidTimeout;
-    return workInProgress.child;
   } else {
-    return null;
+    // This is an update. This branch is more complicated because we need to
+    // ensure the state of the primary children is preserved.
+    var prevState = current$$1.memoizedState;
+    var prevDidTimeout = prevState !== null;
+    if (prevDidTimeout) {
+      // The current tree already timed out. That means each child set is
+      var currentPrimaryChildFragment = current$$1.child;
+      var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
+      if (nextDidTimeout) {
+        // Still timed out. Reuse the current primary children by cloning
+        // its fragment. We're going to skip over these entirely.
+        var _nextFallbackChildren = nextProps.fallback;
+        var _primaryChildFragment = createWorkInProgress(
+          currentPrimaryChildFragment,
+          currentPrimaryChildFragment.pendingProps,
+          NoWork
+        );
+
+        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+          // Outside of concurrent mode, we commit the effects from the
+          var _progressedState = workInProgress.memoizedState;
+          var _progressedPrimaryChild =
+            _progressedState !== null
+              ? workInProgress.child.child
+              : workInProgress.child;
+          if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
+            _primaryChildFragment.child = _progressedPrimaryChild;
+          }
+        }
+
+        // Because primaryChildFragment is a new fiber that we're inserting as the
+        // parent of a new tree, we need to set its treeBaseDuration.
+        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
+          // treeBaseDuration is the sum of all the child tree base durations.
+          var treeBaseDuration = 0;
+          var hiddenChild = _primaryChildFragment.child;
+          while (hiddenChild !== null) {
+            treeBaseDuration += hiddenChild.treeBaseDuration;
+            hiddenChild = hiddenChild.sibling;
+          }
+          _primaryChildFragment.treeBaseDuration = treeBaseDuration;
+        }
+
+        // Clone the fallback child fragment, too. These we'll continue
+        // working on.
+        var _fallbackChildFragment = (_primaryChildFragment.sibling = createWorkInProgress(
+          currentFallbackChildFragment,
+          _nextFallbackChildren,
+          currentFallbackChildFragment.expirationTime
+        ));
+        child = _primaryChildFragment;
+        _primaryChildFragment.childExpirationTime = NoWork;
+        // Skip the primary children, and continue working on the
+        // fallback children.
+        next = _fallbackChildFragment;
+        child.return = next.return = workInProgress;
+      } else {
+        // No longer suspended. Switch back to showing the primary children,
+        // and remove the intermediate fragment fiber.
+        var _nextPrimaryChildren = nextProps.children;
+        var currentPrimaryChild = currentPrimaryChildFragment.child;
+        var primaryChild = reconcileChildFibers(
+          workInProgress,
+          currentPrimaryChild,
+          _nextPrimaryChildren,
+          renderExpirationTime
+        );
+
+        // If this render doesn't suspend, we need to delete the fallback
+        // children. Wait until the complete phase, after we've confirmed the
+        // fallback is no longer needed.
+        // TODO: Would it be better to store the fallback fragment on
+        // the stateNode?
+
+        // Continue rendering the children, like we normally do.
+        child = next = primaryChild;
+      }
+    } else {
+      // The current tree has not already timed out. That means the primary
+      // children are not wrapped in a fragment fiber.
+      var _currentPrimaryChild = current$$1.child;
+      if (nextDidTimeout) {
+        // Timed out. Wrap the children in a fragment fiber to keep them
+        // separate from the fallback children.
+        var _nextFallbackChildren2 = nextProps.fallback;
+        var _primaryChildFragment2 = createFiberFromFragment(
+          // It shouldn't matter what the pending props are because we aren't
+          // going to render this fragment.
+          null,
+          mode,
+          NoWork,
+          null
+        );
+        _primaryChildFragment2.child = _currentPrimaryChild;
+
+        // Even though we're creating a new fiber, there are no new children,
+        // because we're reusing an already mounted tree. So we don't need to
+        // schedule a placement.
+        // primaryChildFragment.effectTag |= Placement;
+
+        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+          // Outside of concurrent mode, we commit the effects from the
+          var _progressedState2 = workInProgress.memoizedState;
+          var _progressedPrimaryChild2 =
+            _progressedState2 !== null
+              ? workInProgress.child.child
+              : workInProgress.child;
+          _primaryChildFragment2.child = _progressedPrimaryChild2;
+        }
+
+        // Because primaryChildFragment is a new fiber that we're inserting as the
+        // parent of a new tree, we need to set its treeBaseDuration.
+        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
+          // treeBaseDuration is the sum of all the child tree base durations.
+          var _treeBaseDuration = 0;
+          var _hiddenChild = _primaryChildFragment2.child;
+          while (_hiddenChild !== null) {
+            _treeBaseDuration += _hiddenChild.treeBaseDuration;
+            _hiddenChild = _hiddenChild.sibling;
+          }
+          _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
+        }
+
+        // Create a fragment from the fallback children, too.
+        var _fallbackChildFragment2 = (_primaryChildFragment2.sibling = createFiberFromFragment(
+          _nextFallbackChildren2,
+          mode,
+          renderExpirationTime,
+          null
+        ));
+        _fallbackChildFragment2.effectTag |= Placement;
+        child = _primaryChildFragment2;
+        _primaryChildFragment2.childExpirationTime = NoWork;
+        // Skip the primary children, and continue working on the
+        // fallback children.
+        next = _fallbackChildFragment2;
+        child.return = next.return = workInProgress;
+      } else {
+        // Still haven't timed out.  Continue rendering the children, like we
+        // normally do.
+        var _nextPrimaryChildren2 = nextProps.children;
+        next = child = reconcileChildFibers(
+          workInProgress,
+          _currentPrimaryChild,
+          _nextPrimaryChildren2,
+          renderExpirationTime
+        );
+      }
+    }
   }
+
+  workInProgress.memoizedState = nextState;
+  workInProgress.child = child;
+  return next;
 }
 
 function updatePortalComponent(
@@ -11296,7 +12278,6 @@ function updatePortalComponent(
       nextChildren,
       renderExpirationTime
     );
-    memoizeProps(workInProgress, nextChildren);
   } else {
     reconcileChildren(
       current$$1,
@@ -11304,7 +12285,6 @@ function updatePortalComponent(
       nextChildren,
       renderExpirationTime
     );
-    memoizeProps(workInProgress, nextChildren);
   }
   return workInProgress.child;
 }
@@ -11321,7 +12301,6 @@ function updateContextProvider(
   var oldProps = workInProgress.memoizedProps;
 
   var newValue = newProps.value;
-  workInProgress.memoizedProps = newProps;
 
   {
     var providerPropTypes = workInProgress.type.propTypes;
@@ -11373,12 +12352,40 @@ function updateContextProvider(
   return workInProgress.child;
 }
 
+var hasWarnedAboutUsingContextAsConsumer = false;
+
 function updateContextConsumer(
   current$$1,
   workInProgress,
   renderExpirationTime
 ) {
   var context = workInProgress.type;
+  // The logic below for Context differs depending on PROD or DEV mode. In
+  // DEV mode, we create a separate object for Context.Consumer that acts
+  // like a proxy to Context. This proxy object adds unnecessary code in PROD
+  // so we use the old behaviour (Context.Consumer references Context) to
+  // reduce size and overhead. The separate object references context via
+  // a property called "_context", which also gives us the ability to check
+  // in DEV mode if this property exists or not and warn if it does not.
+  {
+    if (context._context === undefined) {
+      // This may be because it's a Context (rather than a Consumer).
+      // Or it may be because it's older React where they're the same thing.
+      // We only want to warn if we're sure it's a new React.
+      if (context !== context.Consumer) {
+        if (!hasWarnedAboutUsingContextAsConsumer) {
+          hasWarnedAboutUsingContextAsConsumer = true;
+          warning$1(
+            false,
+            "Rendering <Context> directly is not supported and will be removed in " +
+              "a future major release. Did you mean to render <Context.Consumer> instead?"
+          );
+        }
+      }
+    } else {
+      context = context._context;
+    }
+  }
   var newProps = workInProgress.pendingProps;
   var render = newProps.children;
 
@@ -11412,29 +12419,9 @@ function updateContextConsumer(
     newChildren,
     renderExpirationTime
   );
-  workInProgress.memoizedProps = newProps;
   return workInProgress.child;
 }
 
-/*
-  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
-    let child = firstChild;
-    do {
-      // Ensure that the first and last effect of the parent corresponds
-      // to the children's first and last effect.
-      if (!returnFiber.firstEffect) {
-        returnFiber.firstEffect = child.firstEffect;
-      }
-      if (child.lastEffect) {
-        if (returnFiber.lastEffect) {
-          returnFiber.lastEffect.nextEffect = child.firstEffect;
-        }
-        returnFiber.lastEffect = child.lastEffect;
-      }
-    } while (child = child.sibling);
-  }
-  */
-
 function bailoutOnAlreadyFinishedWork(
   current$$1,
   workInProgress,
@@ -11454,10 +12441,7 @@ function bailoutOnAlreadyFinishedWork(
 
   // Check if the children have any pending work.
   var childExpirationTime = workInProgress.childExpirationTime;
-  if (
-    childExpirationTime === NoWork ||
-    childExpirationTime > renderExpirationTime
-  ) {
+  if (childExpirationTime < renderExpirationTime) {
     // The children don't have any work either. We can skip them.
     // TODO: Once we add back resuming, we should check if the children are
     // a work-in-progress set. If so, we need to transfer their effects.
@@ -11470,17 +12454,6 @@ function bailoutOnAlreadyFinishedWork(
   }
 }
 
-// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
-function memoizeProps(workInProgress, nextProps) {
-  workInProgress.memoizedProps = nextProps;
-}
-
-function memoizeState(workInProgress, nextState) {
-  workInProgress.memoizedState = nextState;
-  // Don't reset the updateQueue, in case there are pending updates. Resetting
-  // is handled by processUpdateQueue.
-}
-
 function beginWork(current$$1, workInProgress, renderExpirationTime) {
   var updateExpirationTime = workInProgress.expirationTime;
 
@@ -11490,8 +12463,7 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
     if (
       oldProps === newProps &&
       !hasContextChanged() &&
-      (updateExpirationTime === NoWork ||
-        updateExpirationTime > renderExpirationTime)
+      updateExpirationTime < renderExpirationTime
     ) {
       // This fiber does not have any pending work. Bailout without entering
       // the begin phase. There's still some bookkeeping we that needs to be done
@@ -11511,14 +12483,6 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
           }
           break;
         }
-        case ClassComponentLazy: {
-          var thenable = workInProgress.type;
-          var _Component = getResultFromResolvedThenable(thenable);
-          if (isContextProvider(_Component)) {
-            pushContextProvider(workInProgress);
-          }
-          break;
-        }
         case HostPortal:
           pushHostContainer(
             workInProgress,
@@ -11535,6 +12499,46 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
             workInProgress.effectTag |= Update;
           }
           break;
+        case SuspenseComponent: {
+          var state = workInProgress.memoizedState;
+          var didTimeout = state !== null;
+          if (didTimeout) {
+            // If this boundary is currently timed out, we need to decide
+            // whether to retry the primary children, or to skip over it and
+            // go straight to the fallback. Check the priority of the primary
+            var primaryChildFragment = workInProgress.child;
+            var primaryChildExpirationTime =
+              primaryChildFragment.childExpirationTime;
+            if (
+              primaryChildExpirationTime !== NoWork &&
+              primaryChildExpirationTime >= renderExpirationTime
+            ) {
+              // The primary children have pending work. Use the normal path
+              // to attempt to render the primary children again.
+              return updateSuspenseComponent(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+            } else {
+              // The primary children do not have pending work with sufficient
+              // priority. Bailout.
+              var child = bailoutOnAlreadyFinishedWork(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+              if (child !== null) {
+                // The fallback children have pending work. Skip over the
+                // primary children and work on the fallback.
+                return child.sibling;
+              } else {
+                return null;
+              }
+            }
+          }
+          break;
+        }
       }
       return bailoutOnAlreadyFinishedWork(
         current$$1,
@@ -11549,64 +12553,53 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
 
   switch (workInProgress.tag) {
     case IndeterminateComponent: {
-      var _Component2 = workInProgress.type;
+      var elementType = workInProgress.elementType;
       return mountIndeterminateComponent(
         current$$1,
         workInProgress,
-        _Component2,
-        updateExpirationTime,
+        elementType,
         renderExpirationTime
       );
     }
-    case FunctionComponent: {
-      var _Component3 = workInProgress.type;
-      var unresolvedProps = workInProgress.pendingProps;
-      return updateFunctionComponent(
+    case LazyComponent: {
+      var _elementType = workInProgress.elementType;
+      return mountLazyComponent(
         current$$1,
         workInProgress,
-        _Component3,
-        unresolvedProps,
+        _elementType,
+        updateExpirationTime,
         renderExpirationTime
       );
     }
-    case FunctionComponentLazy: {
-      var _thenable = workInProgress.type;
-      var _Component4 = getResultFromResolvedThenable(_thenable);
-      var _unresolvedProps = workInProgress.pendingProps;
-      var child = updateFunctionComponent(
+    case FunctionComponent: {
+      var _Component = workInProgress.type;
+      var unresolvedProps = workInProgress.pendingProps;
+      var resolvedProps =
+        workInProgress.elementType === _Component
+          ? unresolvedProps
+          : resolveDefaultProps(_Component, unresolvedProps);
+      return updateFunctionComponent(
         current$$1,
         workInProgress,
-        _Component4,
-        resolveDefaultProps(_Component4, _unresolvedProps),
+        _Component,
+        resolvedProps,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps;
-      return child;
     }
     case ClassComponent: {
-      var _Component5 = workInProgress.type;
-      var _unresolvedProps2 = workInProgress.pendingProps;
+      var _Component2 = workInProgress.type;
+      var _unresolvedProps = workInProgress.pendingProps;
+      var _resolvedProps =
+        workInProgress.elementType === _Component2
+          ? _unresolvedProps
+          : resolveDefaultProps(_Component2, _unresolvedProps);
       return updateClassComponent(
         current$$1,
         workInProgress,
-        _Component5,
-        _unresolvedProps2,
-        renderExpirationTime
-      );
-    }
-    case ClassComponentLazy: {
-      var _thenable2 = workInProgress.type;
-      var _Component6 = getResultFromResolvedThenable(_thenable2);
-      var _unresolvedProps3 = workInProgress.pendingProps;
-      var _child = updateClassComponent(
-        current$$1,
-        workInProgress,
-        _Component6,
-        resolveDefaultProps(_Component6, _unresolvedProps3),
+        _Component2,
+        _resolvedProps,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps3;
-      return _child;
     }
     case HostRoot:
       return updateHostRoot(current$$1, workInProgress, renderExpirationTime);
@@ -11618,8 +12611,8 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
     case HostText:
       return updateHostText(current$$1, workInProgress);
-    case PlaceholderComponent:
-      return updatePlaceholderComponent(
+    case SuspenseComponent:
+      return updateSuspenseComponent(
         current$$1,
         workInProgress,
         renderExpirationTime
@@ -11632,27 +12625,18 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
     case ForwardRef: {
       var type = workInProgress.type;
+      var _unresolvedProps2 = workInProgress.pendingProps;
+      var _resolvedProps2 =
+        workInProgress.elementType === type
+          ? _unresolvedProps2
+          : resolveDefaultProps(type, _unresolvedProps2);
       return updateForwardRef(
         current$$1,
         workInProgress,
         type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    }
-    case ForwardRefLazy: {
-      var _thenable3 = workInProgress.type;
-      var _Component7 = getResultFromResolvedThenable(_thenable3);
-      var _unresolvedProps4 = workInProgress.pendingProps;
-      var _child2 = updateForwardRef(
-        current$$1,
-        workInProgress,
-        _Component7,
-        resolveDefaultProps(_Component7, _unresolvedProps4),
+        _resolvedProps2,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps4;
-      return _child2;
     }
     case Fragment:
       return updateFragment(current$$1, workInProgress, renderExpirationTime);
@@ -11672,31 +12656,43 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         workInProgress,
         renderExpirationTime
       );
-    case PureComponent: {
+    case MemoComponent: {
       var _type = workInProgress.type;
-      return updatePureComponent(
+      var _unresolvedProps3 = workInProgress.pendingProps;
+      var _resolvedProps3 = resolveDefaultProps(_type.type, _unresolvedProps3);
+      return updateMemoComponent(
         current$$1,
         workInProgress,
         _type,
-        workInProgress.pendingProps,
+        _resolvedProps3,
         updateExpirationTime,
         renderExpirationTime
       );
     }
-    case PureComponentLazy: {
-      var _thenable4 = workInProgress.type;
-      var _Component8 = getResultFromResolvedThenable(_thenable4);
-      var _unresolvedProps5 = workInProgress.pendingProps;
-      var _child3 = updatePureComponent(
+    case SimpleMemoComponent: {
+      return updateSimpleMemoComponent(
         current$$1,
         workInProgress,
-        _Component8,
-        resolveDefaultProps(_Component8, _unresolvedProps5),
+        workInProgress.type,
+        workInProgress.pendingProps,
         updateExpirationTime,
         renderExpirationTime
       );
-      workInProgress.memoizedProps = _unresolvedProps5;
-      return _child3;
+    }
+    case IncompleteClassComponent: {
+      var _Component3 = workInProgress.type;
+      var _unresolvedProps4 = workInProgress.pendingProps;
+      var _resolvedProps4 =
+        workInProgress.elementType === _Component3
+          ? _unresolvedProps4
+          : resolveDefaultProps(_Component3, _unresolvedProps4);
+      return mountIncompleteClassComponent(
+        current$$1,
+        workInProgress,
+        _Component3,
+        _resolvedProps4,
+        renderExpirationTime
+      );
     }
     default:
       invariant(
@@ -11708,51 +12704,57 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
 }
 
 function markUpdate(workInProgress) {
-  // Tag the fiber with an update effect. This turns a Placement into
-  // a PlacementAndUpdate.
-  workInProgress.effectTag |= Update;
-}
-
-function markRef$1(workInProgress) {
-  workInProgress.effectTag |= Ref;
-}
-
-function appendAllChildren(parent, workInProgress) {
-  // We only have the top Fiber that was created but we need recurse down its
-  // children to find all the terminal nodes.
-  var node = workInProgress.child;
-  while (node !== null) {
-    if (node.tag === HostComponent || node.tag === HostText) {
-      appendInitialChild(parent, node.stateNode);
-    } else if (node.tag === HostPortal) {
-      // If we have a portal child, then we don't want to traverse
-      // down its children. Instead, we'll get insertions from each child in
-      // the portal directly.
-    } else if (node.child !== null) {
-      node.child.return = node;
-      node = node.child;
-      continue;
-    }
-    if (node === workInProgress) {
-      return;
-    }
-    while (node.sibling === null) {
-      if (node.return === null || node.return === workInProgress) {
-        return;
-      }
-      node = node.return;
-    }
-    node.sibling.return = node.return;
-    node = node.sibling;
-  }
+  // Tag the fiber with an update effect. This turns a Placement into
+  // a PlacementAndUpdate.
+  workInProgress.effectTag |= Update;
+}
+
+function markRef$1(workInProgress) {
+  workInProgress.effectTag |= Ref;
 }
 
+var appendAllChildren = void 0;
 var updateHostContainer = void 0;
 var updateHostComponent$1 = void 0;
 var updateHostText$1 = void 0;
 if (supportsMutation) {
   // Mutation mode
 
+  appendAllChildren = function(
+    parent,
+    workInProgress,
+    needsVisibilityToggle,
+    isHidden
+  ) {
+    // We only have the top Fiber that was created but we need recurse down its
+    // children to find all the terminal nodes.
+    var node = workInProgress.child;
+    while (node !== null) {
+      if (node.tag === HostComponent || node.tag === HostText) {
+        appendInitialChild(parent, node.stateNode);
+      } else if (node.tag === HostPortal) {
+        // If we have a portal child, then we don't want to traverse
+        // down its children. Instead, we'll get insertions from each child in
+        // the portal directly.
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+      if (node === workInProgress) {
+        return;
+      }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === workInProgress) {
+          return;
+        }
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  };
+
   updateHostContainer = function(workInProgress) {
     // Noop
   };
@@ -11806,26 +12808,202 @@ if (supportsMutation) {
 } else if (supportsPersistence) {
   // Persistent host tree mode
 
+  appendAllChildren = function(
+    parent,
+    workInProgress,
+    needsVisibilityToggle,
+    isHidden
+  ) {
+    // We only have the top Fiber that was created but we need recurse down its
+    // children to find all the terminal nodes.
+    var node = workInProgress.child;
+    while (node !== null) {
+      // eslint-disable-next-line no-labels
+      branches: if (node.tag === HostComponent) {
+        var instance = node.stateNode;
+        if (needsVisibilityToggle) {
+          var props = node.memoizedProps;
+          var type = node.type;
+          if (isHidden) {
+            // This child is inside a timed out tree. Hide it.
+            instance = cloneHiddenInstance(instance, type, props, node);
+          } else {
+            // This child was previously inside a timed out tree. If it was not
+            // updated during this render, it may need to be unhidden. Clone
+            // again to be sure.
+            instance = cloneUnhiddenInstance(instance, type, props, node);
+          }
+          node.stateNode = instance;
+        }
+        appendInitialChild(parent, instance);
+      } else if (node.tag === HostText) {
+        var _instance = node.stateNode;
+        if (needsVisibilityToggle) {
+          var text = node.memoizedProps;
+          var rootContainerInstance = getRootHostContainer();
+          var currentHostContext = getHostContext();
+          if (isHidden) {
+            _instance = createHiddenTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          } else {
+            _instance = createTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          }
+          node.stateNode = _instance;
+        }
+        appendInitialChild(parent, _instance);
+      } else if (node.tag === HostPortal) {
+        // If we have a portal child, then we don't want to traverse
+        // down its children. Instead, we'll get insertions from each child in
+        // the portal directly.
+      } else if (node.tag === SuspenseComponent) {
+        var current = node.alternate;
+        if (current !== null) {
+          var oldState = current.memoizedState;
+          var newState = node.memoizedState;
+          var oldIsHidden = oldState !== null;
+          var newIsHidden = newState !== null;
+          if (oldIsHidden !== newIsHidden) {
+            // The placeholder either just timed out or switched back to the normal
+            // children after having previously timed out. Toggle the visibility of
+            // the direct host children.
+            var primaryChildParent = newIsHidden ? node.child : node;
+            if (primaryChildParent !== null) {
+              appendAllChildren(parent, primaryChildParent, true, newIsHidden);
+            }
+            // eslint-disable-next-line no-labels
+            break branches;
+          }
+        }
+        if (node.child !== null) {
+          // Continue traversing like normal
+          node.child.return = node;
+          node = node.child;
+          continue;
+        }
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+      // $FlowFixMe This is correct but Flow is confused by the labeled break.
+      node = node;
+      if (node === workInProgress) {
+        return;
+      }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === workInProgress) {
+          return;
+        }
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  };
+
   // An unfortunate fork of appendAllChildren because we have two different parent types.
   var appendAllChildrenToContainer = function(
     containerChildSet,
-    workInProgress
+    workInProgress,
+    needsVisibilityToggle,
+    isHidden
   ) {
     // We only have the top Fiber that was created but we need recurse down its
     // children to find all the terminal nodes.
     var node = workInProgress.child;
     while (node !== null) {
-      if (node.tag === HostComponent || node.tag === HostText) {
-        appendChildToContainerChildSet(containerChildSet, node.stateNode);
+      // eslint-disable-next-line no-labels
+      branches: if (node.tag === HostComponent) {
+        var instance = node.stateNode;
+        if (needsVisibilityToggle) {
+          var props = node.memoizedProps;
+          var type = node.type;
+          if (isHidden) {
+            // This child is inside a timed out tree. Hide it.
+            instance = cloneHiddenInstance(instance, type, props, node);
+          } else {
+            // This child was previously inside a timed out tree. If it was not
+            // updated during this render, it may need to be unhidden. Clone
+            // again to be sure.
+            instance = cloneUnhiddenInstance(instance, type, props, node);
+          }
+          node.stateNode = instance;
+        }
+        appendChildToContainerChildSet(containerChildSet, instance);
+      } else if (node.tag === HostText) {
+        var _instance2 = node.stateNode;
+        if (needsVisibilityToggle) {
+          var text = node.memoizedProps;
+          var rootContainerInstance = getRootHostContainer();
+          var currentHostContext = getHostContext();
+          if (isHidden) {
+            _instance2 = createHiddenTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          } else {
+            _instance2 = createTextInstance(
+              text,
+              rootContainerInstance,
+              currentHostContext,
+              workInProgress
+            );
+          }
+          node.stateNode = _instance2;
+        }
+        appendChildToContainerChildSet(containerChildSet, _instance2);
       } else if (node.tag === HostPortal) {
         // If we have a portal child, then we don't want to traverse
         // down its children. Instead, we'll get insertions from each child in
         // the portal directly.
+      } else if (node.tag === SuspenseComponent) {
+        var current = node.alternate;
+        if (current !== null) {
+          var oldState = current.memoizedState;
+          var newState = node.memoizedState;
+          var oldIsHidden = oldState !== null;
+          var newIsHidden = newState !== null;
+          if (oldIsHidden !== newIsHidden) {
+            // The placeholder either just timed out or switched back to the normal
+            // children after having previously timed out. Toggle the visibility of
+            // the direct host children.
+            var primaryChildParent = newIsHidden ? node.child : node;
+            if (primaryChildParent !== null) {
+              appendAllChildrenToContainer(
+                containerChildSet,
+                primaryChildParent,
+                true,
+                newIsHidden
+              );
+            }
+            // eslint-disable-next-line no-labels
+            break branches;
+          }
+        }
+        if (node.child !== null) {
+          // Continue traversing like normal
+          node.child.return = node;
+          node = node.child;
+          continue;
+        }
       } else if (node.child !== null) {
         node.child.return = node;
         node = node.child;
         continue;
       }
+      // $FlowFixMe This is correct but Flow is confused by the labeled break.
+      node = node;
       if (node === workInProgress) {
         return;
       }
@@ -11848,7 +13026,7 @@ if (supportsMutation) {
       var container = portalOrRoot.containerInfo;
       var newChildSet = createContainerChildSet(container);
       // If children might have changed, we have to add them all to the set.
-      appendAllChildrenToContainer(newChildSet, workInProgress);
+      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
       portalOrRoot.pendingChildren = newChildSet;
       // Schedule an update on the container to swap out the container.
       markUpdate(workInProgress);
@@ -11921,7 +13099,7 @@ if (supportsMutation) {
       markUpdate(workInProgress);
     } else {
       // If children might have changed, we have to add them all to the set.
-      appendAllChildren(newInstance, workInProgress);
+      appendAllChildren(newInstance, workInProgress, false, false);
     }
   };
   updateHostText$1 = function(current, workInProgress, oldText, newText) {
@@ -11963,8 +13141,12 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   var newProps = workInProgress.pendingProps;
 
   switch (workInProgress.tag) {
+    case IndeterminateComponent:
+      break;
+    case LazyComponent:
+      break;
+    case SimpleMemoComponent:
     case FunctionComponent:
-    case FunctionComponentLazy:
       break;
     case ClassComponent: {
       var Component = workInProgress.type;
@@ -11973,13 +13155,6 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       }
       break;
     }
-    case ClassComponentLazy: {
-      var _Component = getResultFromResolvedThenable(workInProgress.type);
-      if (isContextProvider(_Component)) {
-        popContext(workInProgress);
-      }
-      break;
-    }
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
@@ -12055,7 +13230,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
             workInProgress
           );
 
-          appendAllChildren(instance, workInProgress);
+          appendAllChildren(instance, workInProgress, false, false);
 
           // Certain renderers require commit-time effects for initial mount.
           // (eg DOM renderer supports auto-focus for certain elements).
@@ -12116,10 +13291,54 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       break;
     }
     case ForwardRef:
-    case ForwardRefLazy:
       break;
-    case PlaceholderComponent:
+    case SuspenseComponent: {
+      var nextState = workInProgress.memoizedState;
+      if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
+        // Something suspended. Re-render with the fallback children.
+        workInProgress.expirationTime = renderExpirationTime;
+        // Do not reset the effect list.
+        return workInProgress;
+      }
+
+      var nextDidTimeout = nextState !== null;
+      var prevDidTimeout = current !== null && current.memoizedState !== null;
+
+      if (current !== null && !nextDidTimeout && prevDidTimeout) {
+        // We just switched from the fallback to the normal children. Delete
+        // the fallback.
+        // TODO: Would it be better to store the fallback fragment on
+        var currentFallbackChild = current.child.sibling;
+        if (currentFallbackChild !== null) {
+          // Deletions go at the beginning of the return fiber's effect list
+          var first = workInProgress.firstEffect;
+          if (first !== null) {
+            workInProgress.firstEffect = currentFallbackChild;
+            currentFallbackChild.nextEffect = first;
+          } else {
+            workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
+            currentFallbackChild.nextEffect = null;
+          }
+          currentFallbackChild.effectTag = Deletion;
+        }
+      }
+
+      // The children either timed out after previously being visible, or
+      // were restored after previously being hidden. Schedule an effect
+      // to update their visiblity.
+      if (
+        //
+        nextDidTimeout !== prevDidTimeout ||
+        // Outside concurrent mode, the primary children commit in an
+        // inconsistent state, even if they are hidden. So if they are hidden,
+        // we need to schedule an effect to re-hide them, just in case.
+        ((workInProgress.effectTag & ConcurrentMode) === NoContext &&
+          nextDidTimeout)
+      ) {
+        workInProgress.effectTag |= Update;
+      }
       break;
+    }
     case Fragment:
       break;
     case Mode:
@@ -12136,18 +13355,17 @@ function completeWork(current, workInProgress, renderExpirationTime) {
       break;
     case ContextConsumer:
       break;
-    case PureComponent:
-    case PureComponentLazy:
+    case MemoComponent:
       break;
-    // Error cases
-    case IndeterminateComponent:
-      invariant(
-        false,
-        "An indeterminate component should have become determinate before " +
-          "completing. This error is likely caused by a bug in React. Please " +
-          "file an issue."
-      );
-    // eslint-disable-next-line no-fallthrough
+    case IncompleteClassComponent: {
+      // Same as class component case. I put it down here so that the tags are
+      // sequential to ensure this switch is compiled to a jump table.
+      var _Component = workInProgress.type;
+      if (isContextProvider(_Component)) {
+        popContext(workInProgress);
+      }
+      break;
+    }
     default:
       invariant(
         false,
@@ -12159,6 +13377,17 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   return null;
 }
 
+function shouldCaptureSuspense(current, workInProgress) {
+  // In order to capture, the Suspense component must have a fallback prop.
+  if (workInProgress.memoizedProps.fallback === undefined) {
+    return false;
+  }
+  // If it was the primary children that just suspended, capture and render the
+  // fallback. Otherwise, don't capture and bubble to the next boundary.
+  var nextState = workInProgress.memoizedState;
+  return nextState === null;
+}
+
 // Module provided by RN:
 /**
  * Intercept lifecycle errors and ensure they are shown with the correct stack
@@ -12275,8 +13504,6 @@ function logCapturedError(capturedError) {
   }
 }
 
-var emptyObject$1 = {};
-
 var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
 {
   didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
@@ -12361,19 +13588,60 @@ function safelyDetachRef(current$$1) {
   }
 }
 
+function safelyCallDestroy(current$$1, destroy) {
+  {
+    invokeGuardedCallback(null, destroy, null);
+    if (hasCaughtError()) {
+      var error = clearCaughtError();
+      captureCommitPhaseError(current$$1, error);
+    }
+  }
+}
+
 function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case SimpleMemoComponent: {
+      commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
+      return;
+    }
+    case ClassComponent: {
       if (finishedWork.effectTag & Snapshot) {
         if (current$$1 !== null) {
           var prevProps = current$$1.memoizedProps;
           var prevState = current$$1.memoizedState;
           startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
           var instance = finishedWork.stateNode;
-          instance.props = finishedWork.memoizedProps;
-          instance.state = finishedWork.memoizedState;
-          var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
+          // We could update instance props and state here,
+          // but instead we rely on them being set during last render.
+          // TODO: revisit this when we implement resuming.
+          {
+            if (finishedWork.type === finishedWork.elementType) {
+              !(instance.props === finishedWork.memoizedProps)
+                ? warning$1(
+                    false,
+                    "Expected instance props to match memoized props before " +
+                      "getSnapshotBeforeUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+              !(instance.state === finishedWork.memoizedState)
+                ? warning$1(
+                    false,
+                    "Expected instance state to match memoized state before " +
+                      "getSnapshotBeforeUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+            }
+          }
+          var snapshot = instance.getSnapshotBeforeUpdate(
+            finishedWork.elementType === finishedWork.type
+              ? prevProps
+              : resolveDefaultProps(finishedWork.type, prevProps),
+            prevState
+          );
           {
             var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
             if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
@@ -12396,6 +13664,7 @@ function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
     case HostComponent:
     case HostText:
     case HostPortal:
+    case IncompleteClassComponent:
       // Nothing to do for these component types
       return;
     default: {
@@ -12408,6 +13677,58 @@ function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
   }
 }
 
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  if (!enableHooks) {
+    return;
+  }
+  var updateQueue = finishedWork.updateQueue;
+  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
+  if (lastEffect !== null) {
+    var firstEffect = lastEffect.next;
+    var effect = firstEffect;
+    do {
+      if ((effect.tag & unmountTag) !== NoEffect$1) {
+        // Unmount
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        if (destroy !== null) {
+          destroy();
+        }
+      }
+      if ((effect.tag & mountTag) !== NoEffect$1) {
+        // Mount
+        var create = effect.create;
+        var _destroy = create();
+        if (typeof _destroy !== "function") {
+          {
+            if (_destroy !== null && _destroy !== undefined) {
+              warningWithoutStack$1(
+                false,
+                "useEffect function must return a cleanup function or " +
+                  "nothing.%s%s",
+                typeof _destroy.then === "function"
+                  ? " Promises and useEffect(async () => ...) are not " +
+                    "supported, but you can call an async function inside an " +
+                    "effect."
+                  : "",
+                getStackByFiberInDevAndProd(finishedWork)
+              );
+            }
+          }
+          _destroy = null;
+        }
+        effect.destroy = _destroy;
+      }
+      effect = effect.next;
+    } while (effect !== firstEffect);
+  }
+}
+
+function commitPassiveHookEffects(finishedWork) {
+  commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
+  commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
+}
+
 function commitLifeCycles(
   finishedRoot,
   current$$1,
@@ -12415,22 +13736,75 @@ function commitLifeCycles(
   committedExpirationTime
 ) {
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case SimpleMemoComponent: {
+      commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
+      break;
+    }
+    case ClassComponent: {
       var instance = finishedWork.stateNode;
       if (finishedWork.effectTag & Update) {
         if (current$$1 === null) {
           startPhaseTimer(finishedWork, "componentDidMount");
-          instance.props = finishedWork.memoizedProps;
-          instance.state = finishedWork.memoizedState;
+          // We could update instance props and state here,
+          // but instead we rely on them being set during last render.
+          // TODO: revisit this when we implement resuming.
+          {
+            if (finishedWork.type === finishedWork.elementType) {
+              !(instance.props === finishedWork.memoizedProps)
+                ? warning$1(
+                    false,
+                    "Expected instance props to match memoized props before " +
+                      "componentDidMount. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+              !(instance.state === finishedWork.memoizedState)
+                ? warning$1(
+                    false,
+                    "Expected instance state to match memoized state before " +
+                      "componentDidMount. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+            }
+          }
           instance.componentDidMount();
           stopPhaseTimer();
         } else {
-          var prevProps = current$$1.memoizedProps;
+          var prevProps =
+            finishedWork.elementType === finishedWork.type
+              ? current$$1.memoizedProps
+              : resolveDefaultProps(
+                  finishedWork.type,
+                  current$$1.memoizedProps
+                );
           var prevState = current$$1.memoizedState;
           startPhaseTimer(finishedWork, "componentDidUpdate");
-          instance.props = finishedWork.memoizedProps;
-          instance.state = finishedWork.memoizedState;
+          // We could update instance props and state here,
+          // but instead we rely on them being set during last render.
+          // TODO: revisit this when we implement resuming.
+          {
+            if (finishedWork.type === finishedWork.elementType) {
+              !(instance.props === finishedWork.memoizedProps)
+                ? warning$1(
+                    false,
+                    "Expected instance props to match memoized props before " +
+                      "componentDidUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+              !(instance.state === finishedWork.memoizedState)
+                ? warning$1(
+                    false,
+                    "Expected instance state to match memoized state before " +
+                      "componentDidUpdate. This is likely due to a bug in React. " +
+                      "Please file an issue."
+                  )
+                : void 0;
+            }
+          }
           instance.componentDidUpdate(
             prevProps,
             prevState,
@@ -12441,8 +13815,29 @@ function commitLifeCycles(
       }
       var updateQueue = finishedWork.updateQueue;
       if (updateQueue !== null) {
-        instance.props = finishedWork.memoizedProps;
-        instance.state = finishedWork.memoizedState;
+        {
+          if (finishedWork.type === finishedWork.elementType) {
+            !(instance.props === finishedWork.memoizedProps)
+              ? warning$1(
+                  false,
+                  "Expected instance props to match memoized props before " +
+                    "processing the update queue. This is likely due to a bug in React. " +
+                    "Please file an issue."
+                )
+              : void 0;
+            !(instance.state === finishedWork.memoizedState)
+              ? warning$1(
+                  false,
+                  "Expected instance state to match memoized state before " +
+                    "processing the update queue. This is likely due to a bug in React. " +
+                    "Please file an issue."
+                )
+              : void 0;
+          }
+        }
+        // We could update instance props and state here,
+        // but instead we rely on them being set during last render.
+        // TODO: revisit this when we implement resuming.
         commitUpdateQueue(
           finishedWork,
           updateQueue,
@@ -12462,7 +13857,6 @@ function commitLifeCycles(
               _instance = getPublicInstance(finishedWork.child.stateNode);
               break;
             case ClassComponent:
-            case ClassComponentLazy:
               _instance = finishedWork.child.stateNode;
               break;
           }
@@ -12525,25 +13919,10 @@ function commitLifeCycles(
       }
       return;
     }
-    case PlaceholderComponent: {
-      if (enableSuspense) {
-        if ((finishedWork.mode & StrictMode) === NoEffect) {
-          // In loose mode, a placeholder times out by scheduling a synchronous
-          // update in the commit phase. Use `updateQueue` field to signal that
-          // the Timeout needs to switch to the placeholder. We don't need an
-          // entire queue. Any non-null value works.
-          // $FlowFixMe - Intentionally using a value other than an UpdateQueue.
-          finishedWork.updateQueue = emptyObject$1;
-          scheduleWork(finishedWork, Sync);
-        } else {
-          // In strict mode, the Update effect is used to record the time at
-          // which the placeholder timed out.
-          var currentTime = requestCurrentTime();
-          finishedWork.stateNode = { timedOutAt: currentTime };
-        }
-      }
-      return;
-    }
+    case SuspenseComponent:
+      break;
+    case IncompleteClassComponent:
+      break;
     default: {
       invariant(
         false,
@@ -12554,6 +13933,54 @@ function commitLifeCycles(
   }
 }
 
+function hideOrUnhideAllChildren(finishedWork, isHidden) {
+  if (supportsMutation) {
+    // We only have the top Fiber that was inserted but we need recurse down its
+    var node = finishedWork;
+    while (true) {
+      if (node.tag === HostComponent) {
+        var instance = node.stateNode;
+        if (isHidden) {
+          hideInstance(instance);
+        } else {
+          unhideInstance(node.stateNode, node.memoizedProps);
+        }
+      } else if (node.tag === HostText) {
+        var _instance3 = node.stateNode;
+        if (isHidden) {
+          hideTextInstance(_instance3);
+        } else {
+          unhideTextInstance(_instance3, node.memoizedProps);
+        }
+      } else if (
+        node.tag === SuspenseComponent &&
+        node.memoizedState !== null
+      ) {
+        // Found a nested Suspense component that timed out. Skip over the
+        var fallbackChildFragment = node.child.sibling;
+        fallbackChildFragment.return = node;
+        node = fallbackChildFragment;
+        continue;
+      } else if (node.child !== null) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+      if (node === finishedWork) {
+        return;
+      }
+      while (node.sibling === null) {
+        if (node.return === null || node.return === finishedWork) {
+          return;
+        }
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  }
+}
+
 function commitAttachRef(finishedWork) {
   var ref = finishedWork.ref;
   if (ref !== null) {
@@ -12604,8 +14031,28 @@ function commitUnmount(current$$1) {
   onCommitUnmount(current$$1);
 
   switch (current$$1.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case MemoComponent:
+    case SimpleMemoComponent: {
+      var updateQueue = current$$1.updateQueue;
+      if (updateQueue !== null) {
+        var lastEffect = updateQueue.lastEffect;
+        if (lastEffect !== null) {
+          var firstEffect = lastEffect.next;
+          var effect = firstEffect;
+          do {
+            var destroy = effect.destroy;
+            if (destroy !== null) {
+              safelyCallDestroy(current$$1, destroy);
+            }
+            effect = effect.next;
+          } while (effect !== firstEffect);
+        }
+      }
+      break;
+    }
+    case ClassComponent: {
       safelyDetachRef(current$$1);
       var instance = current$$1.stateNode;
       if (typeof instance.componentWillUnmount === "function") {
@@ -12697,8 +14144,7 @@ function commitContainer(finishedWork) {
   }
 
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case ClassComponent: {
       return;
     }
     case HostComponent: {
@@ -12972,13 +14418,29 @@ function commitDeletion(current$$1) {
 
 function commitWork(current$$1, finishedWork) {
   if (!supportsMutation) {
+    switch (finishedWork.tag) {
+      case FunctionComponent:
+      case ForwardRef:
+      case MemoComponent:
+      case SimpleMemoComponent: {
+        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
+        return;
+      }
+    }
+
     commitContainer(finishedWork);
     return;
   }
 
   switch (finishedWork.tag) {
-    case ClassComponent:
-    case ClassComponentLazy: {
+    case FunctionComponent:
+    case ForwardRef:
+    case MemoComponent:
+    case SimpleMemoComponent: {
+      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
+      return;
+    }
+    case ClassComponent: {
       return;
     }
     case HostComponent: {
@@ -13029,7 +14491,30 @@ function commitWork(current$$1, finishedWork) {
     case Profiler: {
       return;
     }
-    case PlaceholderComponent: {
+    case SuspenseComponent: {
+      var newState = finishedWork.memoizedState;
+
+      var newDidTimeout = void 0;
+      var primaryChildParent = finishedWork;
+      if (newState === null) {
+        newDidTimeout = false;
+      } else {
+        newDidTimeout = true;
+        primaryChildParent = finishedWork.child;
+        if (newState.timedOutAt === NoWork) {
+          // If the children had not already timed out, record the time.
+          // This is used to compute the elapsed time during subsequent
+          // attempts to render the children.
+          newState.timedOutAt = requestCurrentTime();
+        }
+      }
+
+      if (primaryChildParent !== null) {
+        hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
+      }
+      return;
+    }
+    case IncompleteClassComponent: {
       return;
     }
     default: {
@@ -13046,11 +14531,7 @@ function commitResetTextContent(current$$1) {
   if (!supportsMutation) {
     return;
   }
-  resetTextContent(current$$1.stateNode);
-}
-
-function NoopComponent() {
-  return null;
+  resetTextContent(current$$1.stateNode);
 }
 
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
@@ -13129,7 +14610,6 @@ function throwException(
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
   if (
-    enableSuspense &&
     value !== null &&
     typeof value === "object" &&
     typeof value.then === "function"
@@ -13146,25 +14626,20 @@ function throwException(
     var earliestTimeoutMs = -1;
     var startTimeMs = -1;
     do {
-      if (_workInProgress.tag === PlaceholderComponent) {
-        var current = _workInProgress.alternate;
-        if (
-          current !== null &&
-          current.memoizedState === true &&
-          current.stateNode !== null
-        ) {
-          // Reached a placeholder that already timed out. Each timed out
-          // placeholder acts as the root of a new suspense boundary.
-
-          // Use the time at which the placeholder timed out as the start time
-          // for the current render.
-          var timedOutAt = current.stateNode.timedOutAt;
-          startTimeMs = expirationTimeToMs(timedOutAt);
-
-          // Do not search any further.
-          break;
+      if (_workInProgress.tag === SuspenseComponent) {
+        var current$$1 = _workInProgress.alternate;
+        if (current$$1 !== null) {
+          var currentState = current$$1.memoizedState;
+          if (currentState !== null) {
+            // Reached a boundary that already timed out. Do not search
+            // any further.
+            var timedOutAt = currentState.timedOutAt;
+            startTimeMs = expirationTimeToMs(timedOutAt);
+            // Do not search any further.
+            break;
+          }
         }
-        var timeoutPropMs = _workInProgress.pendingProps.delayMs;
+        var timeoutPropMs = _workInProgress.pendingProps.maxDuration;
         if (typeof timeoutPropMs === "number") {
           if (timeoutPropMs <= 0) {
             earliestTimeoutMs = 0;
@@ -13179,132 +14654,124 @@ function throwException(
       _workInProgress = _workInProgress.return;
     } while (_workInProgress !== null);
 
-    // Schedule the nearest Placeholder to re-render the timed out view.
+    // Schedule the nearest Suspense to re-render the timed out view.
     _workInProgress = returnFiber;
     do {
-      if (_workInProgress.tag === PlaceholderComponent) {
-        var didTimeout = _workInProgress.memoizedState;
-        if (!didTimeout) {
-          // Found the nearest boundary.
-
-          // If the boundary is not in concurrent mode, we should not suspend, and
-          // likewise, when the promise resolves, we should ping synchronously.
-          var pingTime =
-            (_workInProgress.mode & ConcurrentMode) === NoEffect
-              ? Sync
-              : renderExpirationTime;
-
-          // Attach a listener to the promise to "ping" the root and retry.
-          var onResolveOrReject = retrySuspendedRoot.bind(
-            null,
-            root,
-            _workInProgress,
-            pingTime
-          );
-          if (enableSchedulerTracing) {
-            onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
-          }
-          thenable.then(onResolveOrReject, onResolveOrReject);
-
-          // If the boundary is outside of strict mode, we should *not* suspend
-          // the commit. Pretend as if the suspended component rendered null and
-          // keep rendering. In the commit phase, we'll schedule a subsequent
-          // synchronous update to re-render the Placeholder.
-          //
-          // Note: It doesn't matter whether the component that suspended was
-          // inside a strict mode tree. If the Placeholder is outside of it, we
-          // should *not* suspend the commit.
-          if ((_workInProgress.mode & StrictMode) === NoEffect) {
-            _workInProgress.effectTag |= Update;
-
-            // Unmount the source fiber's children
-            var nextChildren = null;
-            reconcileChildren(
-              sourceFiber.alternate,
-              sourceFiber,
-              nextChildren,
-              renderExpirationTime
-            );
-            sourceFiber.effectTag &= ~Incomplete;
-            if (sourceFiber.tag === IndeterminateComponent) {
-              // Let's just assume it's a function component. This fiber will
-              // be unmounted in the immediate next commit, anyway.
-              sourceFiber.tag = FunctionComponent;
+      if (
+        _workInProgress.tag === SuspenseComponent &&
+        shouldCaptureSuspense(_workInProgress.alternate, _workInProgress)
+      ) {
+        // Found the nearest boundary.
+
+        // If the boundary is not in concurrent mode, we should not suspend, and
+        // likewise, when the promise resolves, we should ping synchronously.
+        var pingTime =
+          (_workInProgress.mode & ConcurrentMode) === NoEffect
+            ? Sync
+            : renderExpirationTime;
+
+        // Attach a listener to the promise to "ping" the root and retry.
+        var onResolveOrReject = retrySuspendedRoot.bind(
+          null,
+          root,
+          _workInProgress,
+          sourceFiber,
+          pingTime
+        );
+        if (enableSchedulerTracing) {
+          onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
+        }
+        thenable.then(onResolveOrReject, onResolveOrReject);
+
+        // If the boundary is outside of concurrent mode, we should *not*
+        // suspend the commit. Pretend as if the suspended component rendered
+        // null and keep rendering. In the commit phase, we'll schedule a
+        // subsequent synchronous update to re-render the Suspense.
+        //
+        // Note: It doesn't matter whether the component that suspended was
+        // inside a concurrent mode tree. If the Suspense is outside of it, we
+        // should *not* suspend the commit.
+        if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
+          _workInProgress.effectTag |= DidCapture;
+
+          // We're going to commit this fiber even though it didn't complete.
+          // But we shouldn't call any lifecycle methods or callbacks. Remove
+          // all lifecycle effect tags.
+          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
+
+          if (sourceFiber.tag === ClassComponent) {
+            var _current = sourceFiber.alternate;
+            if (_current === null) {
+              // This is a new mount. Change the tag so it's not mistaken for a
+              // completed class component. For example, we should not call
+              // componentWillUnmount if it is deleted.
+              sourceFiber.tag = IncompleteClassComponent;
             }
+          }
 
-            if (
-              sourceFiber.tag === ClassComponent ||
-              sourceFiber.tag === ClassComponentLazy
-            ) {
-              // We're going to commit this fiber even though it didn't
-              // complete. But we shouldn't call any lifecycle methods or
-              // callbacks. Remove all lifecycle effect tags.
-              sourceFiber.effectTag &= ~LifecycleEffectMask;
-              if (sourceFiber.alternate === null) {
-                // We're about to mount a class component that doesn't have an
-                // instance. Turn this into a dummy function component instead,
-                // to prevent type errors. This is a bit weird but it's an edge
-                // case and we're about to synchronously delete this
-                // component, anyway.
-                sourceFiber.tag = FunctionComponent;
-                sourceFiber.type = NoopComponent;
-              }
-            }
+          // The source fiber did not complete. Mark it with the current
+          // render priority to indicate that it still has pending work.
+          sourceFiber.expirationTime = renderExpirationTime;
 
-            // Exit without suspending.
-            return;
-          }
+          // Exit without suspending.
+          return;
+        }
 
-          // Confirmed that the boundary is in a strict mode tree. Continue with
-          // the normal suspend path.
+        // Confirmed that the boundary is in a concurrent mode tree. Continue
+        // with the normal suspend path.
 
-          var absoluteTimeoutMs = void 0;
-          if (earliestTimeoutMs === -1) {
-            // If no explicit threshold is given, default to an abitrarily large
-            // value. The actual size doesn't matter because the threshold for the
-            // whole tree will be clamped to the expiration time.
-            absoluteTimeoutMs = maxSigned31BitInt;
-          } else {
-            if (startTimeMs === -1) {
-              // This suspend happened outside of any already timed-out
-              // placeholders. We don't know exactly when the update was scheduled,
-              // but we can infer an approximate start time from the expiration
-              // time. First, find the earliest uncommitted expiration time in the
-              // tree, including work that is suspended. Then subtract the offset
-              // used to compute an async update's expiration time. This will cause
-              // high priority (interactive) work to expire earlier than necessary,
-              // but we can account for this by adjusting for the Just Noticeable
-              // Difference.
-              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(
-                root,
-                renderExpirationTime
-              );
-              var earliestExpirationTimeMs = expirationTimeToMs(
-                earliestExpirationTime
-              );
-              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
-            }
-            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+        var absoluteTimeoutMs = void 0;
+        if (earliestTimeoutMs === -1) {
+          // If no explicit threshold is given, default to an abitrarily large
+          // value. The actual size doesn't matter because the threshold for the
+          // whole tree will be clamped to the expiration time.
+          absoluteTimeoutMs = maxSigned31BitInt;
+        } else {
+          if (startTimeMs === -1) {
+            // This suspend happened outside of any already timed-out
+            // placeholders. We don't know exactly when the update was
+            // scheduled, but we can infer an approximate start time from the
+            // expiration time. First, find the earliest uncommitted expiration
+            // time in the tree, including work that is suspended. Then subtract
+            // the offset used to compute an async update's expiration time.
+            // This will cause high priority (interactive) work to expire
+            // earlier than necessary, but we can account for this by adjusting
+            // for the Just Noticeable Difference.
+            var earliestExpirationTime = findEarliestOutstandingPriorityLevel(
+              root,
+              renderExpirationTime
+            );
+            var earliestExpirationTimeMs = expirationTimeToMs(
+              earliestExpirationTime
+            );
+            startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
           }
+          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+        }
 
-          // Mark the earliest timeout in the suspended fiber's ancestor path.
-          // After completing the root, we'll take the largest of all the
-          // suspended fiber's timeouts and use it to compute a timeout for the
-          // whole tree.
-          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
+        // Mark the earliest timeout in the suspended fiber's ancestor path.
+        // After completing the root, we'll take the largest of all the
+        // suspended fiber's timeouts and use it to compute a timeout for the
+        // whole tree.
+        renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
 
-          _workInProgress.effectTag |= ShouldCapture;
-          _workInProgress.expirationTime = renderExpirationTime;
-          return;
-        }
-        // This boundary already captured during this render. Continue to the
-        // next boundary.
+        _workInProgress.effectTag |= ShouldCapture;
+        _workInProgress.expirationTime = renderExpirationTime;
+        return;
       }
+      // This boundary already captured during this render. Continue to the next
+      // boundary.
       _workInProgress = _workInProgress.return;
     } while (_workInProgress !== null);
     // No boundary was found. Fallthrough to error mode.
+    // TODO: Use invariant so the message is stripped in prod?
     value = new Error(
-      "An update was suspended, but no placeholder UI was provided."
+      (getComponentName(sourceFiber.type) || "A React component") +
+        " suspended while rendering, but no fallback UI was specified.\n" +
+        "\n" +
+        "Add a <Suspense fallback=...> component higher in the tree to " +
+        "provide a loading indicator or placeholder to display." +
+        getStackByFiberInDevAndProd(sourceFiber)
     );
   }
 
@@ -13329,7 +14796,6 @@ function throwException(
         return;
       }
       case ClassComponent:
-      case ClassComponentLazy:
         // Capture and retry
         var errorInfo = value;
         var ctor = workInProgress.type;
@@ -13374,38 +14840,27 @@ function unwindWork(workInProgress, renderExpirationTime) {
       }
       return null;
     }
-    case ClassComponentLazy: {
-      var _Component = workInProgress.type._reactResult;
-      if (isContextProvider(_Component)) {
-        popContext(workInProgress);
-      }
-      var _effectTag = workInProgress.effectTag;
-      if (_effectTag & ShouldCapture) {
-        workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;
-        return workInProgress;
-      }
-      return null;
-    }
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelContextObject(workInProgress);
-      var _effectTag2 = workInProgress.effectTag;
+      var _effectTag = workInProgress.effectTag;
       invariant(
-        (_effectTag2 & DidCapture) === NoEffect,
+        (_effectTag & DidCapture) === NoEffect,
         "The root failed to unmount after an error. This is likely a bug in " +
           "React. Please file an issue."
       );
-      workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;
+      workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;
       return workInProgress;
     }
     case HostComponent: {
       popHostContext(workInProgress);
       return null;
     }
-    case PlaceholderComponent: {
-      var _effectTag3 = workInProgress.effectTag;
-      if (_effectTag3 & ShouldCapture) {
-        workInProgress.effectTag = (_effectTag3 & ~ShouldCapture) | DidCapture;
+    case SuspenseComponent: {
+      var _effectTag2 = workInProgress.effectTag;
+      if (_effectTag2 & ShouldCapture) {
+        workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;
+        // Captured a suspense effect. Re-render the boundary.
         return workInProgress;
       }
       return null;
@@ -13430,14 +14885,6 @@ function unwindInterruptedWork(interruptedWork) {
       }
       break;
     }
-    case ClassComponentLazy: {
-      var _childContextTypes =
-        interruptedWork.type._reactResult.childContextTypes;
-      if (_childContextTypes !== null && _childContextTypes !== undefined) {
-        popContext(interruptedWork);
-      }
-      break;
-    }
     case HostRoot: {
       popHostContainer(interruptedWork);
       popTopLevelContextObject(interruptedWork);
@@ -13459,6 +14906,19 @@ function unwindInterruptedWork(interruptedWork) {
 }
 
 var Dispatcher = {
+  readContext: readContext,
+  useCallback: useCallback,
+  useContext: useContext,
+  useEffect: useEffect,
+  useImperativeMethods: useImperativeMethods,
+  useLayoutEffect: useLayoutEffect,
+  useMemo: useMemo,
+  useMutationEffect: useMutationEffect,
+  useReducer: useReducer,
+  useRef: useRef,
+  useState: useState
+};
+var DispatcherWithoutHooks = {
   readContext: readContext
 };
 
@@ -13471,12 +14931,12 @@ var warnAboutInvalidUpdates = void 0;
 
 if (enableSchedulerTracing) {
   // Provide explicit error message when production+profiling bundle of e.g. react-dom
-  // is used with production (non-profiling) bundle of schedule/tracing
+  // is used with production (non-profiling) bundle of scheduler/tracing
   invariant(
     tracing.__interactionsRef != null &&
       tracing.__interactionsRef.current != null,
     "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " +
-      "without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. " +
+      "without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. " +
       "Your bundler might have a setting for aliasing both modules. " +
       "Learn more at http://fb.me/react-profiling"
   );
@@ -13487,19 +14947,21 @@ if (enableSchedulerTracing) {
   didWarnSetStateChildContext = false;
   var didWarnStateUpdateForUnmountedComponent = {};
 
-  warnAboutUpdateOnUnmounted = function(fiber) {
+  warnAboutUpdateOnUnmounted = function(fiber, isClass) {
     // We show the whole stack but dedupe on the top component's name because
     // the problematic code almost always lies inside that component.
-    var componentName = getComponentName(fiber.type) || "ReactClass";
+    var componentName = getComponentName(fiber.type) || "ReactComponent";
     if (didWarnStateUpdateForUnmountedComponent[componentName]) {
       return;
     }
     warningWithoutStack$1(
       false,
-      "Can't call setState (or forceUpdate) on an unmounted component. This " +
+      "Can't perform a React state update on an unmounted component. This " +
         "is a no-op, but it indicates a memory leak in your application. To " +
-        "fix, cancel all subscriptions and asynchronous tasks in the " +
-        "componentWillUnmount method.%s",
+        "fix, cancel all subscriptions and asynchronous tasks in %s.%s",
+      isClass
+        ? "the componentWillUnmount method"
+        : "a useEffect cleanup function",
       getStackByFiberInDevAndProd(fiber)
     );
     didWarnStateUpdateForUnmountedComponent[componentName] = true;
@@ -13551,6 +15013,9 @@ var nextRenderDidError = false;
 var nextEffect = null;
 
 var isCommitting$1 = false;
+var rootWithPendingPassiveEffects = null;
+var passiveEffectCallbackHandle = null;
+var passiveEffectCallback = null;
 
 var legacyErrorBoundariesThatAlreadyFailed = null;
 
@@ -13559,11 +15024,13 @@ var interruptedBy = null;
 
 var stashedWorkInProgressProperties = void 0;
 var replayUnitOfWork = void 0;
+var mayReplayFailedUnitOfWork = void 0;
 var isReplayingFailedUnitOfWork = void 0;
 var originalReplayError = void 0;
 var rethrowOriginalError = void 0;
 if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
   stashedWorkInProgressProperties = null;
+  mayReplayFailedUnitOfWork = true;
   isReplayingFailedUnitOfWork = false;
   originalReplayError = null;
   replayUnitOfWork = function(failedUnitOfWork, thrownValue, isYieldy) {
@@ -13608,13 +15075,6 @@ if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
         }
         break;
       }
-      case ClassComponentLazy: {
-        var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);
-        if (isContextProvider(_Component)) {
-          popContext(failedUnitOfWork);
-        }
-        break;
-      }
       case HostPortal:
         popHostContainer(failedUnitOfWork);
         break;
@@ -13753,8 +15213,6 @@ function commitBeforeMutationLifecycles() {
       commitBeforeMutationLifeCycles(current$$1, nextEffect);
     }
 
-    // Don't cleanup effects yet;
-    // This will be done by commitAllLifeCycles()
     nextEffect = nextEffect.nextEffect;
   }
 
@@ -13791,15 +15249,48 @@ function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
       commitAttachRef(nextEffect);
     }
 
-    var next = nextEffect.nextEffect;
-    // Ensure that we clean these up so that we don't accidentally keep them.
-    // I'm not actually sure this matters because we can't reset firstEffect
-    // and lastEffect since they're on every node, not just the effectful
-    // ones. So we have to clean everything as we reuse nodes anyway.
-    nextEffect.nextEffect = null;
-    // Ensure that we reset the effectTag here so that we can rely on effect
-    // tags to reason about the current life-cycle.
-    nextEffect = next;
+    if (enableHooks && effectTag & Passive) {
+      rootWithPendingPassiveEffects = finishedRoot;
+    }
+
+    nextEffect = nextEffect.nextEffect;
+  }
+}
+
+function commitPassiveEffects(root, firstEffect) {
+  rootWithPendingPassiveEffects = null;
+  passiveEffectCallbackHandle = null;
+  passiveEffectCallback = null;
+
+  // Set this to true to prevent re-entrancy
+  var previousIsRendering = isRendering;
+  isRendering = true;
+
+  var effect = firstEffect;
+  do {
+    if (effect.effectTag & Passive) {
+      var didError = false;
+      var error = void 0;
+      {
+        invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);
+        if (hasCaughtError()) {
+          didError = true;
+          error = clearCaughtError();
+        }
+      }
+      if (didError) {
+        captureCommitPhaseError(effect, error);
+      }
+    }
+    effect = effect.nextEffect;
+  } while (effect !== null);
+
+  isRendering = previousIsRendering;
+
+  // Check if work was scheduled by one of the effects
+  var rootExpirationTime = root.expirationTime;
+  if (rootExpirationTime !== NoWork) {
+    requestWork(root, rootExpirationTime);
   }
 }
 
@@ -13818,6 +15309,15 @@ function markLegacyErrorBoundaryAsFailed(instance) {
   }
 }
 
+function flushPassiveEffects() {
+  if (passiveEffectCallback !== null) {
+    scheduler.unstable_cancelCallback(passiveEffectCallbackHandle);
+    // We call the scheduled callback instead of commitPassiveEffects directly
+    // to ensure tracing works correctly.
+    passiveEffectCallback();
+  }
+}
+
 function commitRoot(root, finishedWork) {
   isWorking = true;
   isCommitting$1 = true;
@@ -13843,9 +15343,7 @@ function commitRoot(root, finishedWork) {
   var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
   var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
   var earliestRemainingTimeBeforeCommit =
-    updateExpirationTimeBeforeCommit === NoWork ||
-    (childExpirationTimeBeforeCommit !== NoWork &&
-      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit)
+    childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit
       ? childExpirationTimeBeforeCommit
       : updateExpirationTimeBeforeCommit;
   markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);
@@ -13987,6 +15485,26 @@ function commitRoot(root, finishedWork) {
     }
   }
 
+  if (
+    enableHooks &&
+    firstEffect !== null &&
+    rootWithPendingPassiveEffects !== null
+  ) {
+    // This commit included a passive effect. These do not need to fire until
+    // after the next paint. Schedule an callback to fire them in an async
+    // event. To ensure serial execution, the callback will be flushed early if
+    // we enter rootWithPendingPassiveEffects commit phase before then.
+    var callback = commitPassiveEffects.bind(null, root, firstEffect);
+    if (enableSchedulerTracing) {
+      // TODO: Avoid this extra callback by mutating the tracing ref directly,
+      // like we do at the beginning of commitRoot. I've opted not to do that
+      // here because that code is still in flux.
+      callback = tracing.unstable_wrap(callback);
+    }
+    passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(callback);
+    passiveEffectCallback = callback;
+  }
+
   isCommitting$1 = false;
   isWorking = false;
   stopCommitLifeCyclesTimer();
@@ -13999,9 +15517,7 @@ function commitRoot(root, finishedWork) {
   var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
   var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
   var earliestRemainingTimeAfterCommit =
-    updateExpirationTimeAfterCommit === NoWork ||
-    (childExpirationTimeAfterCommit !== NoWork &&
-      childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit)
+    childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit
       ? childExpirationTimeAfterCommit
       : updateExpirationTimeAfterCommit;
   if (earliestRemainingTimeAfterCommit === NoWork) {
@@ -14044,10 +15560,7 @@ function commitRoot(root, finishedWork) {
         // Only decrement the pending interaction count if we're done.
         // If there's still work at the current priority,
         // That indicates that we are waiting for suspense data.
-        if (
-          earliestRemainingTimeAfterCommit === NoWork ||
-          scheduledExpirationTime < earliestRemainingTimeAfterCommit
-        ) {
+        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
           pendingInteractionMap.delete(scheduledExpirationTime);
 
           scheduledInteractions.forEach(function(interaction) {
@@ -14103,18 +15616,10 @@ function resetChildExpirationTime(workInProgress, renderTime) {
     while (child !== null) {
       var childUpdateExpirationTime = child.expirationTime;
       var childChildExpirationTime = child.childExpirationTime;
-      if (
-        newChildExpirationTime === NoWork ||
-        (childUpdateExpirationTime !== NoWork &&
-          childUpdateExpirationTime < newChildExpirationTime)
-      ) {
+      if (childUpdateExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = childUpdateExpirationTime;
       }
-      if (
-        newChildExpirationTime === NoWork ||
-        (childChildExpirationTime !== NoWork &&
-          childChildExpirationTime < newChildExpirationTime)
-      ) {
+      if (childChildExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = childChildExpirationTime;
       }
       if (shouldBubbleActualDurations) {
@@ -14130,18 +15635,10 @@ function resetChildExpirationTime(workInProgress, renderTime) {
     while (_child !== null) {
       var _childUpdateExpirationTime = _child.expirationTime;
       var _childChildExpirationTime = _child.childExpirationTime;
-      if (
-        newChildExpirationTime === NoWork ||
-        (_childUpdateExpirationTime !== NoWork &&
-          _childUpdateExpirationTime < newChildExpirationTime)
-      ) {
+      if (_childUpdateExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = _childUpdateExpirationTime;
       }
-      if (
-        newChildExpirationTime === NoWork ||
-        (_childChildExpirationTime !== NoWork &&
-          _childChildExpirationTime < newChildExpirationTime)
-      ) {
+      if (_childChildExpirationTime > newChildExpirationTime) {
         newChildExpirationTime = _childChildExpirationTime;
       }
       _child = _child.sibling;
@@ -14169,18 +15666,22 @@ function completeUnitOfWork(workInProgress) {
     var siblingFiber = workInProgress.sibling;
 
     if ((workInProgress.effectTag & Incomplete) === NoEffect) {
+      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
+        // Don't replay if it fails during completion phase.
+        mayReplayFailedUnitOfWork = false;
+      }
       // This fiber completed.
+      // Remember we're completing this unit so we can find a boundary if it fails.
+      nextUnitOfWork = workInProgress;
       if (enableProfilerTimer) {
         if (workInProgress.mode & ProfileMode) {
           startProfilerTimer(workInProgress);
         }
-
         nextUnitOfWork = completeWork(
           current$$1,
           workInProgress,
           nextRenderExpirationTime
         );
-
         if (workInProgress.mode & ProfileMode) {
           // Update render duration assuming we didn't error.
           stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
@@ -14192,12 +15693,21 @@ function completeUnitOfWork(workInProgress) {
           nextRenderExpirationTime
         );
       }
+      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
+        // We're out of completion phase so replaying is fine now.
+        mayReplayFailedUnitOfWork = true;
+      }
       stopWorkTimer(workInProgress);
       resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
       {
         resetCurrentFiber();
       }
 
+      if (nextUnitOfWork !== null) {
+        // Completing this fiber spawned new work. Work on that next.
+        return nextUnitOfWork;
+      }
+
       if (
         returnFiber !== null &&
         // Do not append effects to parents if a sibling failed to complete
@@ -14251,9 +15761,18 @@ function completeUnitOfWork(workInProgress) {
         return null;
       }
     } else {
-      if (workInProgress.mode & ProfileMode) {
+      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
         // Record the render duration for the fiber that errored.
         stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
+
+        // Include the time spent working on failed children before continuing.
+        var actualDuration = workInProgress.actualDuration;
+        var child = workInProgress.child;
+        while (child !== null) {
+          actualDuration += child.actualDuration;
+          child = child.sibling;
+        }
+        workInProgress.actualDuration = actualDuration;
       }
 
       // This fiber did not complete because something threw. Pop values off
@@ -14278,19 +15797,6 @@ function completeUnitOfWork(workInProgress) {
           ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
         }
 
-        if (enableProfilerTimer) {
-          // Include the time spent working on failed children before continuing.
-          if (next.mode & ProfileMode) {
-            var actualDuration = next.actualDuration;
-            var child = next.child;
-            while (child !== null) {
-              actualDuration += child.actualDuration;
-              child = child.sibling;
-            }
-            next.actualDuration = actualDuration;
-          }
-        }
-
         // If completing this work spawned new work, do that next. We'll come
         // back here again.
         // Since we're restarting, remove anything that is not a host effect
@@ -14355,6 +15861,7 @@ function performUnitOfWork(workInProgress) {
     }
 
     next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
+    workInProgress.memoizedProps = workInProgress.pendingProps;
 
     if (workInProgress.mode & ProfileMode) {
       // Record the render duration assuming we didn't bailout (or error).
@@ -14362,6 +15869,7 @@ function performUnitOfWork(workInProgress) {
     }
   } else {
     next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
+    workInProgress.memoizedProps = workInProgress.pendingProps;
   }
 
   {
@@ -14395,21 +15903,28 @@ function workLoop(isYieldy) {
       nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     }
   } else {
-    // Flush asynchronous work until the deadline runs out of time.
-    while (nextUnitOfWork !== null && !shouldYield()) {
+    // Flush asynchronous work until there's a higher priority event
+    while (nextUnitOfWork !== null && !shouldYieldToRenderer()) {
       nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     }
   }
 }
 
-function renderRoot(root, isYieldy, isExpired) {
+function renderRoot(root, isYieldy) {
   invariant(
     !isWorking,
     "renderRoot was called recursively. This error is likely caused " +
       "by a bug in React. Please file an issue."
   );
+
+  flushPassiveEffects();
+
   isWorking = true;
-  ReactCurrentOwner$2.currentDispatcher = Dispatcher;
+  if (enableHooks) {
+    ReactCurrentOwner$2.currentDispatcher = Dispatcher;
+  } else {
+    ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
+  }
 
   var expirationTime = root.nextExpirationTimeToWorkOn;
 
@@ -14439,7 +15954,7 @@ function renderRoot(root, isYieldy, isExpired) {
         scheduledInteractions,
         scheduledExpirationTime
       ) {
-        if (scheduledExpirationTime <= expirationTime) {
+        if (scheduledExpirationTime >= expirationTime) {
           scheduledInteractions.forEach(function(interaction) {
             return interactions.add(interaction);
           });
@@ -14491,20 +16006,39 @@ function renderRoot(root, isYieldy, isExpired) {
     try {
       workLoop(isYieldy);
     } catch (thrownValue) {
+      resetContextDependences();
+      resetHooks();
+
+      // Reset in case completion throws.
+      // This is only used in DEV and when replaying is on.
+      var mayReplay = void 0;
+      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
+        mayReplay = mayReplayFailedUnitOfWork;
+        mayReplayFailedUnitOfWork = true;
+      }
+
       if (nextUnitOfWork === null) {
         // This is a fatal error.
         didFatal = true;
         onUncaughtError(thrownValue);
       } else {
+        if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {
+          // Record the time spent rendering before an error was thrown.
+          // This avoids inaccurate Profiler durations in the case of a suspended render.
+          stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
+        }
+
         {
           // Reset global debug state
           // We assume this is defined in DEV
           resetCurrentlyProcessingQueue();
         }
 
-        var failedUnitOfWork = nextUnitOfWork;
         if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
-          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
+          if (mayReplay) {
+            var failedUnitOfWork = nextUnitOfWork;
+            replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
+          }
         }
 
         // TODO: we already know this isn't true in some cases.
@@ -14553,6 +16087,7 @@ function renderRoot(root, isYieldy, isExpired) {
   isWorking = false;
   ReactCurrentOwner$2.currentDispatcher = null;
   resetContextDependences();
+  resetHooks();
 
   // Yield back to main thread.
   if (didFatal) {
@@ -14624,7 +16159,7 @@ function renderRoot(root, isYieldy, isExpired) {
       // similar to a suspend, but without a timeout because we're not waiting
       // for a promise to resolve.
       !root.didError &&
-      !isExpired
+      isYieldy
     ) {
       root.didError = true;
       var _suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime);
@@ -14640,7 +16175,7 @@ function renderRoot(root, isYieldy, isExpired) {
     }
   }
 
-  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {
+  if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
     // The tree was suspended.
     var _suspendedExpirationTime2 = expirationTime;
     markSuspendedPriorityLevel(root, _suspendedExpirationTime2);
@@ -14682,17 +16217,12 @@ function renderRoot(root, isYieldy, isExpired) {
   onComplete(root, rootWorkInProgress, expirationTime);
 }
 
-function dispatch(sourceFiber, value, expirationTime) {
-  invariant(
-    !isWorking || isCommitting$1,
-    "dispatch: Cannot dispatch during the render phase."
-  );
-
+function captureCommitPhaseError(sourceFiber, value) {
+  var expirationTime = Sync;
   var fiber = sourceFiber.return;
   while (fiber !== null) {
     switch (fiber.tag) {
       case ClassComponent:
-      case ClassComponentLazy:
         var ctor = fiber.type;
         var instance = fiber.stateNode;
         if (
@@ -14733,10 +16263,6 @@ function dispatch(sourceFiber, value, expirationTime) {
   }
 }
 
-function captureCommitPhaseError(fiber, error) {
-  return dispatch(fiber, error, Sync);
-}
-
 function computeThreadID(expirationTime, interactionThreadID) {
   // Interaction threads are unique per root and expiration time.
   return expirationTime * 1000 + interactionThreadID;
@@ -14771,7 +16297,7 @@ function computeExpirationForFiber(currentTime, fiber) {
       // If we're in the middle of rendering a tree, do not update at the same
       // expiration time that is already rendering.
       if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
-        expirationTime += 1;
+        expirationTime -= 1;
       }
     } else {
       // This is a sync update
@@ -14782,7 +16308,10 @@ function computeExpirationForFiber(currentTime, fiber) {
     // This is an interactive update. Keep track of the lowest pending
     // interactive expiration time. This allows us to synchronously flush
     // all interactive updates when needed.
-    if (expirationTime > lowestPriorityPendingInteractiveExpirationTime) {
+    if (
+      lowestPriorityPendingInteractiveExpirationTime === NoWork ||
+      expirationTime < lowestPriorityPendingInteractiveExpirationTime
+    ) {
       lowestPriorityPendingInteractiveExpirationTime = expirationTime;
     }
   }
@@ -14803,68 +16332,75 @@ function renderDidError() {
   nextRenderDidError = true;
 }
 
-function retrySuspendedRoot(root, fiber, suspendedTime) {
-  if (enableSuspense) {
-    var retryTime = void 0;
+function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
+  var retryTime = void 0;
 
-    if (isPriorityLevelSuspended(root, suspendedTime)) {
-      // Ping at the original level
-      retryTime = suspendedTime;
+  if (isPriorityLevelSuspended(root, suspendedTime)) {
+    // Ping at the original level
+    retryTime = suspendedTime;
 
-      markPingedPriorityLevel(root, retryTime);
-    } else {
-      // Placeholder already timed out. Compute a new expiration time
-      var currentTime = requestCurrentTime();
-      retryTime = computeExpirationForFiber(currentTime, fiber);
-      markPendingPriorityLevel(root, retryTime);
-    }
+    markPingedPriorityLevel(root, retryTime);
+  } else {
+    // Suspense already timed out. Compute a new expiration time
+    var currentTime = requestCurrentTime();
+    retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
+    markPendingPriorityLevel(root, retryTime);
+  }
 
-    // TODO: If the placeholder fiber has already rendered the primary children
-    // without suspending (that is, all of the promises have already resolved),
-    // we should not trigger another update here. One case this happens is when
-    // we are in sync mode and a single promise is thrown both on initial render
-    // and on update; we attach two .then(retrySuspendedRoot) callbacks and each
-    // one performs Sync work, rerendering the Placeholder.
+  // TODO: If the suspense fiber has already rendered the primary children
+  // without suspending (that is, all of the promises have already resolved),
+  // we should not trigger another update here. One case this happens is when
+  // we are in sync mode and a single promise is thrown both on initial render
+  // and on update; we attach two .then(retrySuspendedRoot) callbacks and each
+  // one performs Sync work, rerendering the Suspense.
 
-    if ((fiber.mode & ConcurrentMode) !== NoContext) {
-      if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
-        // Received a ping at the same priority level at which we're currently
-        // rendering. Restart from the root.
-        nextRoot = null;
-      }
+  if ((boundaryFiber.mode & ConcurrentMode) !== NoContext) {
+    if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
+      // Received a ping at the same priority level at which we're currently
+      // rendering. Restart from the root.
+      nextRoot = null;
     }
+  }
 
-    scheduleWorkToRoot(fiber, retryTime);
-    var rootExpirationTime = root.expirationTime;
-    if (rootExpirationTime !== NoWork) {
-      requestWork(root, rootExpirationTime);
+  scheduleWorkToRoot(boundaryFiber, retryTime);
+  if ((boundaryFiber.mode & ConcurrentMode) === NoContext) {
+    // Outside of concurrent mode, we must schedule an update on the source
+    // fiber, too, since it already committed in an inconsistent state and
+    // therefore does not have any pending work.
+    scheduleWorkToRoot(sourceFiber, retryTime);
+    var sourceTag = sourceFiber.tag;
+    if (sourceTag === ClassComponent && sourceFiber.stateNode !== null) {
+      // When we try rendering again, we should not reuse the current fiber,
+      // since it's known to be in an inconsistent state. Use a force updte to
+      // prevent a bail out.
+      var update = createUpdate(retryTime);
+      update.tag = ForceUpdate;
+      enqueueUpdate(sourceFiber, update);
     }
   }
+
+  var rootExpirationTime = root.expirationTime;
+  if (rootExpirationTime !== NoWork) {
+    requestWork(root, rootExpirationTime);
+  }
 }
 
 function scheduleWorkToRoot(fiber, expirationTime) {
   recordScheduleUpdate();
 
   {
-    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
+    if (fiber.tag === ClassComponent) {
       var instance = fiber.stateNode;
       warnAboutInvalidUpdates(instance);
     }
   }
 
   // Update the source fiber's expiration time
-  if (
-    fiber.expirationTime === NoWork ||
-    fiber.expirationTime > expirationTime
-  ) {
+  if (fiber.expirationTime < expirationTime) {
     fiber.expirationTime = expirationTime;
   }
   var alternate = fiber.alternate;
-  if (
-    alternate !== null &&
-    (alternate.expirationTime === NoWork ||
-      alternate.expirationTime > expirationTime)
-  ) {
+  if (alternate !== null && alternate.expirationTime < expirationTime) {
     alternate.expirationTime = expirationTime;
   }
   // Walk the parent path to the root and update the child expiration time.
@@ -14875,22 +16411,17 @@ function scheduleWorkToRoot(fiber, expirationTime) {
   } else {
     while (node !== null) {
       alternate = node.alternate;
-      if (
-        node.childExpirationTime === NoWork ||
-        node.childExpirationTime > expirationTime
-      ) {
+      if (node.childExpirationTime < expirationTime) {
         node.childExpirationTime = expirationTime;
         if (
           alternate !== null &&
-          (alternate.childExpirationTime === NoWork ||
-            alternate.childExpirationTime > expirationTime)
+          alternate.childExpirationTime < expirationTime
         ) {
           alternate.childExpirationTime = expirationTime;
         }
       } else if (
         alternate !== null &&
-        (alternate.childExpirationTime === NoWork ||
-          alternate.childExpirationTime > expirationTime)
+        alternate.childExpirationTime < expirationTime
       ) {
         alternate.childExpirationTime = expirationTime;
       }
@@ -14902,63 +16433,67 @@ function scheduleWorkToRoot(fiber, expirationTime) {
     }
   }
 
-  if (root === null) {
-    if (
-      true &&
-      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)
-    ) {
-      warnAboutUpdateOnUnmounted(fiber);
-    }
-    return null;
-  }
-
   if (enableSchedulerTracing) {
-    var interactions = tracing.__interactionsRef.current;
-    if (interactions.size > 0) {
-      var pendingInteractionMap = root.pendingInteractionMap;
-      var pendingInteractions = pendingInteractionMap.get(expirationTime);
-      if (pendingInteractions != null) {
-        interactions.forEach(function(interaction) {
-          if (!pendingInteractions.has(interaction)) {
-            // Update the pending async work count for previously unscheduled interaction.
-            interaction.__count++;
-          }
+    if (root !== null) {
+      var interactions = tracing.__interactionsRef.current;
+      if (interactions.size > 0) {
+        var pendingInteractionMap = root.pendingInteractionMap;
+        var pendingInteractions = pendingInteractionMap.get(expirationTime);
+        if (pendingInteractions != null) {
+          interactions.forEach(function(interaction) {
+            if (!pendingInteractions.has(interaction)) {
+              // Update the pending async work count for previously unscheduled interaction.
+              interaction.__count++;
+            }
 
-          pendingInteractions.add(interaction);
-        });
-      } else {
-        pendingInteractionMap.set(expirationTime, new Set(interactions));
+            pendingInteractions.add(interaction);
+          });
+        } else {
+          pendingInteractionMap.set(expirationTime, new Set(interactions));
 
-        // Update the pending async work count for the current interactions.
-        interactions.forEach(function(interaction) {
-          interaction.__count++;
-        });
-      }
+          // Update the pending async work count for the current interactions.
+          interactions.forEach(function(interaction) {
+            interaction.__count++;
+          });
+        }
 
-      var subscriber = tracing.__subscriberRef.current;
-      if (subscriber !== null) {
-        var threadID = computeThreadID(
-          expirationTime,
-          root.interactionThreadID
-        );
-        subscriber.onWorkScheduled(interactions, threadID);
+        var subscriber = tracing.__subscriberRef.current;
+        if (subscriber !== null) {
+          var threadID = computeThreadID(
+            expirationTime,
+            root.interactionThreadID
+          );
+          subscriber.onWorkScheduled(interactions, threadID);
+        }
       }
     }
   }
-
   return root;
 }
 
 function scheduleWork(fiber, expirationTime) {
   var root = scheduleWorkToRoot(fiber, expirationTime);
   if (root === null) {
+    {
+      switch (fiber.tag) {
+        case ClassComponent:
+          warnAboutUpdateOnUnmounted(fiber, true);
+          break;
+        case FunctionComponent:
+        case ForwardRef:
+        case MemoComponent:
+        case SimpleMemoComponent:
+          warnAboutUpdateOnUnmounted(fiber, false);
+          break;
+      }
+    }
     return;
   }
 
   if (
     !isWorking &&
     nextRenderExpirationTime !== NoWork &&
-    expirationTime < nextRenderExpirationTime
+    expirationTime > nextRenderExpirationTime
   ) {
     // This is an interruption. (Used for performance tracking.)
     interruptedBy = fiber;
@@ -15002,10 +16537,8 @@ var isRendering = false;
 var nextFlushedRoot = null;
 var nextFlushedExpirationTime = NoWork;
 var lowestPriorityPendingInteractiveExpirationTime = NoWork;
-var deadlineDidExpire = false;
 var hasUnhandledError = false;
 var unhandledError = null;
-var deadline = null;
 
 var isBatchingUpdates = false;
 var isUnbatchingUpdates = false;
@@ -15022,8 +16555,6 @@ var NESTED_UPDATE_LIMIT = 50;
 var nestedUpdateCount = 0;
 var lastCommittedRootDuringThisBatch = null;
 
-var timeHeuristicForUnitOfWork = 1;
-
 function recomputeCurrentRendererTime() {
   var currentTimeMs = now() - originalStartTimeMs;
   currentRendererTime = msToExpirationTime(currentTimeMs);
@@ -15032,7 +16563,7 @@ function recomputeCurrentRendererTime() {
 function scheduleCallbackWithExpirationTime(root, expirationTime) {
   if (callbackExpirationTime !== NoWork) {
     // A callback is already scheduled. Check its expiration time (timeout).
-    if (expirationTime > callbackExpirationTime) {
+    if (expirationTime < callbackExpirationTime) {
       // Existing callback has sufficient timeout. Exit.
       return;
     } else {
@@ -15075,7 +16606,7 @@ function onSuspend(
   msUntilTimeout
 ) {
   root.expirationTime = rootExpirationTime;
-  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {
+  if (msUntilTimeout === 0 && !shouldYieldToRenderer()) {
     // Don't wait an additional tick. Commit the tree immediately.
     root.pendingCommitExpirationTime = suspendedExpirationTime;
     root.finishedWork = finishedWork;
@@ -15093,17 +16624,15 @@ function onYield(root) {
 }
 
 function onTimeout(root, finishedWork, suspendedExpirationTime) {
-  if (enableSuspense) {
-    // The root timed out. Commit it.
-    root.pendingCommitExpirationTime = suspendedExpirationTime;
-    root.finishedWork = finishedWork;
-    // Read the current time before entering the commit phase. We can be
-    // certain this won't cause tearing related to batching of event updates
-    // because we're at the top of a timer event.
-    recomputeCurrentRendererTime();
-    currentSchedulerTime = currentRendererTime;
-    flushRoot(root, suspendedExpirationTime);
-  }
+  // The root timed out. Commit it.
+  root.pendingCommitExpirationTime = suspendedExpirationTime;
+  root.finishedWork = finishedWork;
+  // Read the current time before entering the commit phase. We can be
+  // certain this won't cause tearing related to batching of event updates
+  // because we're at the top of a timer event.
+  recomputeCurrentRendererTime();
+  currentSchedulerTime = currentRendererTime;
+  flushRoot(root, suspendedExpirationTime);
 }
 
 function onCommit(root, expirationTime) {
@@ -15172,7 +16701,7 @@ function requestWork(root, expirationTime) {
       // flush it now.
       nextFlushedRoot = root;
       nextFlushedExpirationTime = Sync;
-      performWorkOnRoot(root, Sync, true);
+      performWorkOnRoot(root, Sync, false);
     }
     return;
   }
@@ -15202,10 +16731,7 @@ function addRootToSchedule(root, expirationTime) {
   } else {
     // This root is already scheduled, but its priority may have increased.
     var remainingExpirationTime = root.expirationTime;
-    if (
-      remainingExpirationTime === NoWork ||
-      expirationTime < remainingExpirationTime
-    ) {
+    if (expirationTime > remainingExpirationTime) {
       // Update the priority.
       root.expirationTime = expirationTime;
     }
@@ -15254,10 +16780,7 @@ function findHighestPriorityRoot() {
         }
         root = previousScheduledRoot.nextScheduledRoot;
       } else {
-        if (
-          highestPriorityWork === NoWork ||
-          remainingExpirationTime < highestPriorityWork
-        ) {
+        if (remainingExpirationTime > highestPriorityWork) {
           // Update the priority, if it's higher
           highestPriorityWork = remainingExpirationTime;
           highestPriorityRoot = root;
@@ -15280,43 +16803,60 @@ function findHighestPriorityRoot() {
   nextFlushedExpirationTime = highestPriorityWork;
 }
 
-function performAsyncWork(dl) {
-  if (dl.didTimeout) {
-    // The callback timed out. That means at least one update has expired.
-    // Iterate through the root schedule. If they contain expired work, set
-    // the next render expiration time to the current time. This has the effect
-    // of flushing all expired work in a single batch, instead of flushing each
-    // level one at a time.
-    if (firstScheduledRoot !== null) {
-      recomputeCurrentRendererTime();
-      var root = firstScheduledRoot;
-      do {
-        didExpireAtExpirationTime(root, currentRendererTime);
-        // The root schedule is circular, so this is never null.
-        root = root.nextScheduledRoot;
-      } while (root !== firstScheduledRoot);
+// TODO: This wrapper exists because many of the older tests (the ones that use
+// flushDeferredPri) rely on the number of times `shouldYield` is called. We
+// should get rid of it.
+var didYield = false;
+function shouldYieldToRenderer() {
+  if (didYield) {
+    return true;
+  }
+  if (shouldYield()) {
+    didYield = true;
+    return true;
+  }
+  return false;
+}
+
+function performAsyncWork() {
+  try {
+    if (!shouldYieldToRenderer()) {
+      // The callback timed out. That means at least one update has expired.
+      // Iterate through the root schedule. If they contain expired work, set
+      // the next render expiration time to the current time. This has the effect
+      // of flushing all expired work in a single batch, instead of flushing each
+      // level one at a time.
+      if (firstScheduledRoot !== null) {
+        recomputeCurrentRendererTime();
+        var root = firstScheduledRoot;
+        do {
+          didExpireAtExpirationTime(root, currentRendererTime);
+          // The root schedule is circular, so this is never null.
+          root = root.nextScheduledRoot;
+        } while (root !== firstScheduledRoot);
+      }
     }
+    performWork(NoWork, true);
+  } finally {
+    didYield = false;
   }
-  performWork(NoWork, dl);
 }
 
 function performSyncWork() {
-  performWork(Sync, null);
+  performWork(Sync, false);
 }
 
-function performWork(minExpirationTime, dl) {
-  deadline = dl;
-
-  // Keep working on roots until there's no more work, or until we reach
-  // the deadline.
+function performWork(minExpirationTime, isYieldy) {
+  // Keep working on roots until there's no more work, or until there's a higher
+  // priority event.
   findHighestPriorityRoot();
 
-  if (deadline !== null) {
+  if (isYieldy) {
     recomputeCurrentRendererTime();
     currentSchedulerTime = currentRendererTime;
 
     if (enableUserTimingAPI) {
-      var didExpire = nextFlushedExpirationTime < currentRendererTime;
+      var didExpire = nextFlushedExpirationTime > currentRendererTime;
       var timeout = expirationTimeToMs(nextFlushedExpirationTime);
       stopRequestCallbackTimer(didExpire, timeout);
     }
@@ -15324,14 +16864,13 @@ function performWork(minExpirationTime, dl) {
     while (
       nextFlushedRoot !== null &&
       nextFlushedExpirationTime !== NoWork &&
-      (minExpirationTime === NoWork ||
-        minExpirationTime >= nextFlushedExpirationTime) &&
-      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)
+      minExpirationTime <= nextFlushedExpirationTime &&
+      !(didYield && currentRendererTime > nextFlushedExpirationTime)
     ) {
       performWorkOnRoot(
         nextFlushedRoot,
         nextFlushedExpirationTime,
-        currentRendererTime >= nextFlushedExpirationTime
+        currentRendererTime > nextFlushedExpirationTime
       );
       findHighestPriorityRoot();
       recomputeCurrentRendererTime();
@@ -15341,10 +16880,9 @@ function performWork(minExpirationTime, dl) {
     while (
       nextFlushedRoot !== null &&
       nextFlushedExpirationTime !== NoWork &&
-      (minExpirationTime === NoWork ||
-        minExpirationTime >= nextFlushedExpirationTime)
+      minExpirationTime <= nextFlushedExpirationTime
     ) {
-      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);
+      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
       findHighestPriorityRoot();
     }
   }
@@ -15353,7 +16891,7 @@ function performWork(minExpirationTime, dl) {
   // or there's no more work left with sufficient priority.
 
   // If we're inside a callback, set this to false since we just completed it.
-  if (deadline !== null) {
+  if (isYieldy) {
     callbackExpirationTime = NoWork;
     callbackID = null;
   }
@@ -15366,9 +16904,6 @@ function performWork(minExpirationTime, dl) {
   }
 
   // Clean-up.
-  deadline = null;
-  deadlineDidExpire = false;
-
   finishRendering();
 }
 
@@ -15383,7 +16918,7 @@ function flushRoot(root, expirationTime) {
   // including the given time.
   nextFlushedRoot = root;
   nextFlushedExpirationTime = expirationTime;
-  performWorkOnRoot(root, expirationTime, true);
+  performWorkOnRoot(root, expirationTime, false);
   // Flush any sync work that was scheduled by lifecycles
   performSyncWork();
 }
@@ -15416,7 +16951,7 @@ function finishRendering() {
   }
 }
 
-function performWorkOnRoot(root, expirationTime, isExpired) {
+function performWorkOnRoot(root, expirationTime, isYieldy) {
   invariant(
     !isRendering,
     "performWorkOnRoot was called recursively. This error is likely caused " +
@@ -15426,7 +16961,7 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
   isRendering = true;
 
   // Check if this is async work or sync/expired work.
-  if (deadline === null || isExpired) {
+  if (!isYieldy) {
     // Flush work without yielding.
     // TODO: Non-yieldy work does not necessarily imply expired work. A renderer
     // may want to perform some work without yielding, but also without
@@ -15441,13 +16976,12 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
       // If this root previously suspended, clear its existing timeout, since
       // we're about to try rendering again.
       var timeoutHandle = root.timeoutHandle;
-      if (enableSuspense && timeoutHandle !== noTimeout) {
+      if (timeoutHandle !== noTimeout) {
         root.timeoutHandle = noTimeout;
         // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
         cancelTimeout(timeoutHandle);
       }
-      var isYieldy = false;
-      renderRoot(root, isYieldy, isExpired);
+      renderRoot(root, isYieldy);
       finishedWork = root.finishedWork;
       if (finishedWork !== null) {
         // We've completed the root. Commit it.
@@ -15465,18 +16999,17 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
       // If this root previously suspended, clear its existing timeout, since
       // we're about to try rendering again.
       var _timeoutHandle = root.timeoutHandle;
-      if (enableSuspense && _timeoutHandle !== noTimeout) {
+      if (_timeoutHandle !== noTimeout) {
         root.timeoutHandle = noTimeout;
         // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
         cancelTimeout(_timeoutHandle);
       }
-      var _isYieldy = true;
-      renderRoot(root, _isYieldy, isExpired);
+      renderRoot(root, isYieldy);
       _finishedWork = root.finishedWork;
       if (_finishedWork !== null) {
-        // We've completed the root. Check the deadline one more time
+        // We've completed the root. Check the if we should yield one more time
         // before committing.
-        if (!shouldYield()) {
+        if (!shouldYieldToRenderer()) {
           // Still time left. Commit the root.
           completeRoot(root, _finishedWork, expirationTime);
         } else {
@@ -15494,7 +17027,7 @@ function performWorkOnRoot(root, expirationTime, isExpired) {
 function completeRoot(root, finishedWork, expirationTime) {
   // Check if there's a batch that matches this expiration time.
   var firstBatch = root.firstBatch;
-  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {
+  if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
     if (completedBatches === null) {
       completedBatches = [firstBatch];
     } else {
@@ -15526,24 +17059,6 @@ function completeRoot(root, finishedWork, expirationTime) {
   commitRoot(root, finishedWork);
 }
 
-// When working on async work, the reconciler asks the renderer if it should
-// yield execution. For DOM, we implement this with requestIdleCallback.
-function shouldYield() {
-  if (deadlineDidExpire) {
-    return true;
-  }
-  if (
-    deadline === null ||
-    deadline.timeRemaining() > timeHeuristicForUnitOfWork
-  ) {
-    // Disregard deadline.didTimeout. Only expired work should be flushed
-    // during a timeout. This path is only hit for non-expired work.
-    return false;
-  }
-  deadlineDidExpire = true;
-  return true;
-}
-
 function onUncaughtError(error) {
   invariant(
     nextFlushedRoot !== null,
@@ -15588,7 +17103,7 @@ function interactiveUpdates$1(fn, a, b) {
     lowestPriorityPendingInteractiveExpirationTime !== NoWork
   ) {
     // Synchronously flush pending interactive updates.
-    performWork(lowestPriorityPendingInteractiveExpirationTime, null);
+    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
     lowestPriorityPendingInteractiveExpirationTime = NoWork;
   }
   var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
@@ -15612,7 +17127,7 @@ function flushInteractiveUpdates$1() {
     lowestPriorityPendingInteractiveExpirationTime !== NoWork
   ) {
     // Synchronously flush pending interactive updates.
-    performWork(lowestPriorityPendingInteractiveExpirationTime, null);
+    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
     lowestPriorityPendingInteractiveExpirationTime = NoWork;
   }
 }
@@ -15621,9 +17136,11 @@ function flushInteractiveUpdates$1() {
 // Might add PROFILE later.
 
 var didWarnAboutNestedUpdates = void 0;
+var didWarnAboutFindNodeInStrictMode = void 0;
 
 {
   didWarnAboutNestedUpdates = false;
+  didWarnAboutFindNodeInStrictMode = {};
 }
 
 function getContextForSubtree(parentComponent) {
@@ -15639,11 +17156,6 @@ function getContextForSubtree(parentComponent) {
     if (isContextProvider(Component)) {
       return processChildContext(fiber, Component, parentContext);
     }
-  } else if (fiber.tag === ClassComponentLazy) {
-    var _Component = getResultFromResolvedThenable(fiber.type);
-    if (isContextProvider(_Component)) {
-      return processChildContext(fiber, _Component, parentContext);
-    }
   }
 
   return parentContext;
@@ -15681,9 +17193,11 @@ function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
       : void 0;
     update.callback = callback;
   }
-  enqueueUpdate(current$$1, update);
 
+  flushPassiveEffects();
+  enqueueUpdate(current$$1, update);
   scheduleWork(current$$1, expirationTime);
+
   return expirationTime;
 }
 
@@ -15739,6 +17253,64 @@ function findHostInstance$1(component) {
   return hostFiber.stateNode;
 }
 
+function findHostInstanceWithWarning$1(component, methodName) {
+  {
+    var fiber = get$1(component);
+    if (fiber === undefined) {
+      if (typeof component.render === "function") {
+        invariant(false, "Unable to find node on an unmounted component.");
+      } else {
+        invariant(
+          false,
+          "Argument appears to not be a ReactComponent. Keys: %s",
+          Object.keys(component)
+        );
+      }
+    }
+    var hostFiber = findCurrentHostFiber(fiber);
+    if (hostFiber === null) {
+      return null;
+    }
+    if (hostFiber.mode & StrictMode) {
+      var componentName = getComponentName(fiber.type) || "Component";
+      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
+        didWarnAboutFindNodeInStrictMode[componentName] = true;
+        if (fiber.mode & StrictMode) {
+          warningWithoutStack$1(
+            false,
+            "%s is deprecated in StrictMode. " +
+              "%s was passed an instance of %s which is inside StrictMode. " +
+              "Instead, add a ref directly to the element you want to reference." +
+              "\n%s" +
+              "\n\nLearn more about using refs safely here:" +
+              "\nhttps://fb.me/react-strict-mode-find-node",
+            methodName,
+            methodName,
+            componentName,
+            getStackByFiberInDevAndProd(hostFiber)
+          );
+        } else {
+          warningWithoutStack$1(
+            false,
+            "%s is deprecated in StrictMode. " +
+              "%s was passed an instance of %s which renders StrictMode children. " +
+              "Instead, add a ref directly to the element you want to reference." +
+              "\n%s" +
+              "\n\nLearn more about using refs safely here:" +
+              "\nhttps://fb.me/react-strict-mode-find-node",
+            methodName,
+            methodName,
+            componentName,
+            getStackByFiberInDevAndProd(hostFiber)
+          );
+        }
+      }
+    }
+    return hostFiber.stateNode;
+  }
+  return findHostInstance$1(component);
+}
+
 function createContainer(containerInfo, isConcurrent, hydrate) {
   return createFiberRoot(containerInfo, isConcurrent, hydrate);
 }
@@ -15816,7 +17388,7 @@ function createPortal(
 
 // TODO: this is special because it gets imported during build.
 
-var ReactVersion = "16.5.2";
+var ReactVersion = "16.6.1";
 
 // Modules provided by RN:
 var NativeMethodsMixin = function(findNodeHandle, findHostInstance) {
@@ -16212,9 +17784,9 @@ var ReactNativeComponent = function(findNodeHandle, findHostInstance) {
 };
 
 // Module provided by RN:
-var emptyObject$2 = {};
+var emptyObject$1 = {};
 {
-  Object.freeze(emptyObject$2);
+  Object.freeze(emptyObject$1);
 }
 
 var getInspectorDataForViewTag = void 0;
@@ -16247,9 +17819,9 @@ var getInspectorDataForViewTag = void 0;
   var getHostProps = function(fiber) {
     var host = findCurrentHostFiber(fiber);
     if (host) {
-      return host.memoizedProps || emptyObject$2;
+      return host.memoizedProps || emptyObject$1;
     }
-    return emptyObject$2;
+    return emptyObject$1;
   };
 
   var getHostNode = function(fiber, findNodeHandle) {
@@ -16295,7 +17867,7 @@ var getInspectorDataForViewTag = void 0;
     if (!closestInstance) {
       return {
         hierarchy: [],
-        props: emptyObject$2,
+        props: emptyObject$1,
         selection: null,
         source: null
       };
@@ -16322,6 +17894,7 @@ var getInspectorDataForViewTag = void 0;
 // Module provided by RN:
 var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
 var findHostInstance = findHostInstance$1;
+var findHostInstanceWithWarning = findHostInstanceWithWarning$1;
 
 function findNodeHandle(componentOrHandle) {
   {
@@ -16355,7 +17928,14 @@ function findNodeHandle(componentOrHandle) {
   if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
     return componentOrHandle.canonical._nativeTag;
   }
-  var hostInstance = findHostInstance(componentOrHandle);
+  var hostInstance = void 0;
+  {
+    hostInstance = findHostInstanceWithWarning(
+      componentOrHandle,
+      "findNodeHandle"
+    );
+  }
+
   if (hostInstance == null) {
     return hostInstance;
   }
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-prod.js
@@ -19,7 +19,8 @@ var ReactNativeViewConfigRegistry = require("ReactNativeViewConfigRegistry"),
   deepDiffer = require("deepDiffer"),
   flattenStyle = require("flattenStyle"),
   TextInputState = require("TextInputState");
-var ExceptionsManager = require("ExceptionsManager");
+var scheduler = require("scheduler"),
+  ExceptionsManager = require("ExceptionsManager");
 function invariant(condition, format, a, b, c, d, e, f) {
   if (!condition) {
     condition = void 0;
@@ -166,10 +167,10 @@ var plugins = [],
   getFiberCurrentPropsFromNode = null,
   getInstanceFromNode = null,
   getNodeFromInstance = null;
-function executeDispatch(event, simulated, listener, inst) {
-  simulated = event.type || "unknown-event";
+function executeDispatch(event, listener, inst) {
+  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
-  invokeGuardedCallbackAndCatchFirstError(simulated, listener, void 0, event);
+  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
@@ -215,10 +216,10 @@ function executeDispatchesAndReleaseTopLevel(e) {
         i < dispatchListeners.length && !e.isPropagationStopped();
         i++
       )
-        executeDispatch(e, !1, dispatchListeners[i], dispatchInstances[i]);
+        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
     else
       dispatchListeners &&
-        executeDispatch(e, !1, dispatchListeners, dispatchInstances);
+        executeDispatch(e, dispatchListeners, dispatchInstances);
     e._dispatchListeners = null;
     e._dispatchInstances = null;
     e.isPersistent() || e.constructor.release(e);
@@ -293,7 +294,7 @@ function getListener(inst, registrationName) {
 }
 function getParent(inst) {
   do inst = inst.return;
-  while (inst && 7 !== inst.tag);
+  while (inst && 5 !== inst.tag);
   return inst ? inst : null;
 }
 function traverseTwoPhase(inst, fn, arg) {
@@ -1146,8 +1147,9 @@ var ReactSharedInternals =
     ? Symbol.for("react.concurrent_mode")
     : 60111,
   REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112,
-  REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for("react.placeholder") : 60113,
-  REACT_PURE_TYPE = hasSymbol ? Symbol.for("react.pure") : 60115,
+  REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
+  REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
+  REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
   MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
@@ -1171,29 +1173,28 @@ function getComponentName(type) {
       return "Profiler";
     case REACT_STRICT_MODE_TYPE:
       return "StrictMode";
-    case REACT_PLACEHOLDER_TYPE:
-      return "Placeholder";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
   }
-  if ("object" === typeof type) {
+  if ("object" === typeof type)
     switch (type.$$typeof) {
       case REACT_CONTEXT_TYPE:
         return "Context.Consumer";
       case REACT_PROVIDER_TYPE:
         return "Context.Provider";
       case REACT_FORWARD_REF_TYPE:
-        var renderFn = type.render;
-        renderFn = renderFn.displayName || renderFn.name || "";
+        var innerType = type.render;
+        innerType = innerType.displayName || innerType.name || "";
         return (
           type.displayName ||
-          ("" !== renderFn ? "ForwardRef(" + renderFn + ")" : "ForwardRef")
+          ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef")
         );
+      case REACT_MEMO_TYPE:
+        return getComponentName(type.type);
+      case REACT_LAZY_TYPE:
+        if ((type = 1 === type._status ? type._result : null))
+          return getComponentName(type);
     }
-    if (
-      "function" === typeof type.then &&
-      (type = 1 === type._reactStatus ? type._reactResult : null)
-    )
-      return getComponentName(type);
-  }
   return null;
 }
 function isFiberMountedImpl(fiber) {
@@ -1204,7 +1205,7 @@ function isFiberMountedImpl(fiber) {
     for (; node.return; )
       if (((node = node.return), 0 !== (node.effectTag & 2))) return 1;
   }
-  return 5 === node.tag ? 2 : 3;
+  return 3 === node.tag ? 2 : 3;
 }
 function assertIsMounted(fiber) {
   invariant(
@@ -1280,14 +1281,14 @@ function findCurrentFiberUsingSlowPath(fiber) {
       "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
     );
   }
-  invariant(5 === a.tag, "Unable to find node on an unmounted component.");
+  invariant(3 === a.tag, "Unable to find node on an unmounted component.");
   return a.stateNode.current === a ? fiber : alternate;
 }
 function findCurrentHostFiber(parent) {
   parent = findCurrentFiberUsingSlowPath(parent);
   if (!parent) return null;
   for (var node = parent; ; ) {
-    if (7 === node.tag || 8 === node.tag) return node;
+    if (5 === node.tag || 6 === node.tag) return node;
     if (node.child) (node.child.return = node), (node = node.child);
     else {
       if (node === parent) break;
@@ -1595,23 +1596,17 @@ var ReactNativeFiberHostComponent = (function() {
           return Date.now();
         },
   scheduledCallback = null,
-  frameDeadline = 0,
-  frameDeadlineObject = {
-    timeRemaining: function() {
-      return frameDeadline - now$1();
-    },
-    didTimeout: !1
-  };
+  frameDeadline = 0;
 function setTimeoutCallback() {
   frameDeadline = now$1() + 5;
   var callback = scheduledCallback;
   scheduledCallback = null;
-  null !== callback && callback(frameDeadlineObject);
+  null !== callback && callback();
 }
 function shim$1() {
   invariant(
     !1,
-    "The current renderer does not support hyration. This error is likely caused by a bug in React. Please file an issue."
+    "The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue."
   );
 }
 var UPDATE_SIGNAL = {},
@@ -1640,18 +1635,20 @@ function finalizeInitialChildren(parentInstance) {
   UIManager.setChildren(parentInstance._nativeTag, nativeTags);
   return !1;
 }
-var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
+var scheduleTimeout = setTimeout,
+  cancelTimeout = clearTimeout,
+  BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 function getStackByFiberInDevAndProd(workInProgress) {
   var info = "";
   do {
     a: switch (workInProgress.tag) {
-      case 4:
+      case 2:
+      case 16:
       case 0:
       case 1:
-      case 2:
-      case 3:
-      case 7:
-      case 10:
+      case 5:
+      case 8:
+      case 13:
         var owner = workInProgress._debugOwner,
           source = workInProgress._debugSource,
           name = getComponentName(workInProgress.type);
@@ -1802,7 +1799,7 @@ function injectInternals(internals) {
 function FiberNode(tag, pendingProps, key, mode) {
   this.tag = tag;
   this.key = key;
-  this.sibling = this.child = this.return = this.stateNode = this.type = null;
+  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
@@ -1813,29 +1810,33 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.childExpirationTime = this.expirationTime = 0;
   this.alternate = null;
 }
+function createFiber(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
 function shouldConstruct(Component) {
   Component = Component.prototype;
   return !(!Component || !Component.isReactComponent);
 }
-function resolveLazyComponentTag(fiber, Component) {
+function resolveLazyComponentTag(Component) {
   if ("function" === typeof Component)
-    return shouldConstruct(Component) ? 3 : 1;
+    return shouldConstruct(Component) ? 1 : 0;
   if (void 0 !== Component && null !== Component) {
-    fiber = Component.$$typeof;
-    if (fiber === REACT_FORWARD_REF_TYPE) return 14;
-    if (fiber === REACT_PURE_TYPE) return 18;
+    Component = Component.$$typeof;
+    if (Component === REACT_FORWARD_REF_TYPE) return 11;
+    if (Component === REACT_MEMO_TYPE) return 14;
   }
-  return 4;
+  return 2;
 }
 function createWorkInProgress(current, pendingProps) {
   var workInProgress = current.alternate;
   null === workInProgress
-    ? ((workInProgress = new FiberNode(
+    ? ((workInProgress = createFiber(
         current.tag,
         pendingProps,
         current.key,
         current.mode
       )),
+      (workInProgress.elementType = current.elementType),
       (workInProgress.type = current.type),
       (workInProgress.stateNode = current.stateNode),
       (workInProgress.alternate = current),
@@ -1857,60 +1858,66 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.ref = current.ref;
   return workInProgress;
 }
-function createFiberFromElement(element, mode, expirationTime) {
-  var type = element.type,
-    key = element.key;
-  element = element.props;
-  var fiberTag = void 0;
-  if ("function" === typeof type) fiberTag = shouldConstruct(type) ? 2 : 4;
-  else if ("string" === typeof type) fiberTag = 7;
+function createFiberFromTypeAndProps(
+  type,
+  key,
+  pendingProps,
+  owner,
+  mode,
+  expirationTime
+) {
+  var fiberTag = 2;
+  owner = type;
+  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
+  else if ("string" === typeof type) fiberTag = 5;
   else
     a: switch (type) {
       case REACT_FRAGMENT_TYPE:
         return createFiberFromFragment(
-          element.children,
+          pendingProps.children,
           mode,
           expirationTime,
           key
         );
       case REACT_CONCURRENT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 3;
-        break;
+        return createFiberFromMode(pendingProps, mode | 3, expirationTime, key);
       case REACT_STRICT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 2;
-        break;
+        return createFiberFromMode(pendingProps, mode | 2, expirationTime, key);
       case REACT_PROFILER_TYPE:
         return (
-          (type = new FiberNode(15, element, key, mode | 4)),
+          (type = createFiber(12, pendingProps, key, mode | 4)),
+          (type.elementType = REACT_PROFILER_TYPE),
           (type.type = REACT_PROFILER_TYPE),
           (type.expirationTime = expirationTime),
           type
         );
-      case REACT_PLACEHOLDER_TYPE:
-        fiberTag = 16;
-        break;
+      case REACT_SUSPENSE_TYPE:
+        return (
+          (type = createFiber(13, pendingProps, key, mode)),
+          (type.elementType = REACT_SUSPENSE_TYPE),
+          (type.type = REACT_SUSPENSE_TYPE),
+          (type.expirationTime = expirationTime),
+          type
+        );
       default:
         if ("object" === typeof type && null !== type)
           switch (type.$$typeof) {
             case REACT_PROVIDER_TYPE:
-              fiberTag = 12;
+              fiberTag = 10;
               break a;
             case REACT_CONTEXT_TYPE:
-              fiberTag = 11;
+              fiberTag = 9;
               break a;
             case REACT_FORWARD_REF_TYPE:
-              fiberTag = 13;
+              fiberTag = 11;
               break a;
-            case REACT_PURE_TYPE:
-              fiberTag = 17;
+            case REACT_MEMO_TYPE:
+              fiberTag = 14;
+              break a;
+            case REACT_LAZY_TYPE:
+              fiberTag = 16;
+              owner = null;
               break a;
-            default:
-              if ("function" === typeof type.then) {
-                fiberTag = 4;
-                break a;
-              }
           }
         invariant(
           !1,
@@ -1919,24 +1926,33 @@ function createFiberFromElement(element, mode, expirationTime) {
           ""
         );
     }
-  mode = new FiberNode(fiberTag, element, key, mode);
-  mode.type = type;
-  mode.expirationTime = expirationTime;
-  return mode;
+  key = createFiber(fiberTag, pendingProps, key, mode);
+  key.elementType = type;
+  key.type = owner;
+  key.expirationTime = expirationTime;
+  return key;
 }
 function createFiberFromFragment(elements, mode, expirationTime, key) {
-  elements = new FiberNode(9, elements, key, mode);
+  elements = createFiber(7, elements, key, mode);
   elements.expirationTime = expirationTime;
   return elements;
 }
+function createFiberFromMode(pendingProps, mode, expirationTime, key) {
+  pendingProps = createFiber(8, pendingProps, key, mode);
+  mode = 0 === (mode & 1) ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
+  pendingProps.elementType = mode;
+  pendingProps.type = mode;
+  pendingProps.expirationTime = expirationTime;
+  return pendingProps;
+}
 function createFiberFromText(content, mode, expirationTime) {
-  content = new FiberNode(8, content, null, mode);
+  content = createFiber(6, content, null, mode);
   content.expirationTime = expirationTime;
   return content;
 }
 function createFiberFromPortal(portal, mode, expirationTime) {
-  mode = new FiberNode(
-    6,
+  mode = createFiber(
+    4,
     null !== portal.children ? portal.children : [],
     portal.key,
     mode
@@ -1954,12 +1970,45 @@ function markPendingPriorityLevel(root, expirationTime) {
   var earliestPendingTime = root.earliestPendingTime;
   0 === earliestPendingTime
     ? (root.earliestPendingTime = root.latestPendingTime = expirationTime)
-    : earliestPendingTime > expirationTime
+    : earliestPendingTime < expirationTime
       ? (root.earliestPendingTime = expirationTime)
-      : root.latestPendingTime < expirationTime &&
+      : root.latestPendingTime > expirationTime &&
         (root.latestPendingTime = expirationTime);
   findNextExpirationTimeToWorkOn(expirationTime, root);
 }
+function markSuspendedPriorityLevel(root, suspendedTime) {
+  root.didError = !1;
+  var latestPingedTime = root.latestPingedTime;
+  0 !== latestPingedTime &&
+    latestPingedTime >= suspendedTime &&
+    (root.latestPingedTime = 0);
+  latestPingedTime = root.earliestPendingTime;
+  var latestPendingTime = root.latestPendingTime;
+  latestPingedTime === suspendedTime
+    ? (root.earliestPendingTime =
+        latestPendingTime === suspendedTime
+          ? (root.latestPendingTime = 0)
+          : latestPendingTime)
+    : latestPendingTime === suspendedTime &&
+      (root.latestPendingTime = latestPingedTime);
+  latestPingedTime = root.earliestSuspendedTime;
+  latestPendingTime = root.latestSuspendedTime;
+  0 === latestPingedTime
+    ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
+    : latestPingedTime < suspendedTime
+      ? (root.earliestSuspendedTime = suspendedTime)
+      : latestPendingTime > suspendedTime &&
+        (root.latestSuspendedTime = suspendedTime);
+  findNextExpirationTimeToWorkOn(suspendedTime, root);
+}
+function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
+  var earliestPendingTime = root.earliestPendingTime;
+  root = root.earliestSuspendedTime;
+  earliestPendingTime > renderExpirationTime &&
+    (renderExpirationTime = earliestPendingTime);
+  root > renderExpirationTime && (renderExpirationTime = root);
+  return renderExpirationTime;
+}
 function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   var earliestSuspendedTime = root.earliestSuspendedTime,
     latestSuspendedTime = root.latestSuspendedTime,
@@ -1969,12 +2018,11 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
     0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
   0 === earliestPendingTime &&
     (0 === completedExpirationTime ||
-      latestSuspendedTime > completedExpirationTime) &&
+      latestSuspendedTime < completedExpirationTime) &&
     (earliestPendingTime = latestSuspendedTime);
   completedExpirationTime = earliestPendingTime;
   0 !== completedExpirationTime &&
-    0 !== earliestSuspendedTime &&
-    earliestSuspendedTime < completedExpirationTime &&
+    earliestSuspendedTime > completedExpirationTime &&
     (completedExpirationTime = earliestSuspendedTime);
   root.nextExpirationTimeToWorkOn = earliestPendingTime;
   root.expirationTime = completedExpirationTime;
@@ -2086,7 +2134,7 @@ function getStateFromUpdate(
           : workInProgress
       );
     case 3:
-      workInProgress.effectTag = (workInProgress.effectTag & -1025) | 64;
+      workInProgress.effectTag = (workInProgress.effectTag & -2049) | 64;
     case 0:
       workInProgress = update.payload;
       nextProps =
@@ -2119,58 +2167,52 @@ function processUpdateQueue(
 
   ) {
     var updateExpirationTime = update.expirationTime;
-    if (updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === newFirstUpdate &&
+    updateExpirationTime < renderExpirationTime
+      ? (null === newFirstUpdate &&
           ((newFirstUpdate = update), (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > updateExpirationTime)
-      )
-        newExpirationTime = updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < updateExpirationTime &&
+          (newExpirationTime = updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastEffect
             ? (queue.firstEffect = queue.lastEffect = update)
             : ((queue.lastEffect.nextEffect = update),
-              (queue.lastEffect = update)));
+              (queue.lastEffect = update))));
     update = update.next;
   }
   updateExpirationTime = null;
   for (update = queue.firstCapturedUpdate; null !== update; ) {
     var _updateExpirationTime = update.expirationTime;
-    if (_updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === updateExpirationTime &&
+    _updateExpirationTime < renderExpirationTime
+      ? (null === updateExpirationTime &&
           ((updateExpirationTime = update),
           null === newFirstUpdate && (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > _updateExpirationTime)
-      )
-        newExpirationTime = _updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < _updateExpirationTime &&
+          (newExpirationTime = _updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastCapturedEffect
             ? (queue.firstCapturedEffect = queue.lastCapturedEffect = update)
             : ((queue.lastCapturedEffect.nextEffect = update),
-              (queue.lastCapturedEffect = update)));
+              (queue.lastCapturedEffect = update))));
     update = update.next;
   }
   null === newFirstUpdate && (queue.lastUpdate = null);
@@ -2251,13 +2293,277 @@ function readContext(context, observedBits) {
     null === lastContextDependency
       ? (invariant(
           null !== currentlyRenderingFiber,
-          "Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
+          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
         ),
         (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
       : (lastContextDependency = lastContextDependency.next = observedBits);
   }
   return context._currentValue;
 }
+function areHookInputsEqual(arr1, arr2) {
+  for (var i = 0; i < arr1.length; i++) {
+    var val1 = arr1[i],
+      val2 = arr2[i];
+    if (
+      (val1 !== val2 || (0 === val1 && 1 / val1 !== 1 / val2)) &&
+      (val1 === val1 || val2 === val2)
+    )
+      return !1;
+  }
+  return !0;
+}
+var renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  isReRender = !1,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = 0;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function finishHooks(Component, props, children, refOrContext) {
+  for (; didScheduleRenderPhaseUpdate; )
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (children = Component(props, refOrContext));
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return children;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.memoizedState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((isReRender = !1),
+        (currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((isReRender = !0),
+        (currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    isReRender = !1;
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (isReRender = !0),
+      (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (isReRender) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do
+            (initialAction = reducer(
+              initialAction,
+              firstRenderPhaseUpdate.action
+            )),
+              (firstRenderPhaseUpdate = firstRenderPhaseUpdate.next);
+          while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      initialAction = workInProgressHook.baseState;
+      var newBaseUpdate = (firstRenderPhaseUpdate = null),
+        _update = initialState,
+        didSkip = !1;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (newBaseUpdate = _baseUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : (initialAction = reducer(initialAction, _update.action));
+        _baseUpdate = _update;
+        _update = _update.next;
+      } while (null !== _update && _update !== initialState);
+      didSkip ||
+        ((newBaseUpdate = _baseUpdate),
+        (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = { last: null, dispatch: null };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, inputs) {
+  tag = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    inputs: inputs,
+    next: null
+  };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  inputs = void 0 !== inputs && null !== inputs ? inputs : [create];
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (areHookInputsEqual(inputs, prevEffect.inputs)) {
+      pushEffect(0, create, destroy, inputs);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    inputs
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (alternate = renderPhaseUpdates.get(queue)),
+      void 0 === alternate)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = alternate; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    alternate = requestCurrentTime();
+    alternate = computeExpirationForFiber(alternate, fiber);
+    action = { expirationTime: alternate, action: action, next: null };
+    flushPassiveEffects();
+    var _last2 = queue.last;
+    if (null === _last2) action.next = action;
+    else {
+      var first = _last2.next;
+      null !== first && (action.next = first);
+      _last2.next = action;
+    }
+    queue.last = action;
+    scheduleWork(fiber, alternate);
+  }
+}
 var NO_CONTEXT = {},
   contextStackCursor$1 = { current: NO_CONTEXT },
   contextFiberStackCursor = { current: NO_CONTEXT },
@@ -2327,7 +2633,47 @@ function shallowEqual(objA, objB) {
       return !1;
   return !0;
 }
-var emptyRefsObject = new React.Component().refs;
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    baseProps = Object.assign({}, baseProps);
+    Component = Component.defaultProps;
+    for (var propName in Component)
+      void 0 === baseProps[propName] &&
+        (baseProps[propName] = Component[propName]);
+  }
+  return baseProps;
+}
+function readLazyComponentType(lazyComponent) {
+  var result = lazyComponent._result;
+  switch (lazyComponent._status) {
+    case 1:
+      return result;
+    case 2:
+      throw result;
+    case 0:
+      throw result;
+    default:
+      throw ((lazyComponent._status = 0),
+      (result = lazyComponent._ctor),
+      (result = result()),
+      result.then(
+        function(moduleObject) {
+          0 === lazyComponent._status &&
+            ((moduleObject = moduleObject.default),
+            (lazyComponent._status = 1),
+            (lazyComponent._result = moduleObject));
+        },
+        function(error) {
+          0 === lazyComponent._status &&
+            ((lazyComponent._status = 2), (lazyComponent._result = error));
+        }
+      ),
+      (lazyComponent._result = result),
+      result);
+  }
+}
+var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
+  emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2359,6 +2705,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2370,6 +2717,7 @@ var classComponentUpdater = {
     update.tag = 1;
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2380,6 +2728,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.tag = 2;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   }
@@ -2400,6 +2749,32 @@ function checkShouldComponentUpdate(
       ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
       : !0;
 }
+function constructClassInstance(workInProgress, ctor, props) {
+  var isLegacyContextConsumer = !1,
+    unmaskedContext = emptyContextObject;
+  var context = ctor.contextType;
+  "object" === typeof context && null !== context
+    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    : ((unmaskedContext = isContextProvider(ctor)
+        ? previousContext
+        : contextStackCursor.current),
+      (isLegacyContextConsumer = ctor.contextTypes),
+      (context = (isLegacyContextConsumer =
+        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
+        ? getMaskedContext(workInProgress, unmaskedContext)
+        : emptyContextObject));
+  ctor = new ctor(props, context);
+  workInProgress.memoizedState =
+    null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
+  ctor.updater = classComponentUpdater;
+  workInProgress.stateNode = ctor;
+  ctor._reactInternalFiber = workInProgress;
+  isLegacyContextConsumer &&
+    ((workInProgress = workInProgress.stateNode),
+    (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
+    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
+  return ctor;
+}
 function callComponentWillReceiveProps(
   workInProgress,
   instance,
@@ -2426,7 +2801,9 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = contextType.unstable_read())
+    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
+        contextType
+      ))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2481,10 +2858,7 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(
-          2 === element.tag || 3 === element.tag,
-          "Function components cannot have refs."
-        ),
+        (invariant(1 === element.tag, "Function components cannot have refs."),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -2589,7 +2963,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     textContent,
     expirationTime
   ) {
-    if (null === current$$1 || 8 !== current$$1.tag)
+    if (null === current$$1 || 6 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromText(
           textContent,
@@ -2604,15 +2978,18 @@ function ChildReconciler(shouldTrackSideEffects) {
     return current$$1;
   }
   function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (null !== current$$1 && current$$1.type === element.type)
+    if (null !== current$$1 && current$$1.elementType === element.type)
       return (
         (expirationTime = useFiber(current$$1, element.props, expirationTime)),
         (expirationTime.ref = coerceRef(returnFiber, current$$1, element)),
         (expirationTime.return = returnFiber),
         expirationTime
       );
-    expirationTime = createFiberFromElement(
-      element,
+    expirationTime = createFiberFromTypeAndProps(
+      element.type,
+      element.key,
+      element.props,
+      null,
       returnFiber.mode,
       expirationTime
     );
@@ -2623,7 +3000,7 @@ function ChildReconciler(shouldTrackSideEffects) {
   function updatePortal(returnFiber, current$$1, portal, expirationTime) {
     if (
       null === current$$1 ||
-      6 !== current$$1.tag ||
+      4 !== current$$1.tag ||
       current$$1.stateNode.containerInfo !== portal.containerInfo ||
       current$$1.stateNode.implementation !== portal.implementation
     )
@@ -2647,7 +3024,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     expirationTime,
     key
   ) {
-    if (null === current$$1 || 9 !== current$$1.tag)
+    if (null === current$$1 || 7 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromFragment(
           fragment,
@@ -2677,8 +3054,11 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
           return (
-            (expirationTime = createFiberFromElement(
-              newChild,
+            (expirationTime = createFiberFromTypeAndProps(
+              newChild.type,
+              newChild.key,
+              newChild.props,
+              null,
               returnFiber.mode,
               expirationTime
             )),
@@ -3022,9 +3402,9 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (isUnkeyedTopLevelFragment.key === isObject)
                 if (
-                  9 === isUnkeyedTopLevelFragment.tag
+                  7 === isUnkeyedTopLevelFragment.tag
                     ? newChild.type === REACT_FRAGMENT_TYPE
-                    : isUnkeyedTopLevelFragment.type === newChild.type
+                    : isUnkeyedTopLevelFragment.elementType === newChild.type
                 ) {
                   deleteRemainingChildren(
                     returnFiber,
@@ -3064,8 +3444,11 @@ function ChildReconciler(shouldTrackSideEffects) {
                 )),
                 (currentFirstChild.return = returnFiber),
                 (returnFiber = currentFirstChild))
-              : ((expirationTime = createFiberFromElement(
-                  newChild,
+              : ((expirationTime = createFiberFromTypeAndProps(
+                  newChild.type,
+                  newChild.key,
+                  newChild.props,
+                  null,
                   returnFiber.mode,
                   expirationTime
                 )),
@@ -3087,7 +3470,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (currentFirstChild.key === isUnkeyedTopLevelFragment)
                 if (
-                  6 === currentFirstChild.tag &&
+                  4 === currentFirstChild.tag &&
                   currentFirstChild.stateNode.containerInfo ===
                     newChild.containerInfo &&
                   currentFirstChild.stateNode.implementation ===
@@ -3125,7 +3508,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (newChild = "" + newChild),
-        null !== currentFirstChild && 8 === currentFirstChild.tag
+        null !== currentFirstChild && 6 === currentFirstChild.tag
           ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
             (currentFirstChild = useFiber(
               currentFirstChild,
@@ -3161,8 +3544,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     isObject && throwOnInvalidObjectType(returnFiber, newChild);
     if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
       switch (returnFiber.tag) {
-        case 2:
-        case 3:
+        case 1:
         case 0:
           (expirationTime = returnFiber.type),
             invariant(
@@ -3181,12 +3563,12 @@ var reconcileChildFibers = ChildReconciler(!0),
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
   switch (fiber.tag) {
-    case 7:
+    case 5:
       return (
         (nextInstance = shim$1(nextInstance, fiber.type, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
       );
-    case 8:
+    case 6:
       return (
         (nextInstance = shim$1(nextInstance, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
@@ -3209,7 +3591,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
           return;
         }
         var returnFiber = hydrationParentFiber,
-          fiber = new FiberNode(7, null, null, 0);
+          fiber = createFiber(5, null, null, 0);
+        fiber.elementType = "DELETED";
         fiber.type = "DELETED";
         fiber.stateNode = firstAttemptedInstance;
         fiber.return = returnFiber;
@@ -3227,38 +3610,6 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-function readLazyComponentType(thenable) {
-  switch (thenable._reactStatus) {
-    case 1:
-      return thenable._reactResult;
-    case 2:
-      throw thenable._reactResult;
-    case 0:
-      throw thenable;
-    default:
-      throw ((thenable._reactStatus = 0),
-      thenable.then(
-        function(resolvedValue) {
-          if (0 === thenable._reactStatus) {
-            thenable._reactStatus = 1;
-            if ("object" === typeof resolvedValue && null !== resolvedValue) {
-              var defaultExport = resolvedValue.default;
-              resolvedValue =
-                void 0 !== defaultExport && null !== defaultExport
-                  ? defaultExport
-                  : resolvedValue;
-            }
-            thenable._reactResult = resolvedValue;
-          }
-        },
-        function(error) {
-          0 === thenable._reactStatus &&
-            ((thenable._reactStatus = 2), (thenable._reactResult = error));
-        }
-      ),
-      thenable);
-  }
-}
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 function reconcileChildren(
   current$$1,
@@ -3284,28 +3635,28 @@ function reconcileChildren(
 function updateForwardRef(
   current$$1,
   workInProgress,
-  type,
+  Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
-  type = type.render;
+  Component = Component.render;
   var ref = workInProgress.ref;
-  if (
-    !didPerformWorkStackCursor.current &&
-    workInProgress.memoizedProps === nextProps &&
-    ref === (null !== current$$1 ? current$$1.ref : null)
-  )
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  type = type(nextProps, ref);
-  reconcileChildren(current$$1, workInProgress, type, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, ref);
+  nextChildren = finishHooks(Component, nextProps, nextChildren, ref);
+  workInProgress.effectTag |= 1;
+  reconcileChildren(
+    current$$1,
+    workInProgress,
+    nextChildren,
+    renderExpirationTime$jscomp$0
+  );
   return workInProgress.child;
 }
-function updatePureComponent(
+function updateMemoComponent(
   current$$1,
   workInProgress,
   Component,
@@ -3313,27 +3664,82 @@ function updatePureComponent(
   updateExpirationTime,
   renderExpirationTime
 ) {
-  var render = Component.render;
+  if (null === current$$1) {
+    var type = Component.type;
+    if (
+      "function" === typeof type &&
+      !shouldConstruct(type) &&
+      void 0 === type.defaultProps &&
+      null === Component.compare
+    )
+      return (
+        (workInProgress.tag = 15),
+        (workInProgress.type = type),
+        updateSimpleMemoComponent(
+          current$$1,
+          workInProgress,
+          type,
+          nextProps,
+          updateExpirationTime,
+          renderExpirationTime
+        )
+      );
+    current$$1 = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      null,
+      workInProgress.mode,
+      renderExpirationTime
+    );
+    current$$1.ref = workInProgress.ref;
+    current$$1.return = workInProgress;
+    return (workInProgress.child = current$$1);
+  }
+  type = current$$1.child;
   if (
-    null !== current$$1 &&
-    (0 === updateExpirationTime ||
-      updateExpirationTime > renderExpirationTime) &&
-    ((updateExpirationTime = current$$1.memoizedProps),
+    updateExpirationTime < renderExpirationTime &&
+    ((updateExpirationTime = type.memoizedProps),
     (Component = Component.compare),
     (Component = null !== Component ? Component : shallowEqual),
-    Component(updateExpirationTime, nextProps))
+    Component(updateExpirationTime, nextProps) &&
+      current$$1.ref === workInProgress.ref)
   )
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
       renderExpirationTime
     );
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  render = render(nextProps);
   workInProgress.effectTag |= 1;
-  reconcileChildren(current$$1, workInProgress, render, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
-  return workInProgress.child;
+  current$$1 = createWorkInProgress(type, nextProps, renderExpirationTime);
+  current$$1.ref = workInProgress.ref;
+  current$$1.return = workInProgress;
+  return (workInProgress.child = current$$1);
+}
+function updateSimpleMemoComponent(
+  current$$1,
+  workInProgress,
+  Component,
+  nextProps,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  return null !== current$$1 &&
+    updateExpirationTime < renderExpirationTime &&
+    shallowEqual(current$$1.memoizedProps, nextProps) &&
+    current$$1.ref === workInProgress.ref
+    ? bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    : updateFunctionComponent(
+        current$$1,
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      );
 }
 function markRef(current$$1, workInProgress) {
   var ref = workInProgress.ref;
@@ -3348,22 +3754,30 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
   var unmaskedContext = isContextProvider(Component)
     ? previousContext
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, unmaskedContext);
+  nextChildren = finishHooks(
+    Component,
+    nextProps,
+    nextChildren,
+    unmaskedContext
+  );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
     workInProgress,
-    Component,
-    renderExpirationTime
+    nextChildren,
+    renderExpirationTime$jscomp$0
   );
-  workInProgress.memoizedProps = nextProps;
   return workInProgress.child;
 }
 function updateClassComponent(
@@ -3378,82 +3792,153 @@ function updateClassComponent(
     pushContextProvider(workInProgress);
   } else hasContext = !1;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  if (null === current$$1)
-    if (null === workInProgress.stateNode) {
-      var isLegacyContextConsumer = !1,
-        unmaskedContext = emptyContextObject;
-      var context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((unmaskedContext = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (isLegacyContextConsumer = Component.contextTypes),
-          (context = (isLegacyContextConsumer =
-            null !== isLegacyContextConsumer &&
-            void 0 !== isLegacyContextConsumer)
-            ? getMaskedContext(workInProgress, unmaskedContext)
-            : emptyContextObject));
-      var instance = new Component(nextProps, context);
-      workInProgress.memoizedState =
-        null !== instance.state && void 0 !== instance.state
-          ? instance.state
-          : null;
-      instance.updater = classComponentUpdater;
-      workInProgress.stateNode = instance;
-      instance._reactInternalFiber = workInProgress;
-      isLegacyContextConsumer &&
-        ((isLegacyContextConsumer = workInProgress.stateNode),
-        (isLegacyContextConsumer.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
-        (isLegacyContextConsumer.__reactInternalMemoizedMaskedChildContext = context));
+  if (null === workInProgress.stateNode)
+    null !== current$$1 &&
+      ((current$$1.alternate = null),
+      (workInProgress.alternate = null),
+      (workInProgress.effectTag |= 2)),
+      constructClassInstance(
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      ),
       mountClassInstance(
         workInProgress,
         Component,
         nextProps,
         renderExpirationTime
-      );
-      nextProps = !0;
-    } else {
-      unmaskedContext = workInProgress.stateNode;
-      isLegacyContextConsumer = workInProgress.memoizedProps;
-      unmaskedContext.props = isLegacyContextConsumer;
-      var oldContext = unmaskedContext.context;
-      context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
+      ),
+      (nextProps = !0);
+  else if (null === current$$1) {
+    var instance = workInProgress.stateNode,
+      oldProps = workInProgress.memoizedProps;
+    instance.props = oldProps;
+    var oldContext = instance.context,
+      contextType = Component.contextType;
+    "object" === typeof contextType && null !== contextType
+      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+          contextType
+        ))
+      : ((contextType = isContextProvider(Component)
+          ? previousContext
+          : contextStackCursor.current),
+        (contextType = getMaskedContext(workInProgress, contextType)));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
+      hasNewLifecycles =
+        "function" === typeof getDerivedStateFromProps ||
+        "function" === typeof instance.getSnapshotBeforeUpdate;
+    hasNewLifecycles ||
+      ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof instance.componentWillReceiveProps) ||
+      ((oldProps !== nextProps || oldContext !== contextType) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          instance,
+          nextProps,
+          contextType
+        ));
+    hasForceUpdate = !1;
+    var oldState = workInProgress.memoizedState;
+    oldContext = instance.state = oldState;
+    var updateQueue = workInProgress.updateQueue;
+    null !== updateQueue &&
+      (processUpdateQueue(
+        workInProgress,
+        updateQueue,
+        nextProps,
+        instance,
+        renderExpirationTime
+      ),
+      (oldContext = workInProgress.memoizedState));
+    oldProps !== nextProps ||
+    oldState !== oldContext ||
+    didPerformWorkStackCursor.current ||
+    hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps,
+            nextProps
+          ),
+          (oldContext = workInProgress.memoizedState)),
+        (oldProps =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
+            workInProgress,
+            Component,
+            oldProps,
+            nextProps,
+            oldState,
+            oldContext,
+            contextType
+          ))
+          ? (hasNewLifecycles ||
+              ("function" !== typeof instance.UNSAFE_componentWillMount &&
+                "function" !== typeof instance.componentWillMount) ||
+              ("function" === typeof instance.componentWillMount &&
+                instance.componentWillMount(),
+              "function" === typeof instance.UNSAFE_componentWillMount &&
+                instance.UNSAFE_componentWillMount()),
+            "function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4))
+          : ("function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = oldContext)),
+        (instance.props = nextProps),
+        (instance.state = oldContext),
+        (instance.context = contextType),
+        (nextProps = oldProps))
+      : ("function" === typeof instance.componentDidMount &&
+          (workInProgress.effectTag |= 4),
+        (nextProps = !1));
+  } else
+    (instance = workInProgress.stateNode),
+      (oldProps = workInProgress.memoizedProps),
+      (instance.props =
+        workInProgress.type === workInProgress.elementType
+          ? oldProps
+          : resolveDefaultProps(workInProgress.type, oldProps)),
+      (oldContext = instance.context),
+      (contextType = Component.contextType),
+      "object" === typeof contextType && null !== contextType
+        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+            contextType
+          ))
+        : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context)));
-      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
-      (instance =
+          (contextType = getMaskedContext(workInProgress, contextType))),
+      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
+      (hasNewLifecycles =
         "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
+        "function" === typeof instance.getSnapshotBeforeUpdate) ||
+        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+          "function" !== typeof instance.componentWillReceiveProps) ||
+        ((oldProps !== nextProps || oldContext !== contextType) &&
           callComponentWillReceiveProps(
             workInProgress,
-            unmaskedContext,
+            instance,
             nextProps,
-            context
-          ));
-      hasForceUpdate = !1;
-      var oldState = workInProgress.memoizedState;
-      oldContext = unmaskedContext.state = oldState;
-      var updateQueue = workInProgress.updateQueue;
+            contextType
+          )),
+      (hasForceUpdate = !1),
+      (oldContext = workInProgress.memoizedState),
+      (oldState = instance.state = oldContext),
+      (updateQueue = workInProgress.updateQueue),
       null !== updateQueue &&
         (processUpdateQueue(
           workInProgress,
           updateQueue,
           nextProps,
-          unmaskedContext,
+          instance,
           renderExpirationTime
         ),
-        (oldContext = workInProgress.memoizedState));
-      isLegacyContextConsumer !== nextProps ||
-      oldState !== oldContext ||
+        (oldState = workInProgress.memoizedState)),
+      oldProps !== nextProps ||
+      oldContext !== oldState ||
       didPerformWorkStackCursor.current ||
       hasForceUpdate
         ? ("function" === typeof getDerivedStateFromProps &&
@@ -3463,144 +3948,57 @@ function updateClassComponent(
               getDerivedStateFromProps,
               nextProps
             ),
-            (oldContext = workInProgress.memoizedState)),
-          (isLegacyContextConsumer =
+            (oldState = workInProgress.memoizedState)),
+          (getDerivedStateFromProps =
             hasForceUpdate ||
             checkShouldComponentUpdate(
               workInProgress,
               Component,
-              isLegacyContextConsumer,
+              oldProps,
               nextProps,
-              oldState,
               oldContext,
-              context
+              oldState,
+              contextType
             ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  "function" !== typeof unmaskedContext.componentWillMount) ||
-                ("function" === typeof unmaskedContext.componentWillMount &&
-                  unmaskedContext.componentWillMount(),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  unmaskedContext.UNSAFE_componentWillMount()),
-              "function" === typeof unmaskedContext.componentDidMount &&
-                (workInProgress.effectTag |= 4))
-            : ("function" === typeof unmaskedContext.componentDidMount &&
+            ? (hasNewLifecycles ||
+                ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
+                  "function" !== typeof instance.componentWillUpdate) ||
+                ("function" === typeof instance.componentWillUpdate &&
+                  instance.componentWillUpdate(
+                    nextProps,
+                    oldState,
+                    contextType
+                  ),
+                "function" === typeof instance.UNSAFE_componentWillUpdate &&
+                  instance.UNSAFE_componentWillUpdate(
+                    nextProps,
+                    oldState,
+                    contextType
+                  )),
+              "function" === typeof instance.componentDidUpdate &&
+                (workInProgress.effectTag |= 4),
+              "function" === typeof instance.getSnapshotBeforeUpdate &&
+                (workInProgress.effectTag |= 256))
+            : ("function" !== typeof instance.componentDidUpdate ||
+                (oldProps === current$$1.memoizedProps &&
+                  oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 4),
-              (workInProgress.memoizedProps = nextProps),
-              (workInProgress.memoizedState = oldContext)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldContext),
-          (unmaskedContext.context = context),
-          (nextProps = isLegacyContextConsumer))
-        : ("function" === typeof unmaskedContext.componentDidMount &&
-            (workInProgress.effectTag |= 4),
-          (nextProps = !1));
-    }
-  else
-    (unmaskedContext = workInProgress.stateNode),
-      (isLegacyContextConsumer = workInProgress.memoizedProps),
-      (unmaskedContext.props = isLegacyContextConsumer),
-      (oldContext = unmaskedContext.context),
-      (context = Component.contextType),
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context))),
-      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
-      (instance =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
-          callComponentWillReceiveProps(
-            workInProgress,
-            unmaskedContext,
-            nextProps,
-            context
-          )),
-      (hasForceUpdate = !1),
-      (oldContext = workInProgress.memoizedState),
-      (oldState = unmaskedContext.state = oldContext),
-      (updateQueue = workInProgress.updateQueue),
-      null !== updateQueue &&
-        (processUpdateQueue(
-          workInProgress,
-          updateQueue,
-          nextProps,
-          unmaskedContext,
-          renderExpirationTime
-        ),
-        (oldState = workInProgress.memoizedState)),
-      isLegacyContextConsumer !== nextProps ||
-      oldContext !== oldState ||
-      didPerformWorkStackCursor.current ||
-      hasForceUpdate
-        ? ("function" === typeof getDerivedStateFromProps &&
-            (applyDerivedStateFromProps(
-              workInProgress,
-              Component,
-              getDerivedStateFromProps,
-              nextProps
-            ),
-            (oldState = workInProgress.memoizedState)),
-          (getDerivedStateFromProps =
-            hasForceUpdate ||
-            checkShouldComponentUpdate(
-              workInProgress,
-              Component,
-              isLegacyContextConsumer,
-              nextProps,
-              oldContext,
-              oldState,
-              context
-            ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  "function" !== typeof unmaskedContext.componentWillUpdate) ||
-                ("function" === typeof unmaskedContext.componentWillUpdate &&
-                  unmaskedContext.componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    context
-                  ),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  unmaskedContext.UNSAFE_componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    context
-                  )),
-              "function" === typeof unmaskedContext.componentDidUpdate &&
-                (workInProgress.effectTag |= 4),
-              "function" === typeof unmaskedContext.getSnapshotBeforeUpdate &&
-                (workInProgress.effectTag |= 256))
-            : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
-                  oldContext === current$$1.memoizedState) ||
-                (workInProgress.effectTag |= 4),
-              "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
-                  oldContext === current$$1.memoizedState) ||
-                (workInProgress.effectTag |= 256),
+              "function" !== typeof instance.getSnapshotBeforeUpdate ||
+                (oldProps === current$$1.memoizedProps &&
+                  oldContext === current$$1.memoizedState) ||
+                (workInProgress.effectTag |= 256),
               (workInProgress.memoizedProps = nextProps),
               (workInProgress.memoizedState = oldState)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldState),
-          (unmaskedContext.context = context),
+          (instance.props = nextProps),
+          (instance.state = oldState),
+          (instance.context = contextType),
           (nextProps = getDerivedStateFromProps))
-        : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+        : ("function" !== typeof instance.componentDidUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 4),
-          "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+          "function" !== typeof instance.getSnapshotBeforeUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 256),
           (nextProps = !1));
@@ -3659,7 +4057,6 @@ function finishClassComponent(
         renderExpirationTime
       );
   workInProgress.memoizedState = shouldUpdate.state;
-  workInProgress.memoizedProps = shouldUpdate.props;
   hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
@@ -3675,15 +4072,101 @@ function pushHostRootContext(workInProgress) {
       pushTopLevelContextObject(workInProgress, root.context, !1);
   pushHostContainer(workInProgress, root.containerInfo);
 }
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    baseProps = Object.assign({}, baseProps);
-    Component = Component.defaultProps;
-    for (var propName in Component)
-      void 0 === baseProps[propName] &&
-        (baseProps[propName] = Component[propName]);
-  }
-  return baseProps;
+function updateSuspenseComponent(
+  current$$1,
+  workInProgress,
+  renderExpirationTime
+) {
+  var mode = workInProgress.mode,
+    nextProps = workInProgress.pendingProps,
+    nextState = workInProgress.memoizedState;
+  if (0 === (workInProgress.effectTag & 64)) {
+    nextState = null;
+    var nextDidTimeout = !1;
+  } else
+    (nextState = { timedOutAt: null !== nextState ? nextState.timedOutAt : 0 }),
+      (nextDidTimeout = !0),
+      (workInProgress.effectTag &= -65);
+  null === current$$1
+    ? nextDidTimeout
+      ? ((nextDidTimeout = nextProps.fallback),
+        (nextProps = createFiberFromFragment(null, mode, 0, null)),
+        0 === (workInProgress.mode & 1) &&
+          (nextProps.child =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child),
+        (mode = createFiberFromFragment(
+          nextDidTimeout,
+          mode,
+          renderExpirationTime,
+          null
+        )),
+        (nextProps.sibling = mode),
+        (renderExpirationTime = nextProps),
+        (renderExpirationTime.return = mode.return = workInProgress))
+      : (renderExpirationTime = mode = mountChildFibers(
+          workInProgress,
+          null,
+          nextProps.children,
+          renderExpirationTime
+        ))
+    : null !== current$$1.memoizedState
+      ? ((mode = current$$1.child),
+        (current$$1 = mode.sibling),
+        nextDidTimeout
+          ? ((renderExpirationTime = nextProps.fallback),
+            (nextProps = createWorkInProgress(mode, mode.pendingProps, 0)),
+            0 === (workInProgress.mode & 1) &&
+              ((nextDidTimeout =
+                null !== workInProgress.memoizedState
+                  ? workInProgress.child.child
+                  : workInProgress.child),
+              nextDidTimeout !== mode.child &&
+                (nextProps.child = nextDidTimeout)),
+            (mode = nextProps.sibling = createWorkInProgress(
+              current$$1,
+              renderExpirationTime,
+              current$$1.expirationTime
+            )),
+            (renderExpirationTime = nextProps),
+            (nextProps.childExpirationTime = 0),
+            (renderExpirationTime.return = mode.return = workInProgress))
+          : (renderExpirationTime = mode = reconcileChildFibers(
+              workInProgress,
+              mode.child,
+              nextProps.children,
+              renderExpirationTime
+            )))
+      : ((current$$1 = current$$1.child),
+        nextDidTimeout
+          ? ((nextDidTimeout = nextProps.fallback),
+            (nextProps = createFiberFromFragment(null, mode, 0, null)),
+            (nextProps.child = current$$1),
+            0 === (workInProgress.mode & 1) &&
+              (nextProps.child =
+                null !== workInProgress.memoizedState
+                  ? workInProgress.child.child
+                  : workInProgress.child),
+            (mode = nextProps.sibling = createFiberFromFragment(
+              nextDidTimeout,
+              mode,
+              renderExpirationTime,
+              null
+            )),
+            (mode.effectTag |= 2),
+            (renderExpirationTime = nextProps),
+            (nextProps.childExpirationTime = 0),
+            (renderExpirationTime.return = mode.return = workInProgress))
+          : (mode = renderExpirationTime = reconcileChildFibers(
+              workInProgress,
+              current$$1,
+              nextProps.children,
+              renderExpirationTime
+            )));
+  workInProgress.memoizedState = nextState;
+  workInProgress.child = renderExpirationTime;
+  return mode;
 }
 function bailoutOnAlreadyFinishedWork(
   current$$1,
@@ -3692,9 +4175,7 @@ function bailoutOnAlreadyFinishedWork(
 ) {
   null !== current$$1 &&
     (workInProgress.firstContextDependency = current$$1.firstContextDependency);
-  var childExpirationTime = workInProgress.childExpirationTime;
-  if (0 === childExpirationTime || childExpirationTime > renderExpirationTime)
-    return null;
+  if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
     null === current$$1 || workInProgress.child === current$$1.child,
     "Resuming work not yet implemented."
@@ -3723,518 +4204,559 @@ function bailoutOnAlreadyFinishedWork(
   }
   return workInProgress.child;
 }
-function beginWork(current$$1, workInProgress, renderExpirationTime) {
+function beginWork(current$$1, workInProgress, renderExpirationTime$jscomp$0) {
   var updateExpirationTime = workInProgress.expirationTime;
   if (
     null !== current$$1 &&
     current$$1.memoizedProps === workInProgress.pendingProps &&
     !didPerformWorkStackCursor.current &&
-    (0 === updateExpirationTime || updateExpirationTime > renderExpirationTime)
+    updateExpirationTime < renderExpirationTime$jscomp$0
   ) {
     switch (workInProgress.tag) {
-      case 5:
+      case 3:
         pushHostRootContext(workInProgress);
         break;
-      case 7:
+      case 5:
         pushHostContext(workInProgress);
         break;
-      case 2:
+      case 1:
         isContextProvider(workInProgress.type) &&
           pushContextProvider(workInProgress);
         break;
-      case 3:
-        isContextProvider(workInProgress.type._reactResult) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 6:
+      case 4:
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         );
         break;
-      case 12:
+      case 10:
         pushProvider(workInProgress, workInProgress.memoizedProps.value);
+        break;
+      case 13:
+        if (null !== workInProgress.memoizedState) {
+          updateExpirationTime = workInProgress.child.childExpirationTime;
+          if (
+            0 !== updateExpirationTime &&
+            updateExpirationTime >= renderExpirationTime$jscomp$0
+          )
+            return updateSuspenseComponent(
+              current$$1,
+              workInProgress,
+              renderExpirationTime$jscomp$0
+            );
+          workInProgress = bailoutOnAlreadyFinishedWork(
+            current$$1,
+            workInProgress,
+            renderExpirationTime$jscomp$0
+          );
+          return null !== workInProgress ? workInProgress.sibling : null;
+        }
     }
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
-      renderExpirationTime
+      renderExpirationTime$jscomp$0
     );
   }
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
-    case 4:
-      var Component = workInProgress.type;
-      invariant(
-        null === current$$1,
-        "An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue."
+    case 2:
+      updateExpirationTime = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      current$$1 = workInProgress.pendingProps;
+      var context = getMaskedContext(
+        workInProgress,
+        contextStackCursor.current
       );
-      var props = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+      renderExpirationTime = renderExpirationTime$jscomp$0;
+      currentlyRenderingFiber$1 = workInProgress;
+      firstCurrentHook = null;
+      var value = updateExpirationTime(current$$1, context);
+      workInProgress.effectTag |= 1;
       if (
-        "object" === typeof Component &&
-        null !== Component &&
-        "function" === typeof Component.then
+        "object" === typeof value &&
+        null !== value &&
+        "function" === typeof value.render &&
+        void 0 === value.$$typeof
       ) {
-        Component = readLazyComponentType(Component);
-        var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(
+        workInProgress.tag = 1;
+        resetHooks();
+        isContextProvider(updateExpirationTime)
+          ? ((context = !0), pushContextProvider(workInProgress))
+          : (context = !1);
+        workInProgress.memoizedState =
+          null !== value.state && void 0 !== value.state ? value.state : null;
+        var getDerivedStateFromProps =
+          updateExpirationTime.getDerivedStateFromProps;
+        "function" === typeof getDerivedStateFromProps &&
+          applyDerivedStateFromProps(
             workInProgress,
-            Component
-          )),
-          resolvedProps = resolveDefaultProps(Component, props),
-          child = void 0;
-        switch (resolvedTag) {
-          case 1:
-            child = updateFunctionComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 3:
-            child = updateClassComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 14:
-            child = updateForwardRef(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 18:
-            child = updatePureComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              updateExpirationTime,
-              renderExpirationTime
-            );
-            break;
-          default:
-            invariant(
-              !1,
-              "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
-              Component
-            );
-        }
-        workInProgress.memoizedProps = props;
-        workInProgress = child;
-      } else
-        (updateExpirationTime = getMaskedContext(
+            updateExpirationTime,
+            getDerivedStateFromProps,
+            current$$1
+          );
+        value.updater = classComponentUpdater;
+        workInProgress.stateNode = value;
+        value._reactInternalFiber = workInProgress;
+        mountClassInstance(
           workInProgress,
-          contextStackCursor.current
-        )),
-          prepareToReadContext(workInProgress, renderExpirationTime),
-          (updateExpirationTime = Component(props, updateExpirationTime)),
-          (workInProgress.effectTag |= 1),
-          "object" === typeof updateExpirationTime &&
-          null !== updateExpirationTime &&
-          "function" === typeof updateExpirationTime.render &&
-          void 0 === updateExpirationTime.$$typeof
-            ? ((workInProgress.tag = 2),
-              isContextProvider(Component)
-                ? ((resolvedTag = !0), pushContextProvider(workInProgress))
-                : (resolvedTag = !1),
-              (workInProgress.memoizedState =
-                null !== updateExpirationTime.state &&
-                void 0 !== updateExpirationTime.state
-                  ? updateExpirationTime.state
-                  : null),
-              (resolvedProps = Component.getDerivedStateFromProps),
-              "function" === typeof resolvedProps &&
-                applyDerivedStateFromProps(
-                  workInProgress,
-                  Component,
-                  resolvedProps,
-                  props
-                ),
-              (updateExpirationTime.updater = classComponentUpdater),
-              (workInProgress.stateNode = updateExpirationTime),
-              (updateExpirationTime._reactInternalFiber = workInProgress),
-              mountClassInstance(
-                workInProgress,
-                Component,
-                props,
-                renderExpirationTime
-              ),
-              (workInProgress = finishClassComponent(
-                current$$1,
-                workInProgress,
-                Component,
-                !0,
-                resolvedTag,
-                renderExpirationTime
-              )))
-            : ((workInProgress.tag = 0),
-              reconcileChildren(
-                current$$1,
-                workInProgress,
-                updateExpirationTime,
-                renderExpirationTime
-              ),
-              (workInProgress.memoizedProps = props),
-              (workInProgress = workInProgress.child));
+          updateExpirationTime,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        );
+        workInProgress = finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          context,
+          renderExpirationTime$jscomp$0
+        );
+      } else
+        (workInProgress.tag = 0),
+          (value = finishHooks(
+            updateExpirationTime,
+            current$$1,
+            value,
+            context
+          )),
+          reconcileChildren(
+            null,
+            workInProgress,
+            value,
+            renderExpirationTime$jscomp$0
+          ),
+          (workInProgress = workInProgress.child);
       return workInProgress;
+    case 16:
+      value = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      context = workInProgress.pendingProps;
+      current$$1 = readLazyComponentType(value);
+      workInProgress.type = current$$1;
+      value = workInProgress.tag = resolveLazyComponentTag(current$$1);
+      context = resolveDefaultProps(current$$1, context);
+      getDerivedStateFromProps = void 0;
+      switch (value) {
+        case 0:
+          getDerivedStateFromProps = updateFunctionComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 1:
+          getDerivedStateFromProps = updateClassComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 11:
+          getDerivedStateFromProps = updateForwardRef(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 14:
+          getDerivedStateFromProps = updateMemoComponent(
+            null,
+            workInProgress,
+            current$$1,
+            resolveDefaultProps(current$$1.type, context),
+            updateExpirationTime,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        default:
+          invariant(
+            !1,
+            "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
+            current$$1
+          );
+      }
+      return getDerivedStateFromProps;
     case 0:
-      return updateFunctionComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateFunctionComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateFunctionComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
-      );
-    case 2:
-      return updateClassComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 3:
+    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateClassComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateClassComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 5:
+    case 3:
       return (
         pushHostRootContext(workInProgress),
-        (Component = workInProgress.updateQueue),
+        (updateExpirationTime = workInProgress.updateQueue),
         invariant(
-          null !== Component,
+          null !== updateExpirationTime,
           "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
         ),
-        (props = workInProgress.memoizedState),
-        (props = null !== props ? props.element : null),
+        (value = workInProgress.memoizedState),
+        (value = null !== value ? value.element : null),
         processUpdateQueue(
           workInProgress,
-          Component,
+          updateExpirationTime,
           workInProgress.pendingProps,
           null,
-          renderExpirationTime
+          renderExpirationTime$jscomp$0
         ),
-        (Component = workInProgress.memoizedState.element),
-        Component === props
+        (updateExpirationTime = workInProgress.memoizedState.element),
+        updateExpirationTime === value
           ? (workInProgress = bailoutOnAlreadyFinishedWork(
               current$$1,
               workInProgress,
-              renderExpirationTime
+              renderExpirationTime$jscomp$0
             ))
           : (reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
             (workInProgress = workInProgress.child)),
         workInProgress
       );
-    case 7:
+    case 5:
       return (
         pushHostContext(workInProgress),
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
+        (updateExpirationTime = workInProgress.pendingProps.children),
         markRef(current$$1, workInProgress),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         (workInProgress = workInProgress.child),
         workInProgress
       );
-    case 8:
+    case 6:
       return (
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (workInProgress.memoizedProps = workInProgress.pendingProps),
         null
       );
-    case 16:
-      return null;
-    case 6:
+    case 13:
+      return updateSuspenseComponent(
+        current$$1,
+        workInProgress,
+        renderExpirationTime$jscomp$0
+      );
+    case 4:
       return (
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         ),
-        (Component = workInProgress.pendingProps),
+        (updateExpirationTime = workInProgress.pendingProps),
         null === current$$1
           ? (workInProgress.child = reconcileChildFibers(
               workInProgress,
               null,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ))
           : reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 13:
-      return updateForwardRef(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 14:
+    case 11:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateForwardRef(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateForwardRef(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 9:
+    case 7:
       return (
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 10:
+    case 8:
       return (
-        (Component = workInProgress.pendingProps.children),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 15:
+    case 12:
       return (
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component.children,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 12:
+    case 10:
       a: {
-        Component = workInProgress.type._context;
-        props = workInProgress.pendingProps;
-        resolvedTag = workInProgress.memoizedProps;
-        updateExpirationTime = props.value;
-        workInProgress.memoizedProps = props;
-        pushProvider(workInProgress, updateExpirationTime);
-        if (null !== resolvedTag)
-          if (
-            ((resolvedProps = resolvedTag.value),
-            (updateExpirationTime =
-              (resolvedProps === updateExpirationTime &&
-                (0 !== resolvedProps ||
-                  1 / resolvedProps === 1 / updateExpirationTime)) ||
-              (resolvedProps !== resolvedProps &&
-                updateExpirationTime !== updateExpirationTime)
-                ? 0
-                : ("function" === typeof Component._calculateChangedBits
-                    ? Component._calculateChangedBits(
-                        resolvedProps,
-                        updateExpirationTime
-                      )
-                    : 1073741823) | 0),
-            0 === updateExpirationTime)
-          ) {
+        updateExpirationTime = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        getDerivedStateFromProps = workInProgress.memoizedProps;
+        context = value.value;
+        pushProvider(workInProgress, context);
+        if (null !== getDerivedStateFromProps) {
+          var oldValue = getDerivedStateFromProps.value;
+          context =
+            (oldValue === context &&
+              (0 !== oldValue || 1 / oldValue === 1 / context)) ||
+            (oldValue !== oldValue && context !== context)
+              ? 0
+              : ("function" ===
+                typeof updateExpirationTime._calculateChangedBits
+                  ? updateExpirationTime._calculateChangedBits(
+                      oldValue,
+                      context
+                    )
+                  : 1073741823) | 0;
+          if (0 === context) {
             if (
-              resolvedTag.children === props.children &&
+              getDerivedStateFromProps.children === value.children &&
               !didPerformWorkStackCursor.current
             ) {
               workInProgress = bailoutOnAlreadyFinishedWork(
                 current$$1,
                 workInProgress,
-                renderExpirationTime
+                renderExpirationTime$jscomp$0
               );
               break a;
             }
           } else
             for (
-              resolvedTag = workInProgress.child,
-                null !== resolvedTag && (resolvedTag.return = workInProgress);
-              null !== resolvedTag;
+              getDerivedStateFromProps = workInProgress.child,
+                null !== getDerivedStateFromProps &&
+                  (getDerivedStateFromProps.return = workInProgress);
+              null !== getDerivedStateFromProps;
 
             ) {
-              resolvedProps = resolvedTag.firstContextDependency;
-              if (null !== resolvedProps) {
+              oldValue = getDerivedStateFromProps.firstContextDependency;
+              if (null !== oldValue) {
                 do {
                   if (
-                    resolvedProps.context === Component &&
-                    0 !== (resolvedProps.observedBits & updateExpirationTime)
+                    oldValue.context === updateExpirationTime &&
+                    0 !== (oldValue.observedBits & context)
                   ) {
-                    if (2 === resolvedTag.tag || 3 === resolvedTag.tag)
-                      (child = createUpdate(renderExpirationTime)),
-                        (child.tag = 2),
-                        enqueueUpdate(resolvedTag, child);
-                    if (
-                      0 === resolvedTag.expirationTime ||
-                      resolvedTag.expirationTime > renderExpirationTime
-                    )
-                      resolvedTag.expirationTime = renderExpirationTime;
-                    child = resolvedTag.alternate;
-                    null !== child &&
-                      (0 === child.expirationTime ||
-                        child.expirationTime > renderExpirationTime) &&
-                      (child.expirationTime = renderExpirationTime);
-                    for (var node = resolvedTag.return; null !== node; ) {
-                      child = node.alternate;
+                    if (1 === getDerivedStateFromProps.tag) {
+                      var nextFiber = createUpdate(
+                        renderExpirationTime$jscomp$0
+                      );
+                      nextFiber.tag = 2;
+                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
+                    }
+                    getDerivedStateFromProps.expirationTime <
+                      renderExpirationTime$jscomp$0 &&
+                      (getDerivedStateFromProps.expirationTime = renderExpirationTime$jscomp$0);
+                    nextFiber = getDerivedStateFromProps.alternate;
+                    null !== nextFiber &&
+                      nextFiber.expirationTime <
+                        renderExpirationTime$jscomp$0 &&
+                      (nextFiber.expirationTime = renderExpirationTime$jscomp$0);
+                    for (
+                      var node = getDerivedStateFromProps.return;
+                      null !== node;
+
+                    ) {
+                      nextFiber = node.alternate;
                       if (
-                        0 === node.childExpirationTime ||
-                        node.childExpirationTime > renderExpirationTime
+                        node.childExpirationTime < renderExpirationTime$jscomp$0
                       )
-                        (node.childExpirationTime = renderExpirationTime),
-                          null !== child &&
-                            (0 === child.childExpirationTime ||
-                              child.childExpirationTime >
-                                renderExpirationTime) &&
-                            (child.childExpirationTime = renderExpirationTime);
+                        (node.childExpirationTime = renderExpirationTime$jscomp$0),
+                          null !== nextFiber &&
+                            nextFiber.childExpirationTime <
+                              renderExpirationTime$jscomp$0 &&
+                            (nextFiber.childExpirationTime = renderExpirationTime$jscomp$0);
                       else if (
-                        null !== child &&
-                        (0 === child.childExpirationTime ||
-                          child.childExpirationTime > renderExpirationTime)
+                        null !== nextFiber &&
+                        nextFiber.childExpirationTime <
+                          renderExpirationTime$jscomp$0
                       )
-                        child.childExpirationTime = renderExpirationTime;
+                        nextFiber.childExpirationTime = renderExpirationTime$jscomp$0;
                       else break;
                       node = node.return;
                     }
                   }
-                  child = resolvedTag.child;
-                  resolvedProps = resolvedProps.next;
-                } while (null !== resolvedProps);
+                  nextFiber = getDerivedStateFromProps.child;
+                  oldValue = oldValue.next;
+                } while (null !== oldValue);
               } else
-                child =
-                  12 === resolvedTag.tag
-                    ? resolvedTag.type === workInProgress.type
+                nextFiber =
+                  10 === getDerivedStateFromProps.tag
+                    ? getDerivedStateFromProps.type === workInProgress.type
                       ? null
-                      : resolvedTag.child
-                    : resolvedTag.child;
-              if (null !== child) child.return = resolvedTag;
+                      : getDerivedStateFromProps.child
+                    : getDerivedStateFromProps.child;
+              if (null !== nextFiber)
+                nextFiber.return = getDerivedStateFromProps;
               else
-                for (child = resolvedTag; null !== child; ) {
-                  if (child === workInProgress) {
-                    child = null;
+                for (
+                  nextFiber = getDerivedStateFromProps;
+                  null !== nextFiber;
+
+                ) {
+                  if (nextFiber === workInProgress) {
+                    nextFiber = null;
                     break;
                   }
-                  resolvedTag = child.sibling;
-                  if (null !== resolvedTag) {
-                    resolvedTag.return = child.return;
-                    child = resolvedTag;
+                  getDerivedStateFromProps = nextFiber.sibling;
+                  if (null !== getDerivedStateFromProps) {
+                    getDerivedStateFromProps.return = nextFiber.return;
+                    nextFiber = getDerivedStateFromProps;
                     break;
                   }
-                  child = child.return;
+                  nextFiber = nextFiber.return;
                 }
-              resolvedTag = child;
+              getDerivedStateFromProps = nextFiber;
             }
+        }
         reconcileChildren(
           current$$1,
           workInProgress,
-          props.children,
-          renderExpirationTime
+          value.children,
+          renderExpirationTime$jscomp$0
         );
         workInProgress = workInProgress.child;
       }
       return workInProgress;
-    case 11:
+    case 9:
       return (
-        (updateExpirationTime = workInProgress.type),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
-        prepareToReadContext(workInProgress, renderExpirationTime),
-        (updateExpirationTime = readContext(
-          updateExpirationTime,
-          Component.unstable_observedBits
-        )),
-        (props = props(updateExpirationTime)),
+        (value = workInProgress.type),
+        (context = workInProgress.pendingProps),
+        (updateExpirationTime = context.children),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        (value = readContext(value, context.unstable_observedBits)),
+        (updateExpirationTime = updateExpirationTime(value)),
         (workInProgress.effectTag |= 1),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 17:
-      return updatePureComponent(
+    case 14:
+      return (
+        (value = workInProgress.type),
+        (context = resolveDefaultProps(
+          value.type,
+          workInProgress.pendingProps
+        )),
+        updateMemoComponent(
+          current$$1,
+          workInProgress,
+          value,
+          context,
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
         current$$1,
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
         updateExpirationTime,
-        renderExpirationTime
+        renderExpirationTime$jscomp$0
       );
-    case 18:
+    case 17:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updatePureComponent(
-          current$$1,
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        null !== current$$1 &&
+          ((current$$1.alternate = null),
+          (workInProgress.alternate = null),
+          (workInProgress.effectTag |= 2)),
+        (workInProgress.tag = 1),
+        isContextProvider(updateExpirationTime)
+          ? ((current$$1 = !0), pushContextProvider(workInProgress))
+          : (current$$1 = !1),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        constructClassInstance(
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
           updateExpirationTime,
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        mountClassInstance(
+          workInProgress,
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        )
       );
     default:
       invariant(
@@ -4243,9 +4765,27 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
-var updateHostContainer = void 0,
+var appendAllChildren = void 0,
+  updateHostContainer = void 0,
   updateHostComponent$1 = void 0,
   updateHostText$1 = void 0;
+appendAllChildren = function(parent, workInProgress) {
+  for (var node = workInProgress.child; null !== node; ) {
+    if (5 === node.tag || 6 === node.tag) parent._children.push(node.stateNode);
+    else if (4 !== node.tag && null !== node.child) {
+      node.child.return = node;
+      node = node.child;
+      continue;
+    }
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+};
 updateHostContainer = function() {};
 updateHostComponent$1 = function(current, workInProgress, type, newProps) {
   current.memoizedProps !== newProps &&
@@ -4291,7 +4831,7 @@ function logError(boundary, errorInfo) {
     willRetry: !1
   };
   null !== boundary &&
-    2 === boundary.tag &&
+    1 === boundary.tag &&
     ((errorInfo.errorBoundary = boundary.stateNode),
     (errorInfo.errorBoundaryName = getComponentName(boundary.type)),
     (errorInfo.errorBoundaryFound = !0),
@@ -4315,32 +4855,75 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
-function commitUnmount(current$$1) {
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if (0 !== (effect.tag & unmountTag)) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      0 !== (effect.tag & mountTag) &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function commitUnmount(current$$1$jscomp$0) {
   "function" === typeof onCommitFiberUnmount &&
-    onCommitFiberUnmount(current$$1);
-  switch (current$$1.tag) {
-    case 2:
-    case 3:
-      safelyDetachRef(current$$1);
-      var instance = current$$1.stateNode;
-      if ("function" === typeof instance.componentWillUnmount)
+    onCommitFiberUnmount(current$$1$jscomp$0);
+  switch (current$$1$jscomp$0.tag) {
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      var updateQueue = current$$1$jscomp$0.updateQueue;
+      if (
+        null !== updateQueue &&
+        ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
+      ) {
+        var effect = (updateQueue = updateQueue.next);
+        do {
+          var destroy = effect.destroy;
+          if (null !== destroy) {
+            var current$$1 = current$$1$jscomp$0;
+            try {
+              destroy();
+            } catch (error) {
+              captureCommitPhaseError(current$$1, error);
+            }
+          }
+          effect = effect.next;
+        } while (effect !== updateQueue);
+      }
+      break;
+    case 1:
+      safelyDetachRef(current$$1$jscomp$0);
+      updateQueue = current$$1$jscomp$0.stateNode;
+      if ("function" === typeof updateQueue.componentWillUnmount)
         try {
-          (instance.props = current$$1.memoizedProps),
-            (instance.state = current$$1.memoizedState),
-            instance.componentWillUnmount();
+          (updateQueue.props = current$$1$jscomp$0.memoizedProps),
+            (updateQueue.state = current$$1$jscomp$0.memoizedState),
+            updateQueue.componentWillUnmount();
         } catch (unmountError) {
-          captureCommitPhaseError(current$$1, unmountError);
+          captureCommitPhaseError(current$$1$jscomp$0, unmountError);
         }
       break;
-    case 7:
-      safelyDetachRef(current$$1);
+    case 5:
+      safelyDetachRef(current$$1$jscomp$0);
       break;
-    case 6:
-      unmountHostComponents(current$$1);
+    case 4:
+      unmountHostComponents(current$$1$jscomp$0);
   }
 }
 function isHostParent(fiber) {
-  return 7 === fiber.tag || 5 === fiber.tag || 6 === fiber.tag;
+  return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
 }
 function commitPlacement(finishedWork) {
   a: {
@@ -4359,15 +4942,15 @@ function commitPlacement(finishedWork) {
   }
   var isContainer = (parent = void 0);
   switch (parentFiber.tag) {
-    case 7:
+    case 5:
       parent = parentFiber.stateNode;
       isContainer = !1;
       break;
-    case 5:
+    case 3:
       parent = parentFiber.stateNode.containerInfo;
       isContainer = !0;
       break;
-    case 6:
+    case 4:
       parent = parentFiber.stateNode.containerInfo;
       isContainer = !0;
       break;
@@ -4389,11 +4972,11 @@ function commitPlacement(finishedWork) {
     parentFiber.sibling.return = parentFiber.return;
     for (
       parentFiber = parentFiber.sibling;
-      7 !== parentFiber.tag && 8 !== parentFiber.tag;
+      5 !== parentFiber.tag && 6 !== parentFiber.tag;
 
     ) {
       if (parentFiber.effectTag & 2) continue b;
-      if (null === parentFiber.child || 6 === parentFiber.tag) continue b;
+      if (null === parentFiber.child || 4 === parentFiber.tag) continue b;
       else
         (parentFiber.child.return = parentFiber),
           (parentFiber = parentFiber.child);
@@ -4404,7 +4987,7 @@ function commitPlacement(finishedWork) {
     }
   }
   for (var node = finishedWork; ; ) {
-    if (7 === node.tag || 8 === node.tag)
+    if (5 === node.tag || 6 === node.tag)
       if (parentFiber)
         if (isContainer)
           invariant(
@@ -4473,7 +5056,7 @@ function commitPlacement(finishedWork) {
                   [index.length - 1],
                   []
                 )));
-    else if (6 !== node.tag && null !== node.child) {
+    else if (4 !== node.tag && null !== node.child) {
       node.child.return = node;
       node = node.child;
       continue;
@@ -4504,15 +5087,15 @@ function unmountHostComponents(current$$1) {
           "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
         );
         switch (currentParentIsValid.tag) {
-          case 7:
+          case 5:
             currentParent = currentParentIsValid.stateNode;
             currentParentIsContainer = !1;
             break a;
-          case 5:
+          case 3:
             currentParent = currentParentIsValid.stateNode.containerInfo;
             currentParentIsContainer = !0;
             break a;
-          case 6:
+          case 4:
             currentParent = currentParentIsValid.stateNode.containerInfo;
             currentParentIsContainer = !0;
             break a;
@@ -4521,11 +5104,11 @@ function unmountHostComponents(current$$1) {
       }
       currentParentIsValid = !0;
     }
-    if (7 === node.tag || 8 === node.tag) {
+    if (5 === node.tag || 6 === node.tag) {
       a: for (var root = node, node$jscomp$0 = root; ; )
         if (
           (commitUnmount(node$jscomp$0),
-          null !== node$jscomp$0.child && 6 !== node$jscomp$0.tag)
+          null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag)
         )
           (node$jscomp$0.child.return = node$jscomp$0),
             (node$jscomp$0 = node$jscomp$0.child);
@@ -4553,7 +5136,7 @@ function unmountHostComponents(current$$1) {
         UIManager.manageChildren(root._nativeTag, [], [], [], [], [child]);
       }
     } else if (
-      (6 === node.tag
+      (4 === node.tag
         ? ((currentParent = node.stateNode.containerInfo),
           (currentParentIsContainer = !0))
         : commitUnmount(node),
@@ -4567,7 +5150,7 @@ function unmountHostComponents(current$$1) {
     for (; null === node.sibling; ) {
       if (null === node.return || node.return === current$$1) return;
       node = node.return;
-      6 === node.tag && (currentParentIsValid = !1);
+      4 === node.tag && (currentParentIsValid = !1);
     }
     node.sibling.return = node.return;
     node = node.sibling;
@@ -4575,10 +5158,15 @@ function unmountHostComponents(current$$1) {
 }
 function commitWork(current$$1, finishedWork) {
   switch (finishedWork.tag) {
-    case 2:
-    case 3:
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      commitHookEffectList(4, 8, finishedWork);
       break;
-    case 7:
+    case 1:
+      break;
+    case 5:
       var instance = finishedWork.stateNode;
       if (null != instance) {
         var newProps = finishedWork.memoizedProps;
@@ -4602,7 +5190,7 @@ function commitWork(current$$1, finishedWork) {
             ));
       }
       break;
-    case 8:
+    case 6:
       invariant(
         null !== finishedWork.stateNode,
         "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
@@ -4611,11 +5199,78 @@ function commitWork(current$$1, finishedWork) {
         text: finishedWork.memoizedProps
       });
       break;
-    case 5:
+    case 3:
       break;
-    case 15:
+    case 12:
       break;
-    case 16:
+    case 13:
+      newProps = finishedWork.memoizedState;
+      current$$1 = finishedWork;
+      null === newProps
+        ? (instance = !1)
+        : ((instance = !0),
+          (current$$1 = finishedWork.child),
+          0 === newProps.timedOutAt &&
+            (newProps.timedOutAt = requestCurrentTime()));
+      if (null !== current$$1)
+        a: for (newProps = finishedWork = current$$1; ; ) {
+          if (5 === newProps.tag)
+            if (((current$$1 = newProps.stateNode), instance)) {
+              updatePayload = current$$1.viewConfig;
+              var updatePayload$jscomp$0 = diffProperties(
+                null,
+                emptyObject,
+                { style: { display: "none" } },
+                updatePayload.validAttributes
+              );
+              UIManager.updateView(
+                current$$1._nativeTag,
+                updatePayload.uiViewClassName,
+                updatePayload$jscomp$0
+              );
+            } else {
+              current$$1 = newProps.stateNode;
+              updatePayload$jscomp$0 = newProps.memoizedProps;
+              updatePayload = current$$1.viewConfig;
+              var prevProps = Object.assign({}, updatePayload$jscomp$0, {
+                style: [updatePayload$jscomp$0.style, { display: "none" }]
+              });
+              updatePayload$jscomp$0 = diffProperties(
+                null,
+                prevProps,
+                updatePayload$jscomp$0,
+                updatePayload.validAttributes
+              );
+              UIManager.updateView(
+                current$$1._nativeTag,
+                updatePayload.uiViewClassName,
+                updatePayload$jscomp$0
+              );
+            }
+          else {
+            if (6 === newProps.tag) throw Error("Not yet implemented.");
+            if (13 === newProps.tag && null !== newProps.memoizedState) {
+              current$$1 = newProps.child.sibling;
+              current$$1.return = newProps;
+              newProps = current$$1;
+              continue;
+            } else if (null !== newProps.child) {
+              newProps.child.return = newProps;
+              newProps = newProps.child;
+              continue;
+            }
+          }
+          if (newProps === finishedWork) break a;
+          for (; null === newProps.sibling; ) {
+            if (null === newProps.return || newProps.return === finishedWork)
+              break a;
+            newProps = newProps.return;
+          }
+          newProps.sibling.return = newProps.return;
+          newProps = newProps.sibling;
+        }
+      break;
+    case 17:
       break;
     default:
       invariant(
@@ -4664,24 +5319,14 @@ function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
 }
 function unwindWork(workInProgress) {
   switch (workInProgress.tag) {
-    case 2:
+    case 1:
       isContextProvider(workInProgress.type) && popContext(workInProgress);
       var effectTag = workInProgress.effectTag;
-      return effectTag & 1024
-        ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+      return effectTag & 2048
+        ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
           workInProgress)
         : null;
     case 3:
-      return (
-        isContextProvider(workInProgress.type._reactResult) &&
-          popContext(workInProgress),
-        (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
-            workInProgress)
-          : null
-      );
-    case 5:
       return (
         popHostContainer(workInProgress),
         popTopLevelContextObject(workInProgress),
@@ -4690,36 +5335,117 @@ function unwindWork(workInProgress) {
           0 === (effectTag & 64),
           "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
         ),
-        (workInProgress.effectTag = (effectTag & -1025) | 64),
+        (workInProgress.effectTag = (effectTag & -2049) | 64),
         workInProgress
       );
-    case 7:
+    case 5:
       return popHostContext(workInProgress), null;
-    case 16:
+    case 13:
       return (
         (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+        effectTag & 2048
+          ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
             workInProgress)
           : null
       );
-    case 6:
+    case 4:
       return popHostContainer(workInProgress), null;
-    case 12:
+    case 10:
       return popProvider(workInProgress), null;
     default:
       return null;
   }
 }
-var Dispatcher = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [callback];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, inputs];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, inputs) {
+      useEffectImpl(516, 192, create, inputs);
+    },
+    useImperativeMethods: function(ref, create, inputs) {
+      inputs =
+        null !== inputs && void 0 !== inputs
+          ? inputs.concat([ref])
+          : [ref, create];
+      useEffectImpl(
+        4,
+        36,
+        function() {
+          if ("function" === typeof ref) {
+            var _inst = create();
+            ref(_inst);
+            return function() {
+              return ref(null);
+            };
+          }
+          if (null !== ref && void 0 !== ref)
+            return (
+              (_inst = create()),
+              (ref.current = _inst),
+              function() {
+                ref.current = null;
+              }
+            );
+        },
+        inputs
+      );
+    },
+    useLayoutEffect: function(create, inputs) {
+      useEffectImpl(4, 36, create, inputs);
+    },
+    useMemo: function(nextCreate, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [nextCreate];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      nextCreate = nextCreate();
+      workInProgressHook.memoizedState = [nextCreate, inputs];
+      return nextCreate;
+    },
+    useMutationEffect: function(create, inputs) {
+      useEffectImpl(260, 10, create, inputs);
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
   isWorking = !1,
   nextUnitOfWork = null,
   nextRoot = null,
   nextRenderExpirationTime = 0,
+  nextLatestAbsoluteTimeoutMs = -1,
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
+  passiveEffectCallbackHandle = null,
+  passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
 function resetStack() {
   if (null !== nextUnitOfWork)
@@ -4730,7 +5456,7 @@ function resetStack() {
     ) {
       var interruptedWork$jscomp$0 = interruptedWork;
       switch (interruptedWork$jscomp$0.tag) {
-        case 2:
+        case 1:
           var childContextTypes =
             interruptedWork$jscomp$0.type.childContextTypes;
           null !== childContextTypes &&
@@ -4738,231 +5464,249 @@ function resetStack() {
             popContext(interruptedWork$jscomp$0);
           break;
         case 3:
-          childContextTypes =
-            interruptedWork$jscomp$0.type._reactResult.childContextTypes;
-          null !== childContextTypes &&
-            void 0 !== childContextTypes &&
-            popContext(interruptedWork$jscomp$0);
-          break;
-        case 5:
           popHostContainer(interruptedWork$jscomp$0);
           popTopLevelContextObject(interruptedWork$jscomp$0);
           break;
-        case 7:
+        case 5:
           popHostContext(interruptedWork$jscomp$0);
           break;
-        case 6:
+        case 4:
           popHostContainer(interruptedWork$jscomp$0);
           break;
-        case 12:
+        case 10:
           popProvider(interruptedWork$jscomp$0);
       }
       interruptedWork = interruptedWork.return;
     }
   nextRoot = null;
   nextRenderExpirationTime = 0;
+  nextLatestAbsoluteTimeoutMs = -1;
   nextRenderDidError = !1;
   nextUnitOfWork = null;
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(128, 0, finishedWork);
+        commitHookEffectList(0, 64, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
+function flushPassiveEffects() {
+  null !== passiveEffectCallback &&
+    (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
+    passiveEffectCallback());
+}
 function completeUnitOfWork(workInProgress) {
   for (;;) {
     var current$$1 = workInProgress.alternate,
       returnFiber = workInProgress.return,
       siblingFiber = workInProgress.sibling;
-    if (0 === (workInProgress.effectTag & 512)) {
-      var current = current$$1;
-      current$$1 = workInProgress;
-      var newProps = current$$1.pendingProps;
-      switch (current$$1.tag) {
-        case 0:
-        case 1:
-          break;
-        case 2:
-          isContextProvider(current$$1.type) && popContext(current$$1);
-          break;
-        case 3:
-          isContextProvider(current$$1.type._reactResult) &&
-            popContext(current$$1);
-          break;
-        case 5:
-          popHostContainer(current$$1);
-          popTopLevelContextObject(current$$1);
-          newProps = current$$1.stateNode;
-          newProps.pendingContext &&
-            ((newProps.context = newProps.pendingContext),
-            (newProps.pendingContext = null));
-          if (null === current || null === current.child)
-            current$$1.effectTag &= -3;
-          updateHostContainer(current$$1);
-          break;
-        case 7:
-          popHostContext(current$$1);
-          var rootContainerInstance = requiredContext(
+    if (0 === (workInProgress.effectTag & 1024)) {
+      nextUnitOfWork = workInProgress;
+      a: {
+        var current = current$$1;
+        current$$1 = workInProgress;
+        var renderExpirationTime = nextRenderExpirationTime,
+          newProps = current$$1.pendingProps;
+        switch (current$$1.tag) {
+          case 2:
+            break;
+          case 16:
+            break;
+          case 15:
+          case 0:
+            break;
+          case 1:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          case 3:
+            popHostContainer(current$$1);
+            popTopLevelContextObject(current$$1);
+            newProps = current$$1.stateNode;
+            newProps.pendingContext &&
+              ((newProps.context = newProps.pendingContext),
+              (newProps.pendingContext = null));
+            if (null === current || null === current.child)
+              current$$1.effectTag &= -3;
+            updateHostContainer(current$$1);
+            break;
+          case 5:
+            popHostContext(current$$1);
+            renderExpirationTime = requiredContext(
               rootInstanceStackCursor.current
-            ),
-            type = current$$1.type;
-          if (null !== current && null != current$$1.stateNode)
-            updateHostComponent$1(
-              current,
-              current$$1,
-              type,
-              newProps,
-              rootContainerInstance
-            ),
-              current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
-          else if (newProps) {
-            current = requiredContext(contextStackCursor$1.current);
-            var internalInstanceHandle = current$$1,
-              tag = allocateTag(),
-              viewConfig = ReactNativeViewConfigRegistry.get(type);
-            invariant(
-              "RCTView" !== type || !current.isInAParentText,
-              "Nesting of <View> within <Text> is not currently supported."
-            );
-            var updatePayload = diffProperties(
-              null,
-              emptyObject,
-              newProps,
-              viewConfig.validAttributes
-            );
-            UIManager.createView(
-              tag,
-              viewConfig.uiViewClassName,
-              rootContainerInstance,
-              updatePayload
-            );
-            viewConfig = new ReactNativeFiberHostComponent(tag, viewConfig);
-            instanceCache[tag] = internalInstanceHandle;
-            instanceProps[tag] = newProps;
-            a: for (
-              internalInstanceHandle = viewConfig,
-                tag = current$$1,
-                updatePayload = tag.child;
-              null !== updatePayload;
-
-            ) {
-              if (7 === updatePayload.tag || 8 === updatePayload.tag)
-                internalInstanceHandle._children.push(updatePayload.stateNode);
-              else if (
-                6 !== updatePayload.tag &&
-                null !== updatePayload.child
-              ) {
-                updatePayload.child.return = updatePayload;
-                updatePayload = updatePayload.child;
-                continue;
-              }
-              if (updatePayload === tag) break;
-              for (; null === updatePayload.sibling; ) {
-                if (
-                  null === updatePayload.return ||
-                  updatePayload.return === tag
-                )
-                  break a;
-                updatePayload = updatePayload.return;
-              }
-              updatePayload.sibling.return = updatePayload.return;
-              updatePayload = updatePayload.sibling;
-            }
-            finalizeInitialChildren(
-              viewConfig,
-              type,
-              newProps,
-              rootContainerInstance,
-              current
-            ) && (current$$1.effectTag |= 4);
-            current$$1.stateNode = viewConfig;
-            null !== current$$1.ref && (current$$1.effectTag |= 128);
-          } else
-            invariant(
-              null !== current$$1.stateNode,
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
             );
-          break;
-        case 8:
-          current && null != current$$1.stateNode
-            ? updateHostText$1(
+            var type = current$$1.type;
+            if (null !== current && null != current$$1.stateNode)
+              updateHostComponent$1(
                 current,
                 current$$1,
-                current.memoizedProps,
-                newProps
-              )
-            : ("string" !== typeof newProps &&
+                type,
+                newProps,
+                renderExpirationTime
+              ),
+                current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
+            else if (newProps) {
+              current = requiredContext(contextStackCursor$1.current);
+              var internalInstanceHandle = current$$1,
+                tag = allocateTag(),
+                viewConfig = ReactNativeViewConfigRegistry.get(type);
+              invariant(
+                "RCTView" !== type || !current.isInAParentText,
+                "Nesting of <View> within <Text> is not currently supported."
+              );
+              var updatePayload = diffProperties(
+                null,
+                emptyObject,
+                newProps,
+                viewConfig.validAttributes
+              );
+              UIManager.createView(
+                tag,
+                viewConfig.uiViewClassName,
+                renderExpirationTime,
+                updatePayload
+              );
+              viewConfig = new ReactNativeFiberHostComponent(tag, viewConfig);
+              instanceCache[tag] = internalInstanceHandle;
+              instanceProps[tag] = newProps;
+              appendAllChildren(viewConfig, current$$1, !1, !1);
+              finalizeInitialChildren(
+                viewConfig,
+                type,
+                newProps,
+                renderExpirationTime,
+                current
+              ) && (current$$1.effectTag |= 4);
+              current$$1.stateNode = viewConfig;
+              null !== current$$1.ref && (current$$1.effectTag |= 128);
+            } else
+              invariant(
+                null !== current$$1.stateNode,
+                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+              );
+            break;
+          case 6:
+            current && null != current$$1.stateNode
+              ? updateHostText$1(
+                  current,
+                  current$$1,
+                  current.memoizedProps,
+                  newProps
+                )
+              : ("string" !== typeof newProps &&
+                  invariant(
+                    null !== current$$1.stateNode,
+                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                  ),
+                (current = requiredContext(rootInstanceStackCursor.current)),
+                (type = requiredContext(contextStackCursor$1.current)),
+                (renderExpirationTime = current$$1),
                 invariant(
-                  null !== current$$1.stateNode,
-                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                  type.isInAParentText,
+                  "Text strings must be rendered within a <Text> component."
                 ),
-              (current = requiredContext(rootInstanceStackCursor.current)),
-              (type = requiredContext(contextStackCursor$1.current)),
-              (rootContainerInstance = current$$1),
-              invariant(
-                type.isInAParentText,
-                "Text strings must be rendered within a <Text> component."
-              ),
-              (type = allocateTag()),
-              UIManager.createView(type, "RCTRawText", current, {
-                text: newProps
-              }),
-              (instanceCache[type] = current$$1),
-              (rootContainerInstance.stateNode = type));
-          break;
-        case 13:
-        case 14:
-          break;
-        case 16:
-          break;
-        case 9:
-          break;
-        case 10:
-          break;
-        case 15:
-          break;
-        case 6:
-          popHostContainer(current$$1);
-          updateHostContainer(current$$1);
-          break;
-        case 12:
-          popProvider(current$$1);
-          break;
-        case 11:
-          break;
-        case 17:
-        case 18:
-          break;
-        case 4:
-          invariant(
-            !1,
-            "An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue."
-          );
-        default:
-          invariant(
-            !1,
-            "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
-          );
+                (type = allocateTag()),
+                UIManager.createView(type, "RCTRawText", current, {
+                  text: newProps
+                }),
+                (instanceCache[type] = current$$1),
+                (renderExpirationTime.stateNode = type));
+            break;
+          case 11:
+            break;
+          case 13:
+            newProps = current$$1.memoizedState;
+            if (0 !== (current$$1.effectTag & 64)) {
+              current$$1.expirationTime = renderExpirationTime;
+              nextUnitOfWork = current$$1;
+              break a;
+            }
+            newProps = null !== newProps;
+            renderExpirationTime =
+              null !== current && null !== current.memoizedState;
+            null !== current &&
+              !newProps &&
+              renderExpirationTime &&
+              ((type = current.child.sibling),
+              null !== type &&
+                ((current = current$$1.firstEffect),
+                null !== current
+                  ? ((current$$1.firstEffect = type),
+                    (type.nextEffect = current))
+                  : ((current$$1.firstEffect = current$$1.lastEffect = type),
+                    (type.nextEffect = null)),
+                (type.effectTag = 8)));
+            if (
+              newProps !== renderExpirationTime ||
+              (0 === (current$$1.effectTag & 1) && newProps)
+            )
+              current$$1.effectTag |= 4;
+            break;
+          case 7:
+            break;
+          case 8:
+            break;
+          case 12:
+            break;
+          case 4:
+            popHostContainer(current$$1);
+            updateHostContainer(current$$1);
+            break;
+          case 10:
+            popProvider(current$$1);
+            break;
+          case 9:
+            break;
+          case 14:
+            break;
+          case 17:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          default:
+            invariant(
+              !1,
+              "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
+        nextUnitOfWork = null;
       }
-      nextUnitOfWork = null;
       current$$1 = workInProgress;
       if (
-        1073741823 === nextRenderExpirationTime ||
-        1073741823 !== current$$1.childExpirationTime
+        1 === nextRenderExpirationTime ||
+        1 !== current$$1.childExpirationTime
       ) {
         newProps = 0;
         for (
-          rootContainerInstance = current$$1.child;
-          null !== rootContainerInstance;
+          renderExpirationTime = current$$1.child;
+          null !== renderExpirationTime;
 
-        ) {
-          type = rootContainerInstance.expirationTime;
-          current = rootContainerInstance.childExpirationTime;
-          if (0 === newProps || (0 !== type && type < newProps))
-            newProps = type;
-          if (0 === newProps || (0 !== current && current < newProps))
-            newProps = current;
-          rootContainerInstance = rootContainerInstance.sibling;
-        }
+        )
+          (type = renderExpirationTime.expirationTime),
+            (current = renderExpirationTime.childExpirationTime),
+            type > newProps && (newProps = type),
+            current > newProps && (newProps = current),
+            (renderExpirationTime = renderExpirationTime.sibling);
         current$$1.childExpirationTime = newProps;
       }
+      if (null !== nextUnitOfWork) return nextUnitOfWork;
       null !== returnFiber &&
-        0 === (returnFiber.effectTag & 512) &&
+        0 === (returnFiber.effectTag & 1024) &&
         (null === returnFiber.firstEffect &&
           (returnFiber.firstEffect = workInProgress.firstEffect),
         null !== workInProgress.lastEffect &&
@@ -4977,10 +5721,10 @@ function completeUnitOfWork(workInProgress) {
     } else {
       workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
       if (null !== workInProgress)
-        return (workInProgress.effectTag &= 511), workInProgress;
+        return (workInProgress.effectTag &= 1023), workInProgress;
       null !== returnFiber &&
         ((returnFiber.firstEffect = returnFiber.lastEffect = null),
-        (returnFiber.effectTag |= 512));
+        (returnFiber.effectTag |= 1024));
     }
     if (null !== siblingFiber) return siblingFiber;
     if (null !== returnFiber) workInProgress = returnFiber;
@@ -4994,43 +5738,49 @@ function performUnitOfWork(workInProgress) {
     workInProgress,
     nextRenderExpirationTime
   );
+  workInProgress.memoizedProps = workInProgress.pendingProps;
   null === next && (next = completeUnitOfWork(workInProgress));
   ReactCurrentOwner$2.current = null;
   return next;
 }
-function renderRoot(root, isYieldy, isExpired) {
+function renderRoot(root$jscomp$0, isYieldy) {
   invariant(
     !isWorking,
     "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
+  flushPassiveEffects();
   isWorking = !0;
   ReactCurrentOwner$2.currentDispatcher = Dispatcher;
-  var expirationTime = root.nextExpirationTimeToWorkOn;
+  var expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn;
   if (
     expirationTime !== nextRenderExpirationTime ||
-    root !== nextRoot ||
+    root$jscomp$0 !== nextRoot ||
     null === nextUnitOfWork
   )
     resetStack(),
-      (nextRoot = root),
+      (nextRoot = root$jscomp$0),
       (nextRenderExpirationTime = expirationTime),
       (nextUnitOfWork = createWorkInProgress(
         nextRoot.current,
         null,
         nextRenderExpirationTime
       )),
-      (root.pendingCommitExpirationTime = 0);
+      (root$jscomp$0.pendingCommitExpirationTime = 0);
   var didFatal = !1;
   do {
     try {
       if (isYieldy)
-        for (; null !== nextUnitOfWork && !shouldYield(); )
+        for (; null !== nextUnitOfWork && !shouldYieldToRenderer(); )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
       else
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (null === nextUnitOfWork)
+      if (
+        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
+        resetHooks(),
+        null === nextUnitOfWork)
+      )
         (didFatal = !0), onUncaughtError(thrownValue);
       else {
         invariant(
@@ -5042,54 +5792,141 @@ function renderRoot(root, isYieldy, isExpired) {
         if (null === returnFiber) (didFatal = !0), onUncaughtError(thrownValue);
         else {
           a: {
-            var returnFiber$jscomp$0 = returnFiber,
+            var root = root$jscomp$0,
+              returnFiber$jscomp$0 = returnFiber,
               sourceFiber$jscomp$0 = sourceFiber,
               value = thrownValue;
             returnFiber = nextRenderExpirationTime;
-            sourceFiber$jscomp$0.effectTag |= 512;
+            sourceFiber$jscomp$0.effectTag |= 1024;
             sourceFiber$jscomp$0.firstEffect = sourceFiber$jscomp$0.lastEffect = null;
+            if (
+              null !== value &&
+              "object" === typeof value &&
+              "function" === typeof value.then
+            ) {
+              var thenable = value;
+              value = returnFiber$jscomp$0;
+              var earliestTimeoutMs = -1,
+                startTimeMs = -1;
+              do {
+                if (13 === value.tag) {
+                  var current$$1 = value.alternate;
+                  if (
+                    null !== current$$1 &&
+                    ((current$$1 = current$$1.memoizedState),
+                    null !== current$$1)
+                  ) {
+                    startTimeMs = 10 * (1073741822 - current$$1.timedOutAt);
+                    break;
+                  }
+                  current$$1 = value.pendingProps.maxDuration;
+                  if ("number" === typeof current$$1)
+                    if (0 >= current$$1) earliestTimeoutMs = 0;
+                    else if (
+                      -1 === earliestTimeoutMs ||
+                      current$$1 < earliestTimeoutMs
+                    )
+                      earliestTimeoutMs = current$$1;
+                }
+                value = value.return;
+              } while (null !== value);
+              value = returnFiber$jscomp$0;
+              do {
+                if ((current$$1 = 13 === value.tag))
+                  current$$1 =
+                    void 0 === value.memoizedProps.fallback
+                      ? !1
+                      : null === value.memoizedState;
+                if (current$$1) {
+                  returnFiber$jscomp$0 = retrySuspendedRoot.bind(
+                    null,
+                    root,
+                    value,
+                    sourceFiber$jscomp$0,
+                    0 === (value.mode & 1) ? 1073741823 : returnFiber
+                  );
+                  thenable.then(returnFiber$jscomp$0, returnFiber$jscomp$0);
+                  if (0 === (value.mode & 1)) {
+                    value.effectTag |= 64;
+                    sourceFiber$jscomp$0.effectTag &= -1957;
+                    1 === sourceFiber$jscomp$0.tag &&
+                      null === sourceFiber$jscomp$0.alternate &&
+                      (sourceFiber$jscomp$0.tag = 17);
+                    sourceFiber$jscomp$0.expirationTime = returnFiber;
+                    break a;
+                  }
+                  -1 === earliestTimeoutMs
+                    ? (root = 1073741823)
+                    : (-1 === startTimeMs &&
+                        (startTimeMs =
+                          10 *
+                            (1073741822 -
+                              findEarliestOutstandingPriorityLevel(
+                                root,
+                                returnFiber
+                              )) -
+                          5e3),
+                      (root = startTimeMs + earliestTimeoutMs));
+                  0 <= root &&
+                    nextLatestAbsoluteTimeoutMs < root &&
+                    (nextLatestAbsoluteTimeoutMs = root);
+                  value.effectTag |= 2048;
+                  value.expirationTime = returnFiber;
+                  break a;
+                }
+                value = value.return;
+              } while (null !== value);
+              value = Error(
+                (getComponentName(sourceFiber$jscomp$0.type) ||
+                  "A React component") +
+                  " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
+                  getStackByFiberInDevAndProd(sourceFiber$jscomp$0)
+              );
+            }
             nextRenderDidError = !0;
             value = createCapturedValue(value, sourceFiber$jscomp$0);
+            root = returnFiber$jscomp$0;
             do {
-              switch (returnFiber$jscomp$0.tag) {
-                case 5:
-                  returnFiber$jscomp$0.effectTag |= 1024;
-                  returnFiber$jscomp$0.expirationTime = returnFiber;
+              switch (root.tag) {
+                case 3:
+                  sourceFiber$jscomp$0 = value;
+                  root.effectTag |= 2048;
+                  root.expirationTime = returnFiber;
                   returnFiber = createRootErrorUpdate(
-                    returnFiber$jscomp$0,
-                    value,
+                    root,
+                    sourceFiber$jscomp$0,
                     returnFiber
                   );
-                  enqueueCapturedUpdate(returnFiber$jscomp$0, returnFiber);
+                  enqueueCapturedUpdate(root, returnFiber);
                   break a;
-                case 2:
-                case 3:
-                  sourceFiber$jscomp$0 = value;
-                  var ctor = returnFiber$jscomp$0.type,
-                    instance = returnFiber$jscomp$0.stateNode;
+                case 1:
                   if (
-                    0 === (returnFiber$jscomp$0.effectTag & 64) &&
-                    ("function" === typeof ctor.getDerivedStateFromError ||
-                      (null !== instance &&
-                        "function" === typeof instance.componentDidCatch &&
-                        (null === legacyErrorBoundariesThatAlreadyFailed ||
-                          !legacyErrorBoundariesThatAlreadyFailed.has(
-                            instance
-                          ))))
+                    ((sourceFiber$jscomp$0 = value),
+                    (returnFiber$jscomp$0 = root.type),
+                    (thenable = root.stateNode),
+                    0 === (root.effectTag & 64) &&
+                      ("function" ===
+                        typeof returnFiber$jscomp$0.getDerivedStateFromError ||
+                        (null !== thenable &&
+                          "function" === typeof thenable.componentDidCatch &&
+                          (null === legacyErrorBoundariesThatAlreadyFailed ||
+                            !legacyErrorBoundariesThatAlreadyFailed.has(
+                              thenable
+                            )))))
                   ) {
-                    returnFiber$jscomp$0.effectTag |= 1024;
-                    returnFiber$jscomp$0.expirationTime = returnFiber;
+                    root.effectTag |= 2048;
+                    root.expirationTime = returnFiber;
                     returnFiber = createClassErrorUpdate(
-                      returnFiber$jscomp$0,
+                      root,
                       sourceFiber$jscomp$0,
                       returnFiber
                     );
-                    enqueueCapturedUpdate(returnFiber$jscomp$0, returnFiber);
+                    enqueueCapturedUpdate(root, returnFiber);
                     break a;
                   }
               }
-              returnFiber$jscomp$0 = returnFiber$jscomp$0.return;
-            } while (null !== returnFiber$jscomp$0);
+              root = root.return;
+            } while (null !== root);
           }
           nextUnitOfWork = completeUnitOfWork(sourceFiber);
           continue;
@@ -5100,197 +5937,193 @@ function renderRoot(root, isYieldy, isExpired) {
   } while (1);
   isWorking = !1;
   lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
-  if (didFatal) (nextRoot = null), (root.finishedWork = null);
-  else if (null !== nextUnitOfWork) root.finishedWork = null;
+  resetHooks();
+  if (didFatal) (nextRoot = null), (root$jscomp$0.finishedWork = null);
+  else if (null !== nextUnitOfWork) root$jscomp$0.finishedWork = null;
   else {
-    isYieldy = root.current.alternate;
+    didFatal = root$jscomp$0.current.alternate;
     invariant(
-      null !== isYieldy,
+      null !== didFatal,
       "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue."
     );
     nextRoot = null;
     if (nextRenderDidError) {
-      didFatal = root.latestPendingTime;
-      sourceFiber = root.latestSuspendedTime;
-      returnFiber = root.latestPingedTime;
+      sourceFiber = root$jscomp$0.latestPendingTime;
+      returnFiber = root$jscomp$0.latestSuspendedTime;
+      root = root$jscomp$0.latestPingedTime;
       if (
-        (0 !== didFatal && didFatal > expirationTime) ||
-        (0 !== sourceFiber && sourceFiber > expirationTime) ||
-        (0 !== returnFiber && returnFiber > expirationTime)
+        (0 !== sourceFiber && sourceFiber < expirationTime) ||
+        (0 !== returnFiber && returnFiber < expirationTime) ||
+        (0 !== root && root < expirationTime)
       ) {
-        root.didError = !1;
-        isExpired = root.latestPingedTime;
-        0 !== isExpired &&
-          isExpired <= expirationTime &&
-          (root.latestPingedTime = 0);
-        isExpired = root.earliestPendingTime;
-        isYieldy = root.latestPendingTime;
-        isExpired === expirationTime
-          ? (root.earliestPendingTime =
-              isYieldy === expirationTime
-                ? (root.latestPendingTime = 0)
-                : isYieldy)
-          : isYieldy === expirationTime && (root.latestPendingTime = isExpired);
-        isExpired = root.earliestSuspendedTime;
-        isYieldy = root.latestSuspendedTime;
-        0 === isExpired
-          ? (root.earliestSuspendedTime = root.latestSuspendedTime = expirationTime)
-          : isExpired > expirationTime
-            ? (root.earliestSuspendedTime = expirationTime)
-            : isYieldy < expirationTime &&
-              (root.latestSuspendedTime = expirationTime);
-        findNextExpirationTimeToWorkOn(expirationTime, root);
-        root.expirationTime = root.expirationTime;
+        markSuspendedPriorityLevel(root$jscomp$0, expirationTime);
+        onSuspend(
+          root$jscomp$0,
+          didFatal,
+          expirationTime,
+          root$jscomp$0.expirationTime,
+          -1
+        );
         return;
       }
-      if (!root.didError && !isExpired) {
-        root.didError = !0;
-        root.nextExpirationTimeToWorkOn = expirationTime;
-        root.expirationTime = 1;
+      if (!root$jscomp$0.didError && isYieldy) {
+        root$jscomp$0.didError = !0;
+        expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn = expirationTime;
+        isYieldy = root$jscomp$0.expirationTime = 1073741823;
+        onSuspend(root$jscomp$0, didFatal, expirationTime, isYieldy, -1);
         return;
       }
     }
-    root.pendingCommitExpirationTime = expirationTime;
-    root.finishedWork = isYieldy;
+    isYieldy && -1 !== nextLatestAbsoluteTimeoutMs
+      ? (markSuspendedPriorityLevel(root$jscomp$0, expirationTime),
+        (isYieldy =
+          10 *
+          (1073741822 -
+            findEarliestOutstandingPriorityLevel(
+              root$jscomp$0,
+              expirationTime
+            ))),
+        isYieldy < nextLatestAbsoluteTimeoutMs &&
+          (nextLatestAbsoluteTimeoutMs = isYieldy),
+        (isYieldy = 10 * (1073741822 - requestCurrentTime())),
+        (isYieldy = nextLatestAbsoluteTimeoutMs - isYieldy),
+        onSuspend(
+          root$jscomp$0,
+          didFatal,
+          expirationTime,
+          root$jscomp$0.expirationTime,
+          0 > isYieldy ? 0 : isYieldy
+        ))
+      : ((root$jscomp$0.pendingCommitExpirationTime = expirationTime),
+        (root$jscomp$0.finishedWork = didFatal));
   }
 }
-function captureCommitPhaseError(fiber, error) {
-  var JSCompiler_inline_result;
-  a: {
-    invariant(
-      !isWorking || isCommitting$1,
-      "dispatch: Cannot dispatch during the render phase."
-    );
-    for (
-      JSCompiler_inline_result = fiber.return;
-      null !== JSCompiler_inline_result;
-
-    ) {
-      switch (JSCompiler_inline_result.tag) {
-        case 2:
-        case 3:
-          var instance = JSCompiler_inline_result.stateNode;
-          if (
-            "function" ===
-              typeof JSCompiler_inline_result.type.getDerivedStateFromError ||
-            ("function" === typeof instance.componentDidCatch &&
-              (null === legacyErrorBoundariesThatAlreadyFailed ||
-                !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
-          ) {
-            fiber = createCapturedValue(error, fiber);
-            fiber = createClassErrorUpdate(JSCompiler_inline_result, fiber, 1);
-            enqueueUpdate(JSCompiler_inline_result, fiber);
-            scheduleWork(JSCompiler_inline_result, 1);
-            JSCompiler_inline_result = void 0;
-            break a;
-          }
-          break;
-        case 5:
-          fiber = createCapturedValue(error, fiber);
-          fiber = createRootErrorUpdate(JSCompiler_inline_result, fiber, 1);
-          enqueueUpdate(JSCompiler_inline_result, fiber);
-          scheduleWork(JSCompiler_inline_result, 1);
-          JSCompiler_inline_result = void 0;
-          break a;
-      }
-      JSCompiler_inline_result = JSCompiler_inline_result.return;
+function captureCommitPhaseError(sourceFiber, value) {
+  for (var fiber = sourceFiber.return; null !== fiber; ) {
+    switch (fiber.tag) {
+      case 1:
+        var instance = fiber.stateNode;
+        if (
+          "function" === typeof fiber.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValue(value, sourceFiber);
+          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
+          enqueueUpdate(fiber, sourceFiber);
+          scheduleWork(fiber, 1073741823);
+          return;
+        }
+        break;
+      case 3:
+        sourceFiber = createCapturedValue(value, sourceFiber);
+        sourceFiber = createRootErrorUpdate(fiber, sourceFiber, 1073741823);
+        enqueueUpdate(fiber, sourceFiber);
+        scheduleWork(fiber, 1073741823);
+        return;
     }
-    5 === fiber.tag &&
-      ((JSCompiler_inline_result = createCapturedValue(error, fiber)),
-      (JSCompiler_inline_result = createRootErrorUpdate(
-        fiber,
-        JSCompiler_inline_result,
-        1
-      )),
-      enqueueUpdate(fiber, JSCompiler_inline_result),
-      scheduleWork(fiber, 1));
-    JSCompiler_inline_result = void 0;
+    fiber = fiber.return;
   }
-  return JSCompiler_inline_result;
+  3 === sourceFiber.tag &&
+    ((fiber = createCapturedValue(value, sourceFiber)),
+    (fiber = createRootErrorUpdate(sourceFiber, fiber, 1073741823)),
+    enqueueUpdate(sourceFiber, fiber),
+    scheduleWork(sourceFiber, 1073741823));
 }
 function computeExpirationForFiber(currentTime, fiber) {
   isWorking
-    ? (currentTime = isCommitting$1 ? 1 : nextRenderExpirationTime)
+    ? (currentTime = isCommitting$1 ? 1073741823 : nextRenderExpirationTime)
     : fiber.mode & 1
       ? ((currentTime = isBatchingInteractiveUpdates
-          ? 2 + 10 * ((((currentTime - 2 + 15) / 10) | 0) + 1)
-          : 2 + 25 * ((((currentTime - 2 + 500) / 25) | 0) + 1)),
+          ? 1073741822 - 10 * ((((1073741822 - currentTime + 15) / 10) | 0) + 1)
+          : 1073741822 -
+            25 * ((((1073741822 - currentTime + 500) / 25) | 0) + 1)),
         null !== nextRoot &&
           currentTime === nextRenderExpirationTime &&
-          (currentTime += 1))
-      : (currentTime = 1);
+          --currentTime)
+      : (currentTime = 1073741823);
   isBatchingInteractiveUpdates &&
-    currentTime > lowestPriorityPendingInteractiveExpirationTime &&
+    (0 === lowestPriorityPendingInteractiveExpirationTime ||
+      currentTime < lowestPriorityPendingInteractiveExpirationTime) &&
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
-function scheduleWork(fiber, expirationTime) {
-  if (0 === fiber.expirationTime || fiber.expirationTime > expirationTime)
-    fiber.expirationTime = expirationTime;
+function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
+  var retryTime = root.earliestSuspendedTime;
+  var latestSuspendedTime = root.latestSuspendedTime;
+  if (
+    0 !== retryTime &&
+    suspendedTime <= retryTime &&
+    suspendedTime >= latestSuspendedTime
+  ) {
+    latestSuspendedTime = retryTime = suspendedTime;
+    root.didError = !1;
+    var latestPingedTime = root.latestPingedTime;
+    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
+      root.latestPingedTime = latestSuspendedTime;
+    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
+  } else
+    (retryTime = requestCurrentTime()),
+      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
+      markPendingPriorityLevel(root, retryTime);
+  0 !== (boundaryFiber.mode & 1) &&
+    root === nextRoot &&
+    nextRenderExpirationTime === suspendedTime &&
+    (nextRoot = null);
+  scheduleWorkToRoot(boundaryFiber, retryTime);
+  0 === (boundaryFiber.mode & 1) &&
+    (scheduleWorkToRoot(sourceFiber, retryTime),
+    1 === sourceFiber.tag &&
+      null !== sourceFiber.stateNode &&
+      ((boundaryFiber = createUpdate(retryTime)),
+      (boundaryFiber.tag = 2),
+      enqueueUpdate(sourceFiber, boundaryFiber)));
+  sourceFiber = root.expirationTime;
+  0 !== sourceFiber && requestWork(root, sourceFiber);
+}
+function scheduleWorkToRoot(fiber, expirationTime) {
+  fiber.expirationTime < expirationTime &&
+    (fiber.expirationTime = expirationTime);
   var alternate = fiber.alternate;
   null !== alternate &&
-    (0 === alternate.expirationTime ||
-      alternate.expirationTime > expirationTime) &&
+    alternate.expirationTime < expirationTime &&
     (alternate.expirationTime = expirationTime);
   var node = fiber.return,
     root = null;
-  if (null === node && 5 === fiber.tag) root = fiber.stateNode;
+  if (null === node && 3 === fiber.tag) root = fiber.stateNode;
   else
     for (; null !== node; ) {
       alternate = node.alternate;
-      if (
-        0 === node.childExpirationTime ||
-        node.childExpirationTime > expirationTime
-      )
-        node.childExpirationTime = expirationTime;
+      node.childExpirationTime < expirationTime &&
+        (node.childExpirationTime = expirationTime);
       null !== alternate &&
-        (0 === alternate.childExpirationTime ||
-          alternate.childExpirationTime > expirationTime) &&
+        alternate.childExpirationTime < expirationTime &&
         (alternate.childExpirationTime = expirationTime);
-      if (null === node.return && 5 === node.tag) {
+      if (null === node.return && 3 === node.tag) {
         root = node.stateNode;
         break;
       }
       node = node.return;
     }
-  fiber = null === root ? null : root;
-  if (null !== fiber) {
-    !isWorking &&
+  return root;
+}
+function scheduleWork(fiber, expirationTime) {
+  fiber = scheduleWorkToRoot(fiber, expirationTime);
+  null !== fiber &&
+    (!isWorking &&
       0 !== nextRenderExpirationTime &&
-      expirationTime < nextRenderExpirationTime &&
-      resetStack();
-    markPendingPriorityLevel(fiber, expirationTime);
-    if (!isWorking || isCommitting$1 || nextRoot !== fiber) {
-      expirationTime = fiber.expirationTime;
-      if (null === fiber.nextScheduledRoot)
-        (fiber.expirationTime = expirationTime),
-          null === lastScheduledRoot
-            ? ((firstScheduledRoot = lastScheduledRoot = fiber),
-              (fiber.nextScheduledRoot = fiber))
-            : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = fiber),
-              (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot));
-      else if (
-        ((alternate = fiber.expirationTime),
-        0 === alternate || expirationTime < alternate)
-      )
-        fiber.expirationTime = expirationTime;
-      isRendering ||
-        (isBatchingUpdates
-          ? isUnbatchingUpdates &&
-            ((nextFlushedRoot = fiber),
-            (nextFlushedExpirationTime = 1),
-            performWorkOnRoot(fiber, 1, !0))
-          : 1 === expirationTime
-            ? performWork(1, null)
-            : scheduleCallbackWithExpirationTime(fiber, expirationTime));
-    }
+      expirationTime > nextRenderExpirationTime &&
+      resetStack(),
+    markPendingPriorityLevel(fiber, expirationTime),
+    (isWorking && !isCommitting$1 && nextRoot === fiber) ||
+      requestWork(fiber, fiber.expirationTime),
     nestedUpdateCount > NESTED_UPDATE_LIMIT &&
       ((nestedUpdateCount = 0),
       invariant(
         !1,
         "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-      ));
-  }
+      )));
 }
 var firstScheduledRoot = null,
   lastScheduledRoot = null,
@@ -5300,27 +6133,25 @@ var firstScheduledRoot = null,
   nextFlushedRoot = null,
   nextFlushedExpirationTime = 0,
   lowestPriorityPendingInteractiveExpirationTime = 0,
-  deadlineDidExpire = !1,
   hasUnhandledError = !1,
   unhandledError = null,
-  deadline = null,
   isBatchingUpdates = !1,
   isUnbatchingUpdates = !1,
   isBatchingInteractiveUpdates = !1,
   completedBatches = null,
   originalStartTimeMs = now$1(),
-  currentRendererTime = ((originalStartTimeMs / 10) | 0) + 2,
+  currentRendererTime = 1073741822 - ((originalStartTimeMs / 10) | 0),
   currentSchedulerTime = currentRendererTime,
   NESTED_UPDATE_LIMIT = 50,
   nestedUpdateCount = 0,
-  lastCommittedRootDuringThisBatch = null,
-  timeHeuristicForUnitOfWork = 1;
+  lastCommittedRootDuringThisBatch = null;
 function recomputeCurrentRendererTime() {
-  currentRendererTime = (((now$1() - originalStartTimeMs) / 10) | 0) + 2;
+  currentRendererTime =
+    1073741822 - (((now$1() - originalStartTimeMs) / 10) | 0);
 }
 function scheduleCallbackWithExpirationTime(root, expirationTime) {
   if (0 !== callbackExpirationTime) {
-    if (expirationTime > callbackExpirationTime) return;
+    if (expirationTime < callbackExpirationTime) return;
     null !== callbackID &&
       ((root = callbackID), (scheduledCallback = null), clearTimeout(root));
   }
@@ -5329,17 +6160,65 @@ function scheduleCallbackWithExpirationTime(root, expirationTime) {
   scheduledCallback = performAsyncWork;
   callbackID = setTimeout(setTimeoutCallback, 1);
 }
+function onSuspend(
+  root,
+  finishedWork,
+  suspendedExpirationTime,
+  rootExpirationTime,
+  msUntilTimeout
+) {
+  root.expirationTime = rootExpirationTime;
+  0 !== msUntilTimeout || shouldYieldToRenderer()
+    ? 0 < msUntilTimeout &&
+      (root.timeoutHandle = scheduleTimeout(
+        onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
+        msUntilTimeout
+      ))
+    : ((root.pendingCommitExpirationTime = suspendedExpirationTime),
+      (root.finishedWork = finishedWork));
+}
+function onTimeout(root, finishedWork, suspendedExpirationTime) {
+  root.pendingCommitExpirationTime = suspendedExpirationTime;
+  root.finishedWork = finishedWork;
+  recomputeCurrentRendererTime();
+  currentSchedulerTime = currentRendererTime;
+  invariant(
+    !isRendering,
+    "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method."
+  );
+  nextFlushedRoot = root;
+  nextFlushedExpirationTime = suspendedExpirationTime;
+  performWorkOnRoot(root, suspendedExpirationTime, !1);
+  performWork(1073741823, !1);
+}
 function requestCurrentTime() {
   if (isRendering) return currentSchedulerTime;
   findHighestPriorityRoot();
-  if (
-    0 === nextFlushedExpirationTime ||
-    1073741823 === nextFlushedExpirationTime
-  )
+  if (0 === nextFlushedExpirationTime || 1 === nextFlushedExpirationTime)
     recomputeCurrentRendererTime(),
       (currentSchedulerTime = currentRendererTime);
   return currentSchedulerTime;
 }
+function requestWork(root, expirationTime) {
+  null === root.nextScheduledRoot
+    ? ((root.expirationTime = expirationTime),
+      null === lastScheduledRoot
+        ? ((firstScheduledRoot = lastScheduledRoot = root),
+          (root.nextScheduledRoot = root))
+        : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root),
+          (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot)))
+    : expirationTime > root.expirationTime &&
+      (root.expirationTime = expirationTime);
+  isRendering ||
+    (isBatchingUpdates
+      ? isUnbatchingUpdates &&
+        ((nextFlushedRoot = root),
+        (nextFlushedExpirationTime = 1073741823),
+        performWorkOnRoot(root, 1073741823, !1))
+      : 1073741823 === expirationTime
+        ? performWork(1073741823, !1)
+        : scheduleCallbackWithExpirationTime(root, expirationTime));
+}
 function findHighestPriorityRoot() {
   var highestPriorityWork = 0,
     highestPriorityRoot = null;
@@ -5373,14 +6252,11 @@ function findHighestPriorityRoot() {
             (root.nextScheduledRoot = null);
         root = previousScheduledRoot.nextScheduledRoot;
       } else {
-        if (
-          0 === highestPriorityWork ||
-          remainingExpirationTime < highestPriorityWork
-        )
-          (highestPriorityWork = remainingExpirationTime),
-            (highestPriorityRoot = root);
+        remainingExpirationTime > highestPriorityWork &&
+          ((highestPriorityWork = remainingExpirationTime),
+          (highestPriorityRoot = root));
         if (root === lastScheduledRoot) break;
-        if (1 === highestPriorityWork) break;
+        if (1073741823 === highestPriorityWork) break;
         previousScheduledRoot = root;
         root = root.nextScheduledRoot;
       }
@@ -5388,38 +6264,44 @@ function findHighestPriorityRoot() {
   nextFlushedRoot = highestPriorityRoot;
   nextFlushedExpirationTime = highestPriorityWork;
 }
-function performAsyncWork(dl) {
-  if (dl.didTimeout && null !== firstScheduledRoot) {
-    recomputeCurrentRendererTime();
-    var root = firstScheduledRoot;
-    do {
-      var expirationTime = root.expirationTime;
-      0 !== expirationTime &&
-        currentRendererTime >= expirationTime &&
-        (root.nextExpirationTimeToWorkOn = currentRendererTime);
-      root = root.nextScheduledRoot;
-    } while (root !== firstScheduledRoot);
+var didYield = !1;
+function shouldYieldToRenderer() {
+  return didYield ? !0 : frameDeadline <= now$1() ? (didYield = !0) : !1;
+}
+function performAsyncWork() {
+  try {
+    if (!shouldYieldToRenderer() && null !== firstScheduledRoot) {
+      recomputeCurrentRendererTime();
+      var root = firstScheduledRoot;
+      do {
+        var expirationTime = root.expirationTime;
+        0 !== expirationTime &&
+          currentRendererTime <= expirationTime &&
+          (root.nextExpirationTimeToWorkOn = currentRendererTime);
+        root = root.nextScheduledRoot;
+      } while (root !== firstScheduledRoot);
+    }
+    performWork(0, !0);
+  } finally {
+    didYield = !1;
   }
-  performWork(0, dl);
 }
-function performWork(minExpirationTime, dl) {
-  deadline = dl;
+function performWork(minExpirationTime, isYieldy) {
   findHighestPriorityRoot();
-  if (null !== deadline)
+  if (isYieldy)
     for (
       recomputeCurrentRendererTime(),
         currentSchedulerTime = currentRendererTime;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime) &&
-      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime &&
+      !(didYield && currentRendererTime > nextFlushedExpirationTime);
 
     )
       performWorkOnRoot(
         nextFlushedRoot,
         nextFlushedExpirationTime,
-        currentRendererTime >= nextFlushedExpirationTime
+        currentRendererTime > nextFlushedExpirationTime
       ),
         findHighestPriorityRoot(),
         recomputeCurrentRendererTime(),
@@ -5429,29 +6311,28 @@ function performWork(minExpirationTime, dl) {
       ;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime;
 
     )
-      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !0),
+      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !1),
         findHighestPriorityRoot();
-  null !== deadline && ((callbackExpirationTime = 0), (callbackID = null));
+  isYieldy && ((callbackExpirationTime = 0), (callbackID = null));
   0 !== nextFlushedExpirationTime &&
     scheduleCallbackWithExpirationTime(
       nextFlushedRoot,
       nextFlushedExpirationTime
     );
-  deadline = null;
-  deadlineDidExpire = !1;
   nestedUpdateCount = 0;
   lastCommittedRootDuringThisBatch = null;
   if (null !== completedBatches)
     for (
-      minExpirationTime = completedBatches, completedBatches = null, dl = 0;
-      dl < minExpirationTime.length;
-      dl++
+      minExpirationTime = completedBatches,
+        completedBatches = null,
+        isYieldy = 0;
+      isYieldy < minExpirationTime.length;
+      isYieldy++
     ) {
-      var batch = minExpirationTime[dl];
+      var batch = minExpirationTime[isYieldy];
       try {
         batch._onComplete();
       } catch (error) {
@@ -5465,39 +6346,45 @@ function performWork(minExpirationTime, dl) {
     (hasUnhandledError = !1),
     minExpirationTime);
 }
-function performWorkOnRoot(root, expirationTime, isExpired) {
+function performWorkOnRoot(root, expirationTime, isYieldy) {
   invariant(
     !isRendering,
     "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
   isRendering = !0;
-  if (null === deadline || isExpired) {
-    var finishedWork = root.finishedWork;
-    null !== finishedWork
-      ? completeRoot(root, finishedWork, expirationTime)
+  if (isYieldy) {
+    var _finishedWork = root.finishedWork;
+    null !== _finishedWork
+      ? completeRoot(root, _finishedWork, expirationTime)
       : ((root.finishedWork = null),
-        renderRoot(root, !1, isExpired),
-        (finishedWork = root.finishedWork),
-        null !== finishedWork &&
-          completeRoot(root, finishedWork, expirationTime));
+        (_finishedWork = root.timeoutHandle),
+        -1 !== _finishedWork &&
+          ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+        renderRoot(root, isYieldy),
+        (_finishedWork = root.finishedWork),
+        null !== _finishedWork &&
+          (shouldYieldToRenderer()
+            ? (root.finishedWork = _finishedWork)
+            : completeRoot(root, _finishedWork, expirationTime)));
   } else
-    (finishedWork = root.finishedWork),
-      null !== finishedWork
-        ? completeRoot(root, finishedWork, expirationTime)
+    (_finishedWork = root.finishedWork),
+      null !== _finishedWork
+        ? completeRoot(root, _finishedWork, expirationTime)
         : ((root.finishedWork = null),
-          renderRoot(root, !0, isExpired),
-          (finishedWork = root.finishedWork),
-          null !== finishedWork &&
-            (shouldYield()
-              ? (root.finishedWork = finishedWork)
-              : completeRoot(root, finishedWork, expirationTime)));
+          (_finishedWork = root.timeoutHandle),
+          -1 !== _finishedWork &&
+            ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+          renderRoot(root, isYieldy),
+          (_finishedWork = root.finishedWork),
+          null !== _finishedWork &&
+            completeRoot(root, _finishedWork, expirationTime));
   isRendering = !1;
 }
 function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
   var firstBatch = root.firstBatch;
   if (
     null !== firstBatch &&
-    firstBatch._expirationTime <= expirationTime &&
+    firstBatch._expirationTime >= expirationTime &&
     (null === completedBatches
       ? (completedBatches = [firstBatch])
       : completedBatches.push(firstBatch),
@@ -5526,9 +6413,7 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
   var childExpirationTimeBeforeCommit =
     finishedWork$jscomp$0.childExpirationTime;
   firstBatch =
-    0 === firstBatch ||
-    (0 !== childExpirationTimeBeforeCommit &&
-      childExpirationTimeBeforeCommit < firstBatch)
+    childExpirationTimeBeforeCommit > firstBatch
       ? childExpirationTimeBeforeCommit
       : firstBatch;
   root.didError = !1;
@@ -5540,19 +6425,19 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
       (root.latestPingedTime = 0))
     : ((childExpirationTimeBeforeCommit = root.latestPendingTime),
       0 !== childExpirationTimeBeforeCommit &&
-        (childExpirationTimeBeforeCommit < firstBatch
+        (childExpirationTimeBeforeCommit > firstBatch
           ? (root.earliestPendingTime = root.latestPendingTime = 0)
-          : root.earliestPendingTime < firstBatch &&
+          : root.earliestPendingTime > firstBatch &&
             (root.earliestPendingTime = root.latestPendingTime)),
       (childExpirationTimeBeforeCommit = root.earliestSuspendedTime),
       0 === childExpirationTimeBeforeCommit
         ? markPendingPriorityLevel(root, firstBatch)
-        : firstBatch > root.latestSuspendedTime
+        : firstBatch < root.latestSuspendedTime
           ? ((root.earliestSuspendedTime = 0),
             (root.latestSuspendedTime = 0),
             (root.latestPingedTime = 0),
             markPendingPriorityLevel(root, firstBatch))
-          : firstBatch < childExpirationTimeBeforeCommit &&
+          : firstBatch > childExpirationTimeBeforeCommit &&
             markPendingPriorityLevel(root, firstBatch));
   findNextExpirationTimeToWorkOn(0, root);
   ReactCurrentOwner$2.current = null;
@@ -5567,30 +6452,35 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
     var error = void 0;
     try {
       for (; null !== nextEffect; ) {
-        if (nextEffect.effectTag & 256) {
-          var current$$1 = nextEffect.alternate;
+        if (nextEffect.effectTag & 256)
           a: {
-            var finishedWork = nextEffect;
+            var current$$1 = nextEffect.alternate,
+              finishedWork = nextEffect;
             switch (finishedWork.tag) {
-              case 2:
-              case 3:
+              case 0:
+              case 11:
+              case 15:
+                commitHookEffectList(2, 0, finishedWork);
+                break a;
+              case 1:
                 if (finishedWork.effectTag & 256 && null !== current$$1) {
                   var prevProps = current$$1.memoizedProps,
                     prevState = current$$1.memoizedState,
-                    instance = finishedWork.stateNode;
-                  instance.props = finishedWork.memoizedProps;
-                  instance.state = finishedWork.memoizedState;
-                  var snapshot = instance.getSnapshotBeforeUpdate(
-                    prevProps,
-                    prevState
-                  );
+                    instance = finishedWork.stateNode,
+                    snapshot = instance.getSnapshotBeforeUpdate(
+                      finishedWork.elementType === finishedWork.type
+                        ? prevProps
+                        : resolveDefaultProps(finishedWork.type, prevProps),
+                      prevState
+                    );
                   instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                 }
                 break a;
+              case 3:
               case 5:
-              case 7:
-              case 8:
               case 6:
+              case 4:
+              case 17:
                 break a;
               default:
                 invariant(
@@ -5599,7 +6489,6 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
                 );
             }
           }
-        }
         nextEffect = nextEffect.nextEffect;
       }
     } catch (e) {
@@ -5669,73 +6558,76 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
     effectTag = !1;
     current$$1$jscomp$0 = void 0;
     try {
-      for (currentRef = expirationTime; null !== nextEffect; ) {
+      for (
+        currentRef = root, current$$1 = expirationTime;
+        null !== nextEffect;
+
+      ) {
         var effectTag$jscomp$0 = nextEffect.effectTag;
         if (effectTag$jscomp$0 & 36) {
           var current$$1$jscomp$1 = nextEffect.alternate;
-          current$$1 = nextEffect;
-          prevProps = currentRef;
-          switch (current$$1.tag) {
-            case 2:
-            case 3:
-              var instance$jscomp$0 = current$$1.stateNode;
-              if (current$$1.effectTag & 4)
+          prevProps = nextEffect;
+          prevState = current$$1;
+          switch (prevProps.tag) {
+            case 0:
+            case 11:
+            case 15:
+              commitHookEffectList(16, 32, prevProps);
+              break;
+            case 1:
+              var instance$jscomp$0 = prevProps.stateNode;
+              if (prevProps.effectTag & 4)
                 if (null === current$$1$jscomp$1)
-                  (instance$jscomp$0.props = current$$1.memoizedProps),
-                    (instance$jscomp$0.state = current$$1.memoizedState),
-                    instance$jscomp$0.componentDidMount();
+                  instance$jscomp$0.componentDidMount();
                 else {
-                  var prevProps$jscomp$0 = current$$1$jscomp$1.memoizedProps,
-                    prevState$jscomp$0 = current$$1$jscomp$1.memoizedState;
-                  instance$jscomp$0.props = current$$1.memoizedProps;
-                  instance$jscomp$0.state = current$$1.memoizedState;
+                  var prevProps$jscomp$0 =
+                    prevProps.elementType === prevProps.type
+                      ? current$$1$jscomp$1.memoizedProps
+                      : resolveDefaultProps(
+                          prevProps.type,
+                          current$$1$jscomp$1.memoizedProps
+                        );
                   instance$jscomp$0.componentDidUpdate(
                     prevProps$jscomp$0,
-                    prevState$jscomp$0,
+                    current$$1$jscomp$1.memoizedState,
                     instance$jscomp$0.__reactInternalSnapshotBeforeUpdate
                   );
                 }
-              var updateQueue = current$$1.updateQueue;
+              var updateQueue = prevProps.updateQueue;
               null !== updateQueue &&
-                ((instance$jscomp$0.props = current$$1.memoizedProps),
-                (instance$jscomp$0.state = current$$1.memoizedState),
                 commitUpdateQueue(
-                  current$$1,
+                  prevProps,
                   updateQueue,
                   instance$jscomp$0,
-                  prevProps
-                ));
+                  prevState
+                );
               break;
-            case 5:
-              var _updateQueue = current$$1.updateQueue;
+            case 3:
+              var _updateQueue = prevProps.updateQueue;
               if (null !== _updateQueue) {
-                prevState = null;
-                if (null !== current$$1.child)
-                  switch (current$$1.child.tag) {
-                    case 7:
-                      prevState = current$$1.child.stateNode;
+                instance = null;
+                if (null !== prevProps.child)
+                  switch (prevProps.child.tag) {
+                    case 5:
+                      instance = prevProps.child.stateNode;
                       break;
-                    case 2:
-                    case 3:
-                      prevState = current$$1.child.stateNode;
+                    case 1:
+                      instance = prevProps.child.stateNode;
                   }
-                commitUpdateQueue(
-                  current$$1,
-                  _updateQueue,
-                  prevState,
-                  prevProps
-                );
+                commitUpdateQueue(prevProps, _updateQueue, instance, prevState);
               }
               break;
-            case 7:
-              break;
-            case 8:
+            case 5:
               break;
             case 6:
               break;
-            case 15:
+            case 4:
+              break;
+            case 12:
+              break;
+            case 13:
               break;
-            case 16:
+            case 17:
               break;
             default:
               invariant(
@@ -5749,7 +6641,7 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
           if (null !== ref) {
             var instance$jscomp$1 = nextEffect.stateNode;
             switch (nextEffect.tag) {
-              case 7:
+              case 5:
                 var instanceToUse = instance$jscomp$1;
                 break;
               default:
@@ -5760,9 +6652,9 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
               : (ref.current = instanceToUse);
           }
         }
-        var next = nextEffect.nextEffect;
-        nextEffect.nextEffect = null;
-        nextEffect = next;
+        effectTag$jscomp$0 & 512 &&
+          (rootWithPendingPassiveEffects = currentRef);
+        nextEffect = nextEffect.nextEffect;
       }
     } catch (e) {
       (effectTag = !0), (current$$1$jscomp$0 = e);
@@ -5775,14 +6667,20 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
       captureCommitPhaseError(nextEffect, current$$1$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== firstBatch &&
+    null !== rootWithPendingPassiveEffects &&
+    ((effectTag$jscomp$0 = commitPassiveEffects.bind(null, root, firstBatch)),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      effectTag$jscomp$0
+    )),
+    (passiveEffectCallback = effectTag$jscomp$0));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork$jscomp$0.stateNode);
   effectTag$jscomp$0 = finishedWork$jscomp$0.expirationTime;
   finishedWork$jscomp$0 = finishedWork$jscomp$0.childExpirationTime;
   finishedWork$jscomp$0 =
-    0 === effectTag$jscomp$0 ||
-    (0 !== finishedWork$jscomp$0 && finishedWork$jscomp$0 < effectTag$jscomp$0)
+    finishedWork$jscomp$0 > effectTag$jscomp$0
       ? finishedWork$jscomp$0
       : effectTag$jscomp$0;
   0 === finishedWork$jscomp$0 &&
@@ -5790,13 +6688,6 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
   root.expirationTime = finishedWork$jscomp$0;
   root.finishedWork = null;
 }
-function shouldYield() {
-  return deadlineDidExpire
-    ? !0
-    : null === deadline || deadline.timeRemaining() > timeHeuristicForUnitOfWork
-      ? !1
-      : (deadlineDidExpire = !0);
-}
 function onUncaughtError(error) {
   invariant(
     null !== nextFlushedRoot,
@@ -5805,55 +6696,6 @@ function onUncaughtError(error) {
   nextFlushedRoot.expirationTime = 0;
   hasUnhandledError || ((hasUnhandledError = !0), (unhandledError = error));
 }
-function getContextForSubtree(parentComponent) {
-  if (!parentComponent) return emptyContextObject;
-  parentComponent = parentComponent._reactInternalFiber;
-  a: {
-    invariant(
-      2 === isFiberMountedImpl(parentComponent) &&
-        (2 === parentComponent.tag || 3 === parentComponent.tag),
-      "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-    );
-    var parentContext = parentComponent;
-    do {
-      switch (parentContext.tag) {
-        case 5:
-          parentContext = parentContext.stateNode.context;
-          break a;
-        case 2:
-          if (isContextProvider(parentContext.type)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-          break;
-        case 3:
-          if (isContextProvider(parentContext.type._reactResult)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-      }
-      parentContext = parentContext.return;
-    } while (null !== parentContext);
-    invariant(
-      !1,
-      "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-    );
-    parentContext = void 0;
-  }
-  if (2 === parentComponent.tag) {
-    var Component = parentComponent.type;
-    if (isContextProvider(Component))
-      return processChildContext(parentComponent, Component, parentContext);
-  } else if (
-    3 === parentComponent.tag &&
-    ((Component = parentComponent.type._reactResult),
-    isContextProvider(Component))
-  )
-    return processChildContext(parentComponent, Component, parentContext);
-  return parentContext;
-}
 function findHostInstance$1(component) {
   var fiber = component._reactInternalFiber;
   void 0 === fiber &&
@@ -5872,7 +6714,48 @@ function updateContainer(element, container, parentComponent, callback) {
     currentTime = requestCurrentTime();
   current$$1 = computeExpirationForFiber(currentTime, current$$1);
   currentTime = container.current;
-  parentComponent = getContextForSubtree(parentComponent);
+  a: if (parentComponent) {
+    parentComponent = parentComponent._reactInternalFiber;
+    b: {
+      invariant(
+        2 === isFiberMountedImpl(parentComponent) && 1 === parentComponent.tag,
+        "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
+      );
+      var parentContext = parentComponent;
+      do {
+        switch (parentContext.tag) {
+          case 3:
+            parentContext = parentContext.stateNode.context;
+            break b;
+          case 1:
+            if (isContextProvider(parentContext.type)) {
+              parentContext =
+                parentContext.stateNode
+                  .__reactInternalMemoizedMergedChildContext;
+              break b;
+            }
+        }
+        parentContext = parentContext.return;
+      } while (null !== parentContext);
+      invariant(
+        !1,
+        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
+      );
+      parentContext = void 0;
+    }
+    if (1 === parentComponent.tag) {
+      var Component = parentComponent.type;
+      if (isContextProvider(Component)) {
+        parentComponent = processChildContext(
+          parentComponent,
+          Component,
+          parentContext
+        );
+        break a;
+      }
+    }
+    parentComponent = parentContext;
+  } else parentComponent = emptyContextObject;
   null === container.context
     ? (container.context = parentComponent)
     : (container.pendingContext = parentComponent);
@@ -5881,6 +6764,7 @@ function updateContainer(element, container, parentComponent, callback) {
   callback.payload = { element: element };
   container = void 0 === container ? null : container;
   null !== container && (callback.callback = container);
+  flushPassiveEffects();
   enqueueUpdate(currentTime, callback);
   scheduleWork(currentTime, current$$1);
   return current$$1;
@@ -5940,13 +6824,13 @@ _batchedUpdatesImpl = function(fn, a) {
   } finally {
     (isBatchingUpdates = previousIsBatchingUpdates) ||
       isRendering ||
-      performWork(1, null);
+      performWork(1073741823, !1);
   }
 };
 _flushInteractiveUpdatesImpl = function() {
   isRendering ||
     0 === lowestPriorityPendingInteractiveExpirationTime ||
-    (performWork(lowestPriorityPendingInteractiveExpirationTime, null),
+    (performWork(lowestPriorityPendingInteractiveExpirationTime, !1),
     (lowestPriorityPendingInteractiveExpirationTime = 0));
 };
 var roots = new Map(),
@@ -6026,7 +6910,7 @@ var roots = new Map(),
     render: function(element, containerTag, callback) {
       var root = roots.get(containerTag);
       if (!root) {
-        root = new FiberNode(5, null, null, 0);
+        root = createFiber(3, null, null, 0);
         var root$jscomp$0 = {
           current: root,
           containerInfo: containerTag,
@@ -6054,7 +6938,7 @@ var roots = new Map(),
       updateContainer(element, root, null, callback);
       a: if (((element = root.current), element.child))
         switch (element.child.tag) {
-          case 7:
+          case 5:
             element = element.child.stateNode;
             break a;
           default:
@@ -6161,7 +7045,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromTag,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.5.2",
+  version: "16.6.1",
   rendererPackageName: "react-native-renderer"
 });
 var ReactNativeRenderer$2 = { default: ReactNativeRenderer },
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-profiling.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-profiling.js
@@ -20,6 +20,7 @@ var ReactNativeViewConfigRegistry = require("ReactNativeViewConfigRegistry"),
   flattenStyle = require("flattenStyle"),
   TextInputState = require("TextInputState"),
   tracing = require("scheduler/tracing"),
+  scheduler = require("scheduler"),
   ExceptionsManager = require("ExceptionsManager");
 function invariant(condition, format, a, b, c, d, e, f) {
   if (!condition) {
@@ -167,10 +168,10 @@ var plugins = [],
   getFiberCurrentPropsFromNode = null,
   getInstanceFromNode = null,
   getNodeFromInstance = null;
-function executeDispatch(event, simulated, listener, inst) {
-  simulated = event.type || "unknown-event";
+function executeDispatch(event, listener, inst) {
+  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
-  invokeGuardedCallbackAndCatchFirstError(simulated, listener, void 0, event);
+  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
@@ -216,10 +217,10 @@ function executeDispatchesAndReleaseTopLevel(e) {
         i < dispatchListeners.length && !e.isPropagationStopped();
         i++
       )
-        executeDispatch(e, !1, dispatchListeners[i], dispatchInstances[i]);
+        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
     else
       dispatchListeners &&
-        executeDispatch(e, !1, dispatchListeners, dispatchInstances);
+        executeDispatch(e, dispatchListeners, dispatchInstances);
     e._dispatchListeners = null;
     e._dispatchInstances = null;
     e.isPersistent() || e.constructor.release(e);
@@ -294,7 +295,7 @@ function getListener(inst, registrationName) {
 }
 function getParent(inst) {
   do inst = inst.return;
-  while (inst && 7 !== inst.tag);
+  while (inst && 5 !== inst.tag);
   return inst ? inst : null;
 }
 function traverseTwoPhase(inst, fn, arg) {
@@ -1147,8 +1148,9 @@ var ReactSharedInternals =
     ? Symbol.for("react.concurrent_mode")
     : 60111,
   REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112,
-  REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for("react.placeholder") : 60113,
-  REACT_PURE_TYPE = hasSymbol ? Symbol.for("react.pure") : 60115,
+  REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
+  REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
+  REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
   MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
@@ -1172,29 +1174,28 @@ function getComponentName(type) {
       return "Profiler";
     case REACT_STRICT_MODE_TYPE:
       return "StrictMode";
-    case REACT_PLACEHOLDER_TYPE:
-      return "Placeholder";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
   }
-  if ("object" === typeof type) {
+  if ("object" === typeof type)
     switch (type.$$typeof) {
       case REACT_CONTEXT_TYPE:
         return "Context.Consumer";
       case REACT_PROVIDER_TYPE:
         return "Context.Provider";
       case REACT_FORWARD_REF_TYPE:
-        var renderFn = type.render;
-        renderFn = renderFn.displayName || renderFn.name || "";
+        var innerType = type.render;
+        innerType = innerType.displayName || innerType.name || "";
         return (
           type.displayName ||
-          ("" !== renderFn ? "ForwardRef(" + renderFn + ")" : "ForwardRef")
+          ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef")
         );
+      case REACT_MEMO_TYPE:
+        return getComponentName(type.type);
+      case REACT_LAZY_TYPE:
+        if ((type = 1 === type._status ? type._result : null))
+          return getComponentName(type);
     }
-    if (
-      "function" === typeof type.then &&
-      (type = 1 === type._reactStatus ? type._reactResult : null)
-    )
-      return getComponentName(type);
-  }
   return null;
 }
 function isFiberMountedImpl(fiber) {
@@ -1205,7 +1206,7 @@ function isFiberMountedImpl(fiber) {
     for (; node.return; )
       if (((node = node.return), 0 !== (node.effectTag & 2))) return 1;
   }
-  return 5 === node.tag ? 2 : 3;
+  return 3 === node.tag ? 2 : 3;
 }
 function assertIsMounted(fiber) {
   invariant(
@@ -1281,14 +1282,14 @@ function findCurrentFiberUsingSlowPath(fiber) {
       "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
     );
   }
-  invariant(5 === a.tag, "Unable to find node on an unmounted component.");
+  invariant(3 === a.tag, "Unable to find node on an unmounted component.");
   return a.stateNode.current === a ? fiber : alternate;
 }
 function findCurrentHostFiber(parent) {
   parent = findCurrentFiberUsingSlowPath(parent);
   if (!parent) return null;
   for (var node = parent; ; ) {
-    if (7 === node.tag || 8 === node.tag) return node;
+    if (5 === node.tag || 6 === node.tag) return node;
     if (node.child) (node.child.return = node), (node = node.child);
     else {
       if (node === parent) break;
@@ -1596,23 +1597,17 @@ var ReactNativeFiberHostComponent = (function() {
           return Date.now();
         },
   scheduledCallback = null,
-  frameDeadline = 0,
-  frameDeadlineObject = {
-    timeRemaining: function() {
-      return frameDeadline - now$1();
-    },
-    didTimeout: !1
-  };
+  frameDeadline = 0;
 function setTimeoutCallback() {
   frameDeadline = now$1() + 5;
   var callback = scheduledCallback;
   scheduledCallback = null;
-  null !== callback && callback(frameDeadlineObject);
+  null !== callback && callback();
 }
 function shim$1() {
   invariant(
     !1,
-    "The current renderer does not support hyration. This error is likely caused by a bug in React. Please file an issue."
+    "The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue."
   );
 }
 var UPDATE_SIGNAL = {},
@@ -1642,18 +1637,19 @@ function finalizeInitialChildren(parentInstance) {
   return !1;
 }
 var scheduleTimeout = setTimeout,
+  cancelTimeout = clearTimeout,
   BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 function getStackByFiberInDevAndProd(workInProgress) {
   var info = "";
   do {
     a: switch (workInProgress.tag) {
-      case 4:
+      case 2:
+      case 16:
       case 0:
       case 1:
-      case 2:
-      case 3:
-      case 7:
-      case 10:
+      case 5:
+      case 8:
+      case 13:
         var owner = workInProgress._debugOwner,
           source = workInProgress._debugSource,
           name = getComponentName(workInProgress.type);
@@ -1805,7 +1801,7 @@ function injectInternals(internals) {
 function FiberNode(tag, pendingProps, key, mode) {
   this.tag = tag;
   this.key = key;
-  this.sibling = this.child = this.return = this.stateNode = this.type = null;
+  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
@@ -1819,29 +1815,33 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.actualStartTime = -1;
   this.treeBaseDuration = this.selfBaseDuration = 0;
 }
+function createFiber(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
 function shouldConstruct(Component) {
   Component = Component.prototype;
   return !(!Component || !Component.isReactComponent);
 }
-function resolveLazyComponentTag(fiber, Component) {
+function resolveLazyComponentTag(Component) {
   if ("function" === typeof Component)
-    return shouldConstruct(Component) ? 3 : 1;
+    return shouldConstruct(Component) ? 1 : 0;
   if (void 0 !== Component && null !== Component) {
-    fiber = Component.$$typeof;
-    if (fiber === REACT_FORWARD_REF_TYPE) return 14;
-    if (fiber === REACT_PURE_TYPE) return 18;
+    Component = Component.$$typeof;
+    if (Component === REACT_FORWARD_REF_TYPE) return 11;
+    if (Component === REACT_MEMO_TYPE) return 14;
   }
-  return 4;
+  return 2;
 }
 function createWorkInProgress(current, pendingProps) {
   var workInProgress = current.alternate;
   null === workInProgress
-    ? ((workInProgress = new FiberNode(
+    ? ((workInProgress = createFiber(
         current.tag,
         pendingProps,
         current.key,
         current.mode
       )),
+      (workInProgress.elementType = current.elementType),
       (workInProgress.type = current.type),
       (workInProgress.stateNode = current.stateNode),
       (workInProgress.alternate = current),
@@ -1867,60 +1867,66 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.treeBaseDuration = current.treeBaseDuration;
   return workInProgress;
 }
-function createFiberFromElement(element, mode, expirationTime) {
-  var type = element.type,
-    key = element.key;
-  element = element.props;
-  var fiberTag = void 0;
-  if ("function" === typeof type) fiberTag = shouldConstruct(type) ? 2 : 4;
-  else if ("string" === typeof type) fiberTag = 7;
+function createFiberFromTypeAndProps(
+  type,
+  key,
+  pendingProps,
+  owner,
+  mode,
+  expirationTime
+) {
+  var fiberTag = 2;
+  owner = type;
+  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
+  else if ("string" === typeof type) fiberTag = 5;
   else
     a: switch (type) {
       case REACT_FRAGMENT_TYPE:
         return createFiberFromFragment(
-          element.children,
+          pendingProps.children,
           mode,
           expirationTime,
           key
         );
       case REACT_CONCURRENT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 3;
-        break;
+        return createFiberFromMode(pendingProps, mode | 3, expirationTime, key);
       case REACT_STRICT_MODE_TYPE:
-        fiberTag = 10;
-        mode |= 2;
-        break;
+        return createFiberFromMode(pendingProps, mode | 2, expirationTime, key);
       case REACT_PROFILER_TYPE:
         return (
-          (type = new FiberNode(15, element, key, mode | 4)),
+          (type = createFiber(12, pendingProps, key, mode | 4)),
+          (type.elementType = REACT_PROFILER_TYPE),
           (type.type = REACT_PROFILER_TYPE),
           (type.expirationTime = expirationTime),
           type
         );
-      case REACT_PLACEHOLDER_TYPE:
-        fiberTag = 16;
-        break;
+      case REACT_SUSPENSE_TYPE:
+        return (
+          (type = createFiber(13, pendingProps, key, mode)),
+          (type.elementType = REACT_SUSPENSE_TYPE),
+          (type.type = REACT_SUSPENSE_TYPE),
+          (type.expirationTime = expirationTime),
+          type
+        );
       default:
         if ("object" === typeof type && null !== type)
           switch (type.$$typeof) {
             case REACT_PROVIDER_TYPE:
-              fiberTag = 12;
+              fiberTag = 10;
               break a;
             case REACT_CONTEXT_TYPE:
-              fiberTag = 11;
+              fiberTag = 9;
               break a;
             case REACT_FORWARD_REF_TYPE:
-              fiberTag = 13;
+              fiberTag = 11;
               break a;
-            case REACT_PURE_TYPE:
-              fiberTag = 17;
+            case REACT_MEMO_TYPE:
+              fiberTag = 14;
+              break a;
+            case REACT_LAZY_TYPE:
+              fiberTag = 16;
+              owner = null;
               break a;
-            default:
-              if ("function" === typeof type.then) {
-                fiberTag = 4;
-                break a;
-              }
           }
         invariant(
           !1,
@@ -1929,24 +1935,33 @@ function createFiberFromElement(element, mode, expirationTime) {
           ""
         );
     }
-  mode = new FiberNode(fiberTag, element, key, mode);
-  mode.type = type;
-  mode.expirationTime = expirationTime;
-  return mode;
+  key = createFiber(fiberTag, pendingProps, key, mode);
+  key.elementType = type;
+  key.type = owner;
+  key.expirationTime = expirationTime;
+  return key;
 }
 function createFiberFromFragment(elements, mode, expirationTime, key) {
-  elements = new FiberNode(9, elements, key, mode);
+  elements = createFiber(7, elements, key, mode);
   elements.expirationTime = expirationTime;
   return elements;
 }
+function createFiberFromMode(pendingProps, mode, expirationTime, key) {
+  pendingProps = createFiber(8, pendingProps, key, mode);
+  mode = 0 === (mode & 1) ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
+  pendingProps.elementType = mode;
+  pendingProps.type = mode;
+  pendingProps.expirationTime = expirationTime;
+  return pendingProps;
+}
 function createFiberFromText(content, mode, expirationTime) {
-  content = new FiberNode(8, content, null, mode);
+  content = createFiber(6, content, null, mode);
   content.expirationTime = expirationTime;
   return content;
 }
 function createFiberFromPortal(portal, mode, expirationTime) {
-  mode = new FiberNode(
-    6,
+  mode = createFiber(
+    4,
     null !== portal.children ? portal.children : [],
     portal.key,
     mode
@@ -1964,9 +1979,9 @@ function markPendingPriorityLevel(root, expirationTime) {
   var earliestPendingTime = root.earliestPendingTime;
   0 === earliestPendingTime
     ? (root.earliestPendingTime = root.latestPendingTime = expirationTime)
-    : earliestPendingTime > expirationTime
+    : earliestPendingTime < expirationTime
       ? (root.earliestPendingTime = expirationTime)
-      : root.latestPendingTime < expirationTime &&
+      : root.latestPendingTime > expirationTime &&
         (root.latestPendingTime = expirationTime);
   findNextExpirationTimeToWorkOn(expirationTime, root);
 }
@@ -1981,19 +1996,19 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
   else {
     var latestPendingTime = root.latestPendingTime;
     0 !== latestPendingTime &&
-      (latestPendingTime < earliestRemainingTime
+      (latestPendingTime > earliestRemainingTime
         ? (root.earliestPendingTime = root.latestPendingTime = 0)
-        : root.earliestPendingTime < earliestRemainingTime &&
+        : root.earliestPendingTime > earliestRemainingTime &&
           (root.earliestPendingTime = root.latestPendingTime));
     latestPendingTime = root.earliestSuspendedTime;
     0 === latestPendingTime
       ? markPendingPriorityLevel(root, earliestRemainingTime)
-      : earliestRemainingTime > root.latestSuspendedTime
+      : earliestRemainingTime < root.latestSuspendedTime
         ? ((root.earliestSuspendedTime = 0),
           (root.latestSuspendedTime = 0),
           (root.latestPingedTime = 0),
           markPendingPriorityLevel(root, earliestRemainingTime))
-        : earliestRemainingTime < latestPendingTime &&
+        : earliestRemainingTime > latestPendingTime &&
           markPendingPriorityLevel(root, earliestRemainingTime);
   }
   findNextExpirationTimeToWorkOn(0, root);
@@ -2003,17 +2018,17 @@ function hasLowerPriorityWork(root, erroredExpirationTime) {
     latestSuspendedTime = root.latestSuspendedTime;
   root = root.latestPingedTime;
   return (
-    (0 !== latestPendingTime && latestPendingTime > erroredExpirationTime) ||
+    (0 !== latestPendingTime && latestPendingTime < erroredExpirationTime) ||
     (0 !== latestSuspendedTime &&
-      latestSuspendedTime > erroredExpirationTime) ||
-    (0 !== root && root > erroredExpirationTime)
+      latestSuspendedTime < erroredExpirationTime) ||
+    (0 !== root && root < erroredExpirationTime)
   );
 }
 function markSuspendedPriorityLevel(root, suspendedTime) {
   root.didError = !1;
   var latestPingedTime = root.latestPingedTime;
   0 !== latestPingedTime &&
-    latestPingedTime <= suspendedTime &&
+    latestPingedTime >= suspendedTime &&
     (root.latestPingedTime = 0);
   latestPingedTime = root.earliestPendingTime;
   var latestPendingTime = root.latestPendingTime;
@@ -2028,12 +2043,20 @@ function markSuspendedPriorityLevel(root, suspendedTime) {
   latestPendingTime = root.latestSuspendedTime;
   0 === latestPingedTime
     ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
-    : latestPingedTime > suspendedTime
+    : latestPingedTime < suspendedTime
       ? (root.earliestSuspendedTime = suspendedTime)
-      : latestPendingTime < suspendedTime &&
+      : latestPendingTime > suspendedTime &&
         (root.latestSuspendedTime = suspendedTime);
   findNextExpirationTimeToWorkOn(suspendedTime, root);
 }
+function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
+  var earliestPendingTime = root.earliestPendingTime;
+  root = root.earliestSuspendedTime;
+  earliestPendingTime > renderExpirationTime &&
+    (renderExpirationTime = earliestPendingTime);
+  root > renderExpirationTime && (renderExpirationTime = root);
+  return renderExpirationTime;
+}
 function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
   var earliestSuspendedTime = root.earliestSuspendedTime,
     latestSuspendedTime = root.latestSuspendedTime,
@@ -2043,12 +2066,11 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
     0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
   0 === earliestPendingTime &&
     (0 === completedExpirationTime ||
-      latestSuspendedTime > completedExpirationTime) &&
+      latestSuspendedTime < completedExpirationTime) &&
     (earliestPendingTime = latestSuspendedTime);
   completedExpirationTime = earliestPendingTime;
   0 !== completedExpirationTime &&
-    0 !== earliestSuspendedTime &&
-    earliestSuspendedTime < completedExpirationTime &&
+    earliestSuspendedTime > completedExpirationTime &&
     (completedExpirationTime = earliestSuspendedTime);
   root.nextExpirationTimeToWorkOn = earliestPendingTime;
   root.expirationTime = completedExpirationTime;
@@ -2160,7 +2182,7 @@ function getStateFromUpdate(
           : workInProgress
       );
     case 3:
-      workInProgress.effectTag = (workInProgress.effectTag & -1025) | 64;
+      workInProgress.effectTag = (workInProgress.effectTag & -2049) | 64;
     case 0:
       workInProgress = update.payload;
       nextProps =
@@ -2193,58 +2215,52 @@ function processUpdateQueue(
 
   ) {
     var updateExpirationTime = update.expirationTime;
-    if (updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === newFirstUpdate &&
+    updateExpirationTime < renderExpirationTime
+      ? (null === newFirstUpdate &&
           ((newFirstUpdate = update), (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > updateExpirationTime)
-      )
-        newExpirationTime = updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < updateExpirationTime &&
+          (newExpirationTime = updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastEffect
             ? (queue.firstEffect = queue.lastEffect = update)
             : ((queue.lastEffect.nextEffect = update),
-              (queue.lastEffect = update)));
+              (queue.lastEffect = update))));
     update = update.next;
   }
   updateExpirationTime = null;
   for (update = queue.firstCapturedUpdate; null !== update; ) {
     var _updateExpirationTime = update.expirationTime;
-    if (_updateExpirationTime > renderExpirationTime) {
-      if (
-        (null === updateExpirationTime &&
+    _updateExpirationTime < renderExpirationTime
+      ? (null === updateExpirationTime &&
           ((updateExpirationTime = update),
           null === newFirstUpdate && (newBaseState = resultState)),
-        0 === newExpirationTime || newExpirationTime > _updateExpirationTime)
-      )
-        newExpirationTime = _updateExpirationTime;
-    } else
-      (resultState = getStateFromUpdate(
-        workInProgress,
-        queue,
-        update,
-        resultState,
-        props,
-        instance
-      )),
+        newExpirationTime < _updateExpirationTime &&
+          (newExpirationTime = _updateExpirationTime))
+      : ((resultState = getStateFromUpdate(
+          workInProgress,
+          queue,
+          update,
+          resultState,
+          props,
+          instance
+        )),
         null !== update.callback &&
           ((workInProgress.effectTag |= 32),
           (update.nextEffect = null),
           null === queue.lastCapturedEffect
             ? (queue.firstCapturedEffect = queue.lastCapturedEffect = update)
             : ((queue.lastCapturedEffect.nextEffect = update),
-              (queue.lastCapturedEffect = update)));
+              (queue.lastCapturedEffect = update))));
     update = update.next;
   }
   null === newFirstUpdate && (queue.lastUpdate = null);
@@ -2325,13 +2341,277 @@ function readContext(context, observedBits) {
     null === lastContextDependency
       ? (invariant(
           null !== currentlyRenderingFiber,
-          "Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
+          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
         ),
         (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
       : (lastContextDependency = lastContextDependency.next = observedBits);
   }
   return context._currentValue;
 }
+function areHookInputsEqual(arr1, arr2) {
+  for (var i = 0; i < arr1.length; i++) {
+    var val1 = arr1[i],
+      val2 = arr2[i];
+    if (
+      (val1 !== val2 || (0 === val1 && 1 / val1 !== 1 / val2)) &&
+      (val1 === val1 || val2 === val2)
+    )
+      return !1;
+  }
+  return !0;
+}
+var renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  isReRender = !1,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = 0;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function finishHooks(Component, props, children, refOrContext) {
+  for (; didScheduleRenderPhaseUpdate; )
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (children = Component(props, refOrContext));
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return children;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = 0;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.memoizedState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((isReRender = !1),
+        (currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((isReRender = !0),
+        (currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    isReRender = !1;
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (isReRender = !0),
+      (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (isReRender) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do
+            (initialAction = reducer(
+              initialAction,
+              firstRenderPhaseUpdate.action
+            )),
+              (firstRenderPhaseUpdate = firstRenderPhaseUpdate.next);
+          while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      initialAction = workInProgressHook.baseState;
+      var newBaseUpdate = (firstRenderPhaseUpdate = null),
+        _update = initialState,
+        didSkip = !1;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (newBaseUpdate = _baseUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : (initialAction = reducer(initialAction, _update.action));
+        _baseUpdate = _update;
+        _update = _update.next;
+      } while (null !== _update && _update !== initialState);
+      didSkip ||
+        ((newBaseUpdate = _baseUpdate),
+        (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = { last: null, dispatch: null };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, inputs) {
+  tag = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    inputs: inputs,
+    next: null
+  };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  inputs = void 0 !== inputs && null !== inputs ? inputs : [create];
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (areHookInputsEqual(inputs, prevEffect.inputs)) {
+      pushEffect(0, create, destroy, inputs);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    inputs
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (alternate = renderPhaseUpdates.get(queue)),
+      void 0 === alternate)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = alternate; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    alternate = requestCurrentTime();
+    alternate = computeExpirationForFiber(alternate, fiber);
+    action = { expirationTime: alternate, action: action, next: null };
+    flushPassiveEffects();
+    var _last2 = queue.last;
+    if (null === _last2) action.next = action;
+    else {
+      var first = _last2.next;
+      null !== first && (action.next = first);
+      _last2.next = action;
+    }
+    queue.last = action;
+    scheduleWork(fiber, alternate);
+  }
+}
 var NO_CONTEXT = {},
   contextStackCursor$1 = { current: NO_CONTEXT },
   contextFiberStackCursor = { current: NO_CONTEXT },
@@ -2411,7 +2691,47 @@ function shallowEqual(objA, objB) {
       return !1;
   return !0;
 }
-var emptyRefsObject = new React.Component().refs;
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    baseProps = Object.assign({}, baseProps);
+    Component = Component.defaultProps;
+    for (var propName in Component)
+      void 0 === baseProps[propName] &&
+        (baseProps[propName] = Component[propName]);
+  }
+  return baseProps;
+}
+function readLazyComponentType(lazyComponent) {
+  var result = lazyComponent._result;
+  switch (lazyComponent._status) {
+    case 1:
+      return result;
+    case 2:
+      throw result;
+    case 0:
+      throw result;
+    default:
+      throw ((lazyComponent._status = 0),
+      (result = lazyComponent._ctor),
+      (result = result()),
+      result.then(
+        function(moduleObject) {
+          0 === lazyComponent._status &&
+            ((moduleObject = moduleObject.default),
+            (lazyComponent._status = 1),
+            (lazyComponent._result = moduleObject));
+        },
+        function(error) {
+          0 === lazyComponent._status &&
+            ((lazyComponent._status = 2), (lazyComponent._result = error));
+        }
+      ),
+      (lazyComponent._result = result),
+      result);
+  }
+}
+var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
+  emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2443,6 +2763,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2454,6 +2775,7 @@ var classComponentUpdater = {
     update.tag = 1;
     update.payload = payload;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   },
@@ -2464,6 +2786,7 @@ var classComponentUpdater = {
     var update = createUpdate(currentTime);
     update.tag = 2;
     void 0 !== callback && null !== callback && (update.callback = callback);
+    flushPassiveEffects();
     enqueueUpdate(inst, update);
     scheduleWork(inst, currentTime);
   }
@@ -2484,6 +2807,32 @@ function checkShouldComponentUpdate(
       ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
       : !0;
 }
+function constructClassInstance(workInProgress, ctor, props) {
+  var isLegacyContextConsumer = !1,
+    unmaskedContext = emptyContextObject;
+  var context = ctor.contextType;
+  "object" === typeof context && null !== context
+    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    : ((unmaskedContext = isContextProvider(ctor)
+        ? previousContext
+        : contextStackCursor.current),
+      (isLegacyContextConsumer = ctor.contextTypes),
+      (context = (isLegacyContextConsumer =
+        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
+        ? getMaskedContext(workInProgress, unmaskedContext)
+        : emptyContextObject));
+  ctor = new ctor(props, context);
+  workInProgress.memoizedState =
+    null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
+  ctor.updater = classComponentUpdater;
+  workInProgress.stateNode = ctor;
+  ctor._reactInternalFiber = workInProgress;
+  isLegacyContextConsumer &&
+    ((workInProgress = workInProgress.stateNode),
+    (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
+    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
+  return ctor;
+}
 function callComponentWillReceiveProps(
   workInProgress,
   instance,
@@ -2510,7 +2859,9 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = contextType.unstable_read())
+    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
+        contextType
+      ))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2565,10 +2916,7 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(
-          2 === element.tag || 3 === element.tag,
-          "Function components cannot have refs."
-        ),
+        (invariant(1 === element.tag, "Function components cannot have refs."),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -2673,7 +3021,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     textContent,
     expirationTime
   ) {
-    if (null === current$$1 || 8 !== current$$1.tag)
+    if (null === current$$1 || 6 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromText(
           textContent,
@@ -2688,15 +3036,18 @@ function ChildReconciler(shouldTrackSideEffects) {
     return current$$1;
   }
   function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (null !== current$$1 && current$$1.type === element.type)
+    if (null !== current$$1 && current$$1.elementType === element.type)
       return (
         (expirationTime = useFiber(current$$1, element.props, expirationTime)),
         (expirationTime.ref = coerceRef(returnFiber, current$$1, element)),
         (expirationTime.return = returnFiber),
         expirationTime
       );
-    expirationTime = createFiberFromElement(
-      element,
+    expirationTime = createFiberFromTypeAndProps(
+      element.type,
+      element.key,
+      element.props,
+      null,
       returnFiber.mode,
       expirationTime
     );
@@ -2707,7 +3058,7 @@ function ChildReconciler(shouldTrackSideEffects) {
   function updatePortal(returnFiber, current$$1, portal, expirationTime) {
     if (
       null === current$$1 ||
-      6 !== current$$1.tag ||
+      4 !== current$$1.tag ||
       current$$1.stateNode.containerInfo !== portal.containerInfo ||
       current$$1.stateNode.implementation !== portal.implementation
     )
@@ -2731,7 +3082,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     expirationTime,
     key
   ) {
-    if (null === current$$1 || 9 !== current$$1.tag)
+    if (null === current$$1 || 7 !== current$$1.tag)
       return (
         (current$$1 = createFiberFromFragment(
           fragment,
@@ -2761,8 +3112,11 @@ function ChildReconciler(shouldTrackSideEffects) {
       switch (newChild.$$typeof) {
         case REACT_ELEMENT_TYPE:
           return (
-            (expirationTime = createFiberFromElement(
-              newChild,
+            (expirationTime = createFiberFromTypeAndProps(
+              newChild.type,
+              newChild.key,
+              newChild.props,
+              null,
               returnFiber.mode,
               expirationTime
             )),
@@ -3106,9 +3460,9 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (isUnkeyedTopLevelFragment.key === isObject)
                 if (
-                  9 === isUnkeyedTopLevelFragment.tag
+                  7 === isUnkeyedTopLevelFragment.tag
                     ? newChild.type === REACT_FRAGMENT_TYPE
-                    : isUnkeyedTopLevelFragment.type === newChild.type
+                    : isUnkeyedTopLevelFragment.elementType === newChild.type
                 ) {
                   deleteRemainingChildren(
                     returnFiber,
@@ -3148,8 +3502,11 @@ function ChildReconciler(shouldTrackSideEffects) {
                 )),
                 (currentFirstChild.return = returnFiber),
                 (returnFiber = currentFirstChild))
-              : ((expirationTime = createFiberFromElement(
-                  newChild,
+              : ((expirationTime = createFiberFromTypeAndProps(
+                  newChild.type,
+                  newChild.key,
+                  newChild.props,
+                  null,
                   returnFiber.mode,
                   expirationTime
                 )),
@@ -3171,7 +3528,7 @@ function ChildReconciler(shouldTrackSideEffects) {
             ) {
               if (currentFirstChild.key === isUnkeyedTopLevelFragment)
                 if (
-                  6 === currentFirstChild.tag &&
+                  4 === currentFirstChild.tag &&
                   currentFirstChild.stateNode.containerInfo ===
                     newChild.containerInfo &&
                   currentFirstChild.stateNode.implementation ===
@@ -3209,7 +3566,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     if ("string" === typeof newChild || "number" === typeof newChild)
       return (
         (newChild = "" + newChild),
-        null !== currentFirstChild && 8 === currentFirstChild.tag
+        null !== currentFirstChild && 6 === currentFirstChild.tag
           ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
             (currentFirstChild = useFiber(
               currentFirstChild,
@@ -3245,8 +3602,7 @@ function ChildReconciler(shouldTrackSideEffects) {
     isObject && throwOnInvalidObjectType(returnFiber, newChild);
     if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
       switch (returnFiber.tag) {
-        case 2:
-        case 3:
+        case 1:
         case 0:
           (expirationTime = returnFiber.type),
             invariant(
@@ -3265,12 +3621,12 @@ var reconcileChildFibers = ChildReconciler(!0),
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
   switch (fiber.tag) {
-    case 7:
+    case 5:
       return (
         (nextInstance = shim$1(nextInstance, fiber.type, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
       );
-    case 8:
+    case 6:
       return (
         (nextInstance = shim$1(nextInstance, fiber.pendingProps)),
         null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
@@ -3293,7 +3649,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
           return;
         }
         var returnFiber = hydrationParentFiber,
-          fiber = new FiberNode(7, null, null, 0);
+          fiber = createFiber(5, null, null, 0);
+        fiber.elementType = "DELETED";
         fiber.type = "DELETED";
         fiber.stateNode = firstAttemptedInstance;
         fiber.return = returnFiber;
@@ -3311,38 +3668,6 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-function readLazyComponentType(thenable) {
-  switch (thenable._reactStatus) {
-    case 1:
-      return thenable._reactResult;
-    case 2:
-      throw thenable._reactResult;
-    case 0:
-      throw thenable;
-    default:
-      throw ((thenable._reactStatus = 0),
-      thenable.then(
-        function(resolvedValue) {
-          if (0 === thenable._reactStatus) {
-            thenable._reactStatus = 1;
-            if ("object" === typeof resolvedValue && null !== resolvedValue) {
-              var defaultExport = resolvedValue.default;
-              resolvedValue =
-                void 0 !== defaultExport && null !== defaultExport
-                  ? defaultExport
-                  : resolvedValue;
-            }
-            thenable._reactResult = resolvedValue;
-          }
-        },
-        function(error) {
-          0 === thenable._reactStatus &&
-            ((thenable._reactStatus = 2), (thenable._reactResult = error));
-        }
-      ),
-      thenable);
-  }
-}
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 function reconcileChildren(
   current$$1,
@@ -3368,28 +3693,28 @@ function reconcileChildren(
 function updateForwardRef(
   current$$1,
   workInProgress,
-  type,
+  Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
-  type = type.render;
+  Component = Component.render;
   var ref = workInProgress.ref;
-  if (
-    !didPerformWorkStackCursor.current &&
-    workInProgress.memoizedProps === nextProps &&
-    ref === (null !== current$$1 ? current$$1.ref : null)
-  )
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  type = type(nextProps, ref);
-  reconcileChildren(current$$1, workInProgress, type, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, ref);
+  nextChildren = finishHooks(Component, nextProps, nextChildren, ref);
+  workInProgress.effectTag |= 1;
+  reconcileChildren(
+    current$$1,
+    workInProgress,
+    nextChildren,
+    renderExpirationTime$jscomp$0
+  );
   return workInProgress.child;
 }
-function updatePureComponent(
+function updateMemoComponent(
   current$$1,
   workInProgress,
   Component,
@@ -3397,27 +3722,82 @@ function updatePureComponent(
   updateExpirationTime,
   renderExpirationTime
 ) {
-  var render = Component.render;
+  if (null === current$$1) {
+    var type = Component.type;
+    if (
+      "function" === typeof type &&
+      !shouldConstruct(type) &&
+      void 0 === type.defaultProps &&
+      null === Component.compare
+    )
+      return (
+        (workInProgress.tag = 15),
+        (workInProgress.type = type),
+        updateSimpleMemoComponent(
+          current$$1,
+          workInProgress,
+          type,
+          nextProps,
+          updateExpirationTime,
+          renderExpirationTime
+        )
+      );
+    current$$1 = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      null,
+      workInProgress.mode,
+      renderExpirationTime
+    );
+    current$$1.ref = workInProgress.ref;
+    current$$1.return = workInProgress;
+    return (workInProgress.child = current$$1);
+  }
+  type = current$$1.child;
   if (
-    null !== current$$1 &&
-    (0 === updateExpirationTime ||
-      updateExpirationTime > renderExpirationTime) &&
-    ((updateExpirationTime = current$$1.memoizedProps),
+    updateExpirationTime < renderExpirationTime &&
+    ((updateExpirationTime = type.memoizedProps),
     (Component = Component.compare),
     (Component = null !== Component ? Component : shallowEqual),
-    Component(updateExpirationTime, nextProps))
+    Component(updateExpirationTime, nextProps) &&
+      current$$1.ref === workInProgress.ref)
   )
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
       renderExpirationTime
     );
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  render = render(nextProps);
   workInProgress.effectTag |= 1;
-  reconcileChildren(current$$1, workInProgress, render, renderExpirationTime);
-  workInProgress.memoizedProps = nextProps;
-  return workInProgress.child;
+  current$$1 = createWorkInProgress(type, nextProps, renderExpirationTime);
+  current$$1.ref = workInProgress.ref;
+  current$$1.return = workInProgress;
+  return (workInProgress.child = current$$1);
+}
+function updateSimpleMemoComponent(
+  current$$1,
+  workInProgress,
+  Component,
+  nextProps,
+  updateExpirationTime,
+  renderExpirationTime
+) {
+  return null !== current$$1 &&
+    updateExpirationTime < renderExpirationTime &&
+    shallowEqual(current$$1.memoizedProps, nextProps) &&
+    current$$1.ref === workInProgress.ref
+    ? bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    : updateFunctionComponent(
+        current$$1,
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      );
 }
 function markRef(current$$1, workInProgress) {
   var ref = workInProgress.ref;
@@ -3432,22 +3812,30 @@ function updateFunctionComponent(
   workInProgress,
   Component,
   nextProps,
-  renderExpirationTime
+  renderExpirationTime$jscomp$0
 ) {
   var unmaskedContext = isContextProvider(Component)
     ? previousContext
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
-  prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+  renderExpirationTime = renderExpirationTime$jscomp$0;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current$$1 ? current$$1.memoizedState : null;
+  var nextChildren = Component(nextProps, unmaskedContext);
+  nextChildren = finishHooks(
+    Component,
+    nextProps,
+    nextChildren,
+    unmaskedContext
+  );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
     workInProgress,
-    Component,
-    renderExpirationTime
+    nextChildren,
+    renderExpirationTime$jscomp$0
   );
-  workInProgress.memoizedProps = nextProps;
   return workInProgress.child;
 }
 function updateClassComponent(
@@ -3462,82 +3850,153 @@ function updateClassComponent(
     pushContextProvider(workInProgress);
   } else hasContext = !1;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  if (null === current$$1)
-    if (null === workInProgress.stateNode) {
-      var isLegacyContextConsumer = !1,
-        unmaskedContext = emptyContextObject;
-      var context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((unmaskedContext = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (isLegacyContextConsumer = Component.contextTypes),
-          (context = (isLegacyContextConsumer =
-            null !== isLegacyContextConsumer &&
-            void 0 !== isLegacyContextConsumer)
-            ? getMaskedContext(workInProgress, unmaskedContext)
-            : emptyContextObject));
-      var instance = new Component(nextProps, context);
-      workInProgress.memoizedState =
-        null !== instance.state && void 0 !== instance.state
-          ? instance.state
-          : null;
-      instance.updater = classComponentUpdater;
-      workInProgress.stateNode = instance;
-      instance._reactInternalFiber = workInProgress;
-      isLegacyContextConsumer &&
-        ((isLegacyContextConsumer = workInProgress.stateNode),
-        (isLegacyContextConsumer.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
-        (isLegacyContextConsumer.__reactInternalMemoizedMaskedChildContext = context));
+  if (null === workInProgress.stateNode)
+    null !== current$$1 &&
+      ((current$$1.alternate = null),
+      (workInProgress.alternate = null),
+      (workInProgress.effectTag |= 2)),
+      constructClassInstance(
+        workInProgress,
+        Component,
+        nextProps,
+        renderExpirationTime
+      ),
       mountClassInstance(
         workInProgress,
         Component,
         nextProps,
         renderExpirationTime
-      );
-      nextProps = !0;
-    } else {
-      unmaskedContext = workInProgress.stateNode;
-      isLegacyContextConsumer = workInProgress.memoizedProps;
-      unmaskedContext.props = isLegacyContextConsumer;
-      var oldContext = unmaskedContext.context;
-      context = Component.contextType;
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
+      ),
+      (nextProps = !0);
+  else if (null === current$$1) {
+    var instance = workInProgress.stateNode,
+      oldProps = workInProgress.memoizedProps;
+    instance.props = oldProps;
+    var oldContext = instance.context,
+      contextType = Component.contextType;
+    "object" === typeof contextType && null !== contextType
+      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+          contextType
+        ))
+      : ((contextType = isContextProvider(Component)
+          ? previousContext
+          : contextStackCursor.current),
+        (contextType = getMaskedContext(workInProgress, contextType)));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
+      hasNewLifecycles =
+        "function" === typeof getDerivedStateFromProps ||
+        "function" === typeof instance.getSnapshotBeforeUpdate;
+    hasNewLifecycles ||
+      ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof instance.componentWillReceiveProps) ||
+      ((oldProps !== nextProps || oldContext !== contextType) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          instance,
+          nextProps,
+          contextType
+        ));
+    hasForceUpdate = !1;
+    var oldState = workInProgress.memoizedState;
+    oldContext = instance.state = oldState;
+    var updateQueue = workInProgress.updateQueue;
+    null !== updateQueue &&
+      (processUpdateQueue(
+        workInProgress,
+        updateQueue,
+        nextProps,
+        instance,
+        renderExpirationTime
+      ),
+      (oldContext = workInProgress.memoizedState));
+    oldProps !== nextProps ||
+    oldState !== oldContext ||
+    didPerformWorkStackCursor.current ||
+    hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps,
+            nextProps
+          ),
+          (oldContext = workInProgress.memoizedState)),
+        (oldProps =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
+            workInProgress,
+            Component,
+            oldProps,
+            nextProps,
+            oldState,
+            oldContext,
+            contextType
+          ))
+          ? (hasNewLifecycles ||
+              ("function" !== typeof instance.UNSAFE_componentWillMount &&
+                "function" !== typeof instance.componentWillMount) ||
+              ("function" === typeof instance.componentWillMount &&
+                instance.componentWillMount(),
+              "function" === typeof instance.UNSAFE_componentWillMount &&
+                instance.UNSAFE_componentWillMount()),
+            "function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4))
+          : ("function" === typeof instance.componentDidMount &&
+              (workInProgress.effectTag |= 4),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = oldContext)),
+        (instance.props = nextProps),
+        (instance.state = oldContext),
+        (instance.context = contextType),
+        (nextProps = oldProps))
+      : ("function" === typeof instance.componentDidMount &&
+          (workInProgress.effectTag |= 4),
+        (nextProps = !1));
+  } else
+    (instance = workInProgress.stateNode),
+      (oldProps = workInProgress.memoizedProps),
+      (instance.props =
+        workInProgress.type === workInProgress.elementType
+          ? oldProps
+          : resolveDefaultProps(workInProgress.type, oldProps)),
+      (oldContext = instance.context),
+      (contextType = Component.contextType),
+      "object" === typeof contextType && null !== contextType
+        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
+            contextType
+          ))
+        : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context)));
-      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
-      (instance =
+          (contextType = getMaskedContext(workInProgress, contextType))),
+      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
+      (hasNewLifecycles =
         "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
+        "function" === typeof instance.getSnapshotBeforeUpdate) ||
+        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
+          "function" !== typeof instance.componentWillReceiveProps) ||
+        ((oldProps !== nextProps || oldContext !== contextType) &&
           callComponentWillReceiveProps(
             workInProgress,
-            unmaskedContext,
+            instance,
             nextProps,
-            context
-          ));
-      hasForceUpdate = !1;
-      var oldState = workInProgress.memoizedState;
-      oldContext = unmaskedContext.state = oldState;
-      var updateQueue = workInProgress.updateQueue;
+            contextType
+          )),
+      (hasForceUpdate = !1),
+      (oldContext = workInProgress.memoizedState),
+      (oldState = instance.state = oldContext),
+      (updateQueue = workInProgress.updateQueue),
       null !== updateQueue &&
         (processUpdateQueue(
           workInProgress,
           updateQueue,
           nextProps,
-          unmaskedContext,
+          instance,
           renderExpirationTime
         ),
-        (oldContext = workInProgress.memoizedState));
-      isLegacyContextConsumer !== nextProps ||
-      oldState !== oldContext ||
+        (oldState = workInProgress.memoizedState)),
+      oldProps !== nextProps ||
+      oldContext !== oldState ||
       didPerformWorkStackCursor.current ||
       hasForceUpdate
         ? ("function" === typeof getDerivedStateFromProps &&
@@ -3547,144 +4006,57 @@ function updateClassComponent(
               getDerivedStateFromProps,
               nextProps
             ),
-            (oldContext = workInProgress.memoizedState)),
-          (isLegacyContextConsumer =
+            (oldState = workInProgress.memoizedState)),
+          (getDerivedStateFromProps =
             hasForceUpdate ||
             checkShouldComponentUpdate(
               workInProgress,
               Component,
-              isLegacyContextConsumer,
+              oldProps,
               nextProps,
-              oldState,
               oldContext,
-              context
+              oldState,
+              contextType
             ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  "function" !== typeof unmaskedContext.componentWillMount) ||
-                ("function" === typeof unmaskedContext.componentWillMount &&
-                  unmaskedContext.componentWillMount(),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillMount &&
-                  unmaskedContext.UNSAFE_componentWillMount()),
-              "function" === typeof unmaskedContext.componentDidMount &&
-                (workInProgress.effectTag |= 4))
-            : ("function" === typeof unmaskedContext.componentDidMount &&
+            ? (hasNewLifecycles ||
+                ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
+                  "function" !== typeof instance.componentWillUpdate) ||
+                ("function" === typeof instance.componentWillUpdate &&
+                  instance.componentWillUpdate(
+                    nextProps,
+                    oldState,
+                    contextType
+                  ),
+                "function" === typeof instance.UNSAFE_componentWillUpdate &&
+                  instance.UNSAFE_componentWillUpdate(
+                    nextProps,
+                    oldState,
+                    contextType
+                  )),
+              "function" === typeof instance.componentDidUpdate &&
                 (workInProgress.effectTag |= 4),
-              (workInProgress.memoizedProps = nextProps),
-              (workInProgress.memoizedState = oldContext)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldContext),
-          (unmaskedContext.context = context),
-          (nextProps = isLegacyContextConsumer))
-        : ("function" === typeof unmaskedContext.componentDidMount &&
-            (workInProgress.effectTag |= 4),
-          (nextProps = !1));
-    }
-  else
-    (unmaskedContext = workInProgress.stateNode),
-      (isLegacyContextConsumer = workInProgress.memoizedProps),
-      (unmaskedContext.props = isLegacyContextConsumer),
-      (oldContext = unmaskedContext.context),
-      (context = Component.contextType),
-      "object" === typeof context && null !== context
-        ? (context = context.unstable_read())
-        : ((context = isContextProvider(Component)
-            ? previousContext
-            : contextStackCursor.current),
-          (context = getMaskedContext(workInProgress, context))),
-      (getDerivedStateFromProps = Component.getDerivedStateFromProps),
-      (instance =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
-        ("function" !==
-          typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
-          "function" !== typeof unmaskedContext.componentWillReceiveProps) ||
-        ((isLegacyContextConsumer !== nextProps || oldContext !== context) &&
-          callComponentWillReceiveProps(
-            workInProgress,
-            unmaskedContext,
-            nextProps,
-            context
-          )),
-      (hasForceUpdate = !1),
-      (oldContext = workInProgress.memoizedState),
-      (oldState = unmaskedContext.state = oldContext),
-      (updateQueue = workInProgress.updateQueue),
-      null !== updateQueue &&
-        (processUpdateQueue(
-          workInProgress,
-          updateQueue,
-          nextProps,
-          unmaskedContext,
-          renderExpirationTime
-        ),
-        (oldState = workInProgress.memoizedState)),
-      isLegacyContextConsumer !== nextProps ||
-      oldContext !== oldState ||
-      didPerformWorkStackCursor.current ||
-      hasForceUpdate
-        ? ("function" === typeof getDerivedStateFromProps &&
-            (applyDerivedStateFromProps(
-              workInProgress,
-              Component,
-              getDerivedStateFromProps,
-              nextProps
-            ),
-            (oldState = workInProgress.memoizedState)),
-          (getDerivedStateFromProps =
-            hasForceUpdate ||
-            checkShouldComponentUpdate(
-              workInProgress,
-              Component,
-              isLegacyContextConsumer,
-              nextProps,
-              oldContext,
-              oldState,
-              context
-            ))
-            ? (instance ||
-                ("function" !==
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  "function" !== typeof unmaskedContext.componentWillUpdate) ||
-                ("function" === typeof unmaskedContext.componentWillUpdate &&
-                  unmaskedContext.componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    context
-                  ),
-                "function" ===
-                  typeof unmaskedContext.UNSAFE_componentWillUpdate &&
-                  unmaskedContext.UNSAFE_componentWillUpdate(
-                    nextProps,
-                    oldState,
-                    context
-                  )),
-              "function" === typeof unmaskedContext.componentDidUpdate &&
-                (workInProgress.effectTag |= 4),
-              "function" === typeof unmaskedContext.getSnapshotBeforeUpdate &&
+              "function" === typeof instance.getSnapshotBeforeUpdate &&
                 (workInProgress.effectTag |= 256))
-            : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
+            : ("function" !== typeof instance.componentDidUpdate ||
+                (oldProps === current$$1.memoizedProps &&
                   oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 4),
-              "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-                (isLegacyContextConsumer === current$$1.memoizedProps &&
+              "function" !== typeof instance.getSnapshotBeforeUpdate ||
+                (oldProps === current$$1.memoizedProps &&
                   oldContext === current$$1.memoizedState) ||
                 (workInProgress.effectTag |= 256),
               (workInProgress.memoizedProps = nextProps),
               (workInProgress.memoizedState = oldState)),
-          (unmaskedContext.props = nextProps),
-          (unmaskedContext.state = oldState),
-          (unmaskedContext.context = context),
+          (instance.props = nextProps),
+          (instance.state = oldState),
+          (instance.context = contextType),
           (nextProps = getDerivedStateFromProps))
-        : ("function" !== typeof unmaskedContext.componentDidUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+        : ("function" !== typeof instance.componentDidUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 4),
-          "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
-            (isLegacyContextConsumer === current$$1.memoizedProps &&
+          "function" !== typeof instance.getSnapshotBeforeUpdate ||
+            (oldProps === current$$1.memoizedProps &&
               oldContext === current$$1.memoizedState) ||
             (workInProgress.effectTag |= 256),
           (nextProps = !1));
@@ -3747,7 +4119,6 @@ function finishClassComponent(
         renderExpirationTime
       );
   workInProgress.memoizedState = shouldUpdate.state;
-  workInProgress.memoizedProps = shouldUpdate.props;
   hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
@@ -3763,15 +4134,123 @@ function pushHostRootContext(workInProgress) {
       pushTopLevelContextObject(workInProgress, root.context, !1);
   pushHostContainer(workInProgress, root.containerInfo);
 }
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    baseProps = Object.assign({}, baseProps);
-    Component = Component.defaultProps;
-    for (var propName in Component)
-      void 0 === baseProps[propName] &&
-        (baseProps[propName] = Component[propName]);
-  }
-  return baseProps;
+function updateSuspenseComponent(
+  current$$1,
+  workInProgress,
+  renderExpirationTime
+) {
+  var mode = workInProgress.mode,
+    nextProps = workInProgress.pendingProps,
+    nextState = workInProgress.memoizedState;
+  if (0 === (workInProgress.effectTag & 64)) {
+    nextState = null;
+    var nextDidTimeout = !1;
+  } else
+    (nextState = { timedOutAt: null !== nextState ? nextState.timedOutAt : 0 }),
+      (nextDidTimeout = !0),
+      (workInProgress.effectTag &= -65);
+  if (null === current$$1)
+    nextDidTimeout
+      ? ((nextDidTimeout = nextProps.fallback),
+        (nextProps = createFiberFromFragment(null, mode, 0, null)),
+        0 === (workInProgress.mode & 1) &&
+          (nextProps.child =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child),
+        (renderExpirationTime = createFiberFromFragment(
+          nextDidTimeout,
+          mode,
+          renderExpirationTime,
+          null
+        )),
+        (nextProps.sibling = renderExpirationTime),
+        (mode = nextProps),
+        (mode.return = renderExpirationTime.return = workInProgress))
+      : (mode = renderExpirationTime = mountChildFibers(
+          workInProgress,
+          null,
+          nextProps.children,
+          renderExpirationTime
+        ));
+  else if (null !== current$$1.memoizedState)
+    if (
+      ((current$$1 = current$$1.child),
+      (mode = current$$1.sibling),
+      nextDidTimeout)
+    ) {
+      nextProps = nextProps.fallback;
+      renderExpirationTime = createWorkInProgress(
+        current$$1,
+        current$$1.pendingProps,
+        0
+      );
+      0 === (workInProgress.mode & 1) &&
+        ((nextDidTimeout =
+          null !== workInProgress.memoizedState
+            ? workInProgress.child.child
+            : workInProgress.child),
+        nextDidTimeout !== current$$1.child &&
+          (renderExpirationTime.child = nextDidTimeout));
+      if (workInProgress.mode & 4) {
+        nextDidTimeout = 0;
+        for (current$$1 = renderExpirationTime.child; null !== current$$1; )
+          (nextDidTimeout += current$$1.treeBaseDuration),
+            (current$$1 = current$$1.sibling);
+        renderExpirationTime.treeBaseDuration = nextDidTimeout;
+      }
+      nextProps = renderExpirationTime.sibling = createWorkInProgress(
+        mode,
+        nextProps,
+        mode.expirationTime
+      );
+      mode = renderExpirationTime;
+      renderExpirationTime.childExpirationTime = 0;
+      renderExpirationTime = nextProps;
+      mode.return = renderExpirationTime.return = workInProgress;
+    } else
+      mode = renderExpirationTime = reconcileChildFibers(
+        workInProgress,
+        current$$1.child,
+        nextProps.children,
+        renderExpirationTime
+      );
+  else if (((current$$1 = current$$1.child), nextDidTimeout)) {
+    nextDidTimeout = nextProps.fallback;
+    nextProps = createFiberFromFragment(null, mode, 0, null);
+    nextProps.child = current$$1;
+    0 === (workInProgress.mode & 1) &&
+      (nextProps.child =
+        null !== workInProgress.memoizedState
+          ? workInProgress.child.child
+          : workInProgress.child);
+    if (workInProgress.mode & 4) {
+      current$$1 = 0;
+      for (var _hiddenChild = nextProps.child; null !== _hiddenChild; )
+        (current$$1 += _hiddenChild.treeBaseDuration),
+          (_hiddenChild = _hiddenChild.sibling);
+      nextProps.treeBaseDuration = current$$1;
+    }
+    renderExpirationTime = nextProps.sibling = createFiberFromFragment(
+      nextDidTimeout,
+      mode,
+      renderExpirationTime,
+      null
+    );
+    renderExpirationTime.effectTag |= 2;
+    mode = nextProps;
+    nextProps.childExpirationTime = 0;
+    mode.return = renderExpirationTime.return = workInProgress;
+  } else
+    renderExpirationTime = mode = reconcileChildFibers(
+      workInProgress,
+      current$$1,
+      nextProps.children,
+      renderExpirationTime
+    );
+  workInProgress.memoizedState = nextState;
+  workInProgress.child = mode;
+  return renderExpirationTime;
 }
 function bailoutOnAlreadyFinishedWork(
   current$$1,
@@ -3781,9 +4260,7 @@ function bailoutOnAlreadyFinishedWork(
   null !== current$$1 &&
     (workInProgress.firstContextDependency = current$$1.firstContextDependency);
   profilerStartTime = -1;
-  var childExpirationTime = workInProgress.childExpirationTime;
-  if (0 === childExpirationTime || childExpirationTime > renderExpirationTime)
-    return null;
+  if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
     null === current$$1 || workInProgress.child === current$$1.child,
     "Resuming work not yet implemented."
@@ -3812,522 +4289,563 @@ function bailoutOnAlreadyFinishedWork(
   }
   return workInProgress.child;
 }
-function beginWork(current$$1, workInProgress, renderExpirationTime) {
+function beginWork(current$$1, workInProgress, renderExpirationTime$jscomp$0) {
   var updateExpirationTime = workInProgress.expirationTime;
   if (
     null !== current$$1 &&
     current$$1.memoizedProps === workInProgress.pendingProps &&
     !didPerformWorkStackCursor.current &&
-    (0 === updateExpirationTime || updateExpirationTime > renderExpirationTime)
+    updateExpirationTime < renderExpirationTime$jscomp$0
   ) {
     switch (workInProgress.tag) {
-      case 5:
+      case 3:
         pushHostRootContext(workInProgress);
         break;
-      case 7:
+      case 5:
         pushHostContext(workInProgress);
         break;
-      case 2:
+      case 1:
         isContextProvider(workInProgress.type) &&
           pushContextProvider(workInProgress);
         break;
-      case 3:
-        isContextProvider(workInProgress.type._reactResult) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 6:
+      case 4:
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         );
         break;
-      case 12:
+      case 10:
         pushProvider(workInProgress, workInProgress.memoizedProps.value);
         break;
-      case 15:
+      case 12:
         workInProgress.effectTag |= 4;
+        break;
+      case 13:
+        if (null !== workInProgress.memoizedState) {
+          updateExpirationTime = workInProgress.child.childExpirationTime;
+          if (
+            0 !== updateExpirationTime &&
+            updateExpirationTime >= renderExpirationTime$jscomp$0
+          )
+            return updateSuspenseComponent(
+              current$$1,
+              workInProgress,
+              renderExpirationTime$jscomp$0
+            );
+          workInProgress = bailoutOnAlreadyFinishedWork(
+            current$$1,
+            workInProgress,
+            renderExpirationTime$jscomp$0
+          );
+          return null !== workInProgress ? workInProgress.sibling : null;
+        }
     }
     return bailoutOnAlreadyFinishedWork(
       current$$1,
       workInProgress,
-      renderExpirationTime
+      renderExpirationTime$jscomp$0
     );
   }
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
-    case 4:
-      var Component = workInProgress.type;
-      invariant(
-        null === current$$1,
-        "An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue."
+    case 2:
+      updateExpirationTime = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      current$$1 = workInProgress.pendingProps;
+      var context = getMaskedContext(
+        workInProgress,
+        contextStackCursor.current
       );
-      var props = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0);
+      renderExpirationTime = renderExpirationTime$jscomp$0;
+      currentlyRenderingFiber$1 = workInProgress;
+      firstCurrentHook = null;
+      var value = updateExpirationTime(current$$1, context);
+      workInProgress.effectTag |= 1;
       if (
-        "object" === typeof Component &&
-        null !== Component &&
-        "function" === typeof Component.then
+        "object" === typeof value &&
+        null !== value &&
+        "function" === typeof value.render &&
+        void 0 === value.$$typeof
       ) {
-        Component = readLazyComponentType(Component);
-        var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(
+        workInProgress.tag = 1;
+        resetHooks();
+        isContextProvider(updateExpirationTime)
+          ? ((context = !0), pushContextProvider(workInProgress))
+          : (context = !1);
+        workInProgress.memoizedState =
+          null !== value.state && void 0 !== value.state ? value.state : null;
+        var getDerivedStateFromProps =
+          updateExpirationTime.getDerivedStateFromProps;
+        "function" === typeof getDerivedStateFromProps &&
+          applyDerivedStateFromProps(
             workInProgress,
-            Component
-          )),
-          resolvedProps = resolveDefaultProps(Component, props),
-          child = void 0;
-        switch (resolvedTag) {
-          case 1:
-            child = updateFunctionComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 3:
-            child = updateClassComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 14:
-            child = updateForwardRef(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              renderExpirationTime
-            );
-            break;
-          case 18:
-            child = updatePureComponent(
-              current$$1,
-              workInProgress,
-              Component,
-              resolvedProps,
-              updateExpirationTime,
-              renderExpirationTime
-            );
-            break;
-          default:
-            invariant(
-              !1,
-              "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
-              Component
-            );
-        }
-        workInProgress.memoizedProps = props;
-        workInProgress = child;
-      } else
-        (updateExpirationTime = getMaskedContext(
+            updateExpirationTime,
+            getDerivedStateFromProps,
+            current$$1
+          );
+        value.updater = classComponentUpdater;
+        workInProgress.stateNode = value;
+        value._reactInternalFiber = workInProgress;
+        mountClassInstance(
           workInProgress,
-          contextStackCursor.current
-        )),
-          prepareToReadContext(workInProgress, renderExpirationTime),
-          (updateExpirationTime = Component(props, updateExpirationTime)),
-          (workInProgress.effectTag |= 1),
-          "object" === typeof updateExpirationTime &&
-          null !== updateExpirationTime &&
-          "function" === typeof updateExpirationTime.render &&
-          void 0 === updateExpirationTime.$$typeof
-            ? ((workInProgress.tag = 2),
-              isContextProvider(Component)
-                ? ((resolvedTag = !0), pushContextProvider(workInProgress))
-                : (resolvedTag = !1),
-              (workInProgress.memoizedState =
-                null !== updateExpirationTime.state &&
-                void 0 !== updateExpirationTime.state
-                  ? updateExpirationTime.state
-                  : null),
-              (resolvedProps = Component.getDerivedStateFromProps),
-              "function" === typeof resolvedProps &&
-                applyDerivedStateFromProps(
-                  workInProgress,
-                  Component,
-                  resolvedProps,
-                  props
-                ),
-              (updateExpirationTime.updater = classComponentUpdater),
-              (workInProgress.stateNode = updateExpirationTime),
-              (updateExpirationTime._reactInternalFiber = workInProgress),
-              mountClassInstance(
-                workInProgress,
-                Component,
-                props,
-                renderExpirationTime
-              ),
-              (workInProgress = finishClassComponent(
-                current$$1,
-                workInProgress,
-                Component,
-                !0,
-                resolvedTag,
-                renderExpirationTime
-              )))
-            : ((workInProgress.tag = 0),
-              reconcileChildren(
-                current$$1,
-                workInProgress,
-                updateExpirationTime,
-                renderExpirationTime
-              ),
-              (workInProgress.memoizedProps = props),
-              (workInProgress = workInProgress.child));
+          updateExpirationTime,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        );
+        workInProgress = finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          context,
+          renderExpirationTime$jscomp$0
+        );
+      } else
+        (workInProgress.tag = 0),
+          (value = finishHooks(
+            updateExpirationTime,
+            current$$1,
+            value,
+            context
+          )),
+          reconcileChildren(
+            null,
+            workInProgress,
+            value,
+            renderExpirationTime$jscomp$0
+          ),
+          (workInProgress = workInProgress.child);
       return workInProgress;
+    case 16:
+      value = workInProgress.elementType;
+      null !== current$$1 &&
+        ((current$$1.alternate = null),
+        (workInProgress.alternate = null),
+        (workInProgress.effectTag |= 2));
+      context = workInProgress.pendingProps;
+      current$$1 = readLazyComponentType(value);
+      workInProgress.type = current$$1;
+      value = workInProgress.tag = resolveLazyComponentTag(current$$1);
+      context = resolveDefaultProps(current$$1, context);
+      getDerivedStateFromProps = void 0;
+      switch (value) {
+        case 0:
+          getDerivedStateFromProps = updateFunctionComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 1:
+          getDerivedStateFromProps = updateClassComponent(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 11:
+          getDerivedStateFromProps = updateForwardRef(
+            null,
+            workInProgress,
+            current$$1,
+            context,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        case 14:
+          getDerivedStateFromProps = updateMemoComponent(
+            null,
+            workInProgress,
+            current$$1,
+            resolveDefaultProps(current$$1.type, context),
+            updateExpirationTime,
+            renderExpirationTime$jscomp$0
+          );
+          break;
+        default:
+          invariant(
+            !1,
+            "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.",
+            current$$1
+          );
+      }
+      return getDerivedStateFromProps;
     case 0:
-      return updateFunctionComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateFunctionComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateFunctionComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
-      );
-    case 2:
-      return updateClassComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 3:
+    case 1:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateClassComponent(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateClassComponent(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 5:
+    case 3:
       return (
         pushHostRootContext(workInProgress),
-        (Component = workInProgress.updateQueue),
+        (updateExpirationTime = workInProgress.updateQueue),
         invariant(
-          null !== Component,
+          null !== updateExpirationTime,
           "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
         ),
-        (props = workInProgress.memoizedState),
-        (props = null !== props ? props.element : null),
+        (value = workInProgress.memoizedState),
+        (value = null !== value ? value.element : null),
         processUpdateQueue(
           workInProgress,
-          Component,
+          updateExpirationTime,
           workInProgress.pendingProps,
           null,
-          renderExpirationTime
+          renderExpirationTime$jscomp$0
         ),
-        (Component = workInProgress.memoizedState.element),
-        Component === props
+        (updateExpirationTime = workInProgress.memoizedState.element),
+        updateExpirationTime === value
           ? (workInProgress = bailoutOnAlreadyFinishedWork(
               current$$1,
               workInProgress,
-              renderExpirationTime
+              renderExpirationTime$jscomp$0
             ))
           : (reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
             (workInProgress = workInProgress.child)),
         workInProgress
       );
-    case 7:
+    case 5:
       return (
         pushHostContext(workInProgress),
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
+        (updateExpirationTime = workInProgress.pendingProps.children),
         markRef(current$$1, workInProgress),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         (workInProgress = workInProgress.child),
         workInProgress
       );
-    case 8:
+    case 6:
       return (
         null === current$$1 && tryToClaimNextHydratableInstance(workInProgress),
-        (workInProgress.memoizedProps = workInProgress.pendingProps),
         null
       );
-    case 16:
-      return null;
-    case 6:
+    case 13:
+      return updateSuspenseComponent(
+        current$$1,
+        workInProgress,
+        renderExpirationTime$jscomp$0
+      );
+    case 4:
       return (
         pushHostContainer(
           workInProgress,
           workInProgress.stateNode.containerInfo
         ),
-        (Component = workInProgress.pendingProps),
+        (updateExpirationTime = workInProgress.pendingProps),
         null === current$$1
           ? (workInProgress.child = reconcileChildFibers(
               workInProgress,
               null,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ))
           : reconcileChildren(
               current$$1,
               workInProgress,
-              Component,
-              renderExpirationTime
+              updateExpirationTime,
+              renderExpirationTime$jscomp$0
             ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 13:
-      return updateForwardRef(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderExpirationTime
-      );
-    case 14:
+    case 11:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updateForwardRef(
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        updateForwardRef(
           current$$1,
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        )
       );
-    case 9:
+    case 7:
       return (
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 10:
+    case 8:
       return (
-        (Component = workInProgress.pendingProps.children),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 15:
+    case 12:
       return (
         (workInProgress.effectTag |= 4),
-        (Component = workInProgress.pendingProps),
         reconcileChildren(
           current$$1,
           workInProgress,
-          Component.children,
-          renderExpirationTime
+          workInProgress.pendingProps.children,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 12:
+    case 10:
       a: {
-        Component = workInProgress.type._context;
-        props = workInProgress.pendingProps;
-        resolvedTag = workInProgress.memoizedProps;
-        updateExpirationTime = props.value;
-        workInProgress.memoizedProps = props;
-        pushProvider(workInProgress, updateExpirationTime);
-        if (null !== resolvedTag)
-          if (
-            ((resolvedProps = resolvedTag.value),
-            (updateExpirationTime =
-              (resolvedProps === updateExpirationTime &&
-                (0 !== resolvedProps ||
-                  1 / resolvedProps === 1 / updateExpirationTime)) ||
-              (resolvedProps !== resolvedProps &&
-                updateExpirationTime !== updateExpirationTime)
-                ? 0
-                : ("function" === typeof Component._calculateChangedBits
-                    ? Component._calculateChangedBits(
-                        resolvedProps,
-                        updateExpirationTime
-                      )
-                    : 1073741823) | 0),
-            0 === updateExpirationTime)
-          ) {
+        updateExpirationTime = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        getDerivedStateFromProps = workInProgress.memoizedProps;
+        context = value.value;
+        pushProvider(workInProgress, context);
+        if (null !== getDerivedStateFromProps) {
+          var oldValue = getDerivedStateFromProps.value;
+          context =
+            (oldValue === context &&
+              (0 !== oldValue || 1 / oldValue === 1 / context)) ||
+            (oldValue !== oldValue && context !== context)
+              ? 0
+              : ("function" ===
+                typeof updateExpirationTime._calculateChangedBits
+                  ? updateExpirationTime._calculateChangedBits(
+                      oldValue,
+                      context
+                    )
+                  : 1073741823) | 0;
+          if (0 === context) {
             if (
-              resolvedTag.children === props.children &&
+              getDerivedStateFromProps.children === value.children &&
               !didPerformWorkStackCursor.current
             ) {
               workInProgress = bailoutOnAlreadyFinishedWork(
                 current$$1,
                 workInProgress,
-                renderExpirationTime
+                renderExpirationTime$jscomp$0
               );
               break a;
             }
           } else
             for (
-              resolvedTag = workInProgress.child,
-                null !== resolvedTag && (resolvedTag.return = workInProgress);
-              null !== resolvedTag;
+              getDerivedStateFromProps = workInProgress.child,
+                null !== getDerivedStateFromProps &&
+                  (getDerivedStateFromProps.return = workInProgress);
+              null !== getDerivedStateFromProps;
 
             ) {
-              resolvedProps = resolvedTag.firstContextDependency;
-              if (null !== resolvedProps) {
+              oldValue = getDerivedStateFromProps.firstContextDependency;
+              if (null !== oldValue) {
                 do {
                   if (
-                    resolvedProps.context === Component &&
-                    0 !== (resolvedProps.observedBits & updateExpirationTime)
+                    oldValue.context === updateExpirationTime &&
+                    0 !== (oldValue.observedBits & context)
                   ) {
-                    if (2 === resolvedTag.tag || 3 === resolvedTag.tag)
-                      (child = createUpdate(renderExpirationTime)),
-                        (child.tag = 2),
-                        enqueueUpdate(resolvedTag, child);
-                    if (
-                      0 === resolvedTag.expirationTime ||
-                      resolvedTag.expirationTime > renderExpirationTime
-                    )
-                      resolvedTag.expirationTime = renderExpirationTime;
-                    child = resolvedTag.alternate;
-                    null !== child &&
-                      (0 === child.expirationTime ||
-                        child.expirationTime > renderExpirationTime) &&
-                      (child.expirationTime = renderExpirationTime);
-                    for (var node = resolvedTag.return; null !== node; ) {
-                      child = node.alternate;
+                    if (1 === getDerivedStateFromProps.tag) {
+                      var nextFiber = createUpdate(
+                        renderExpirationTime$jscomp$0
+                      );
+                      nextFiber.tag = 2;
+                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
+                    }
+                    getDerivedStateFromProps.expirationTime <
+                      renderExpirationTime$jscomp$0 &&
+                      (getDerivedStateFromProps.expirationTime = renderExpirationTime$jscomp$0);
+                    nextFiber = getDerivedStateFromProps.alternate;
+                    null !== nextFiber &&
+                      nextFiber.expirationTime <
+                        renderExpirationTime$jscomp$0 &&
+                      (nextFiber.expirationTime = renderExpirationTime$jscomp$0);
+                    for (
+                      var node = getDerivedStateFromProps.return;
+                      null !== node;
+
+                    ) {
+                      nextFiber = node.alternate;
                       if (
-                        0 === node.childExpirationTime ||
-                        node.childExpirationTime > renderExpirationTime
+                        node.childExpirationTime < renderExpirationTime$jscomp$0
                       )
-                        (node.childExpirationTime = renderExpirationTime),
-                          null !== child &&
-                            (0 === child.childExpirationTime ||
-                              child.childExpirationTime >
-                                renderExpirationTime) &&
-                            (child.childExpirationTime = renderExpirationTime);
+                        (node.childExpirationTime = renderExpirationTime$jscomp$0),
+                          null !== nextFiber &&
+                            nextFiber.childExpirationTime <
+                              renderExpirationTime$jscomp$0 &&
+                            (nextFiber.childExpirationTime = renderExpirationTime$jscomp$0);
                       else if (
-                        null !== child &&
-                        (0 === child.childExpirationTime ||
-                          child.childExpirationTime > renderExpirationTime)
+                        null !== nextFiber &&
+                        nextFiber.childExpirationTime <
+                          renderExpirationTime$jscomp$0
                       )
-                        child.childExpirationTime = renderExpirationTime;
+                        nextFiber.childExpirationTime = renderExpirationTime$jscomp$0;
                       else break;
                       node = node.return;
                     }
                   }
-                  child = resolvedTag.child;
-                  resolvedProps = resolvedProps.next;
-                } while (null !== resolvedProps);
+                  nextFiber = getDerivedStateFromProps.child;
+                  oldValue = oldValue.next;
+                } while (null !== oldValue);
               } else
-                child =
-                  12 === resolvedTag.tag
-                    ? resolvedTag.type === workInProgress.type
+                nextFiber =
+                  10 === getDerivedStateFromProps.tag
+                    ? getDerivedStateFromProps.type === workInProgress.type
                       ? null
-                      : resolvedTag.child
-                    : resolvedTag.child;
-              if (null !== child) child.return = resolvedTag;
+                      : getDerivedStateFromProps.child
+                    : getDerivedStateFromProps.child;
+              if (null !== nextFiber)
+                nextFiber.return = getDerivedStateFromProps;
               else
-                for (child = resolvedTag; null !== child; ) {
-                  if (child === workInProgress) {
-                    child = null;
+                for (
+                  nextFiber = getDerivedStateFromProps;
+                  null !== nextFiber;
+
+                ) {
+                  if (nextFiber === workInProgress) {
+                    nextFiber = null;
                     break;
                   }
-                  resolvedTag = child.sibling;
-                  if (null !== resolvedTag) {
-                    resolvedTag.return = child.return;
-                    child = resolvedTag;
+                  getDerivedStateFromProps = nextFiber.sibling;
+                  if (null !== getDerivedStateFromProps) {
+                    getDerivedStateFromProps.return = nextFiber.return;
+                    nextFiber = getDerivedStateFromProps;
                     break;
                   }
-                  child = child.return;
+                  nextFiber = nextFiber.return;
                 }
-              resolvedTag = child;
+              getDerivedStateFromProps = nextFiber;
             }
+        }
         reconcileChildren(
           current$$1,
           workInProgress,
-          props.children,
-          renderExpirationTime
+          value.children,
+          renderExpirationTime$jscomp$0
         );
         workInProgress = workInProgress.child;
       }
       return workInProgress;
-    case 11:
+    case 9:
       return (
-        (updateExpirationTime = workInProgress.type),
-        (Component = workInProgress.pendingProps),
-        (props = Component.children),
-        prepareToReadContext(workInProgress, renderExpirationTime),
-        (updateExpirationTime = readContext(
-          updateExpirationTime,
-          Component.unstable_observedBits
-        )),
-        (props = props(updateExpirationTime)),
+        (value = workInProgress.type),
+        (context = workInProgress.pendingProps),
+        (updateExpirationTime = context.children),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        (value = readContext(value, context.unstable_observedBits)),
+        (updateExpirationTime = updateExpirationTime(value)),
         (workInProgress.effectTag |= 1),
         reconcileChildren(
           current$$1,
           workInProgress,
-          props,
-          renderExpirationTime
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
         ),
-        (workInProgress.memoizedProps = Component),
         workInProgress.child
       );
-    case 17:
-      return updatePureComponent(
+    case 14:
+      return (
+        (value = workInProgress.type),
+        (context = resolveDefaultProps(
+          value.type,
+          workInProgress.pendingProps
+        )),
+        updateMemoComponent(
+          current$$1,
+          workInProgress,
+          value,
+          context,
+          updateExpirationTime,
+          renderExpirationTime$jscomp$0
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
         current$$1,
         workInProgress,
         workInProgress.type,
         workInProgress.pendingProps,
         updateExpirationTime,
-        renderExpirationTime
+        renderExpirationTime$jscomp$0
       );
-    case 18:
+    case 17:
       return (
-        (props = workInProgress.type._reactResult),
-        (Component = workInProgress.pendingProps),
-        (current$$1 = updatePureComponent(
-          current$$1,
+        (updateExpirationTime = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === updateExpirationTime
+            ? value
+            : resolveDefaultProps(updateExpirationTime, value)),
+        null !== current$$1 &&
+          ((current$$1.alternate = null),
+          (workInProgress.alternate = null),
+          (workInProgress.effectTag |= 2)),
+        (workInProgress.tag = 1),
+        isContextProvider(updateExpirationTime)
+          ? ((current$$1 = !0), pushContextProvider(workInProgress))
+          : (current$$1 = !1),
+        prepareToReadContext(workInProgress, renderExpirationTime$jscomp$0),
+        constructClassInstance(
           workInProgress,
-          props,
-          resolveDefaultProps(props, Component),
           updateExpirationTime,
-          renderExpirationTime
-        )),
-        (workInProgress.memoizedProps = Component),
-        current$$1
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        mountClassInstance(
+          workInProgress,
+          updateExpirationTime,
+          value,
+          renderExpirationTime$jscomp$0
+        ),
+        finishClassComponent(
+          null,
+          workInProgress,
+          updateExpirationTime,
+          !0,
+          current$$1,
+          renderExpirationTime$jscomp$0
+        )
       );
     default:
       invariant(
@@ -4336,9 +4854,27 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
-var updateHostContainer = void 0,
+var appendAllChildren = void 0,
+  updateHostContainer = void 0,
   updateHostComponent$1 = void 0,
   updateHostText$1 = void 0;
+appendAllChildren = function(parent, workInProgress) {
+  for (var node = workInProgress.child; null !== node; ) {
+    if (5 === node.tag || 6 === node.tag) parent._children.push(node.stateNode);
+    else if (4 !== node.tag && null !== node.child) {
+      node.child.return = node;
+      node = node.child;
+      continue;
+    }
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+};
 updateHostContainer = function() {};
 updateHostComponent$1 = function(current, workInProgress, type, newProps) {
   current.memoizedProps !== newProps &&
@@ -4384,7 +4920,7 @@ function logError(boundary, errorInfo) {
     willRetry: !1
   };
   null !== boundary &&
-    2 === boundary.tag &&
+    1 === boundary.tag &&
     ((errorInfo.errorBoundary = boundary.stateNode),
     (errorInfo.errorBoundaryName = getComponentName(boundary.type)),
     (errorInfo.errorBoundaryFound = !0),
@@ -4408,32 +4944,75 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
-function commitUnmount(current$$1) {
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if (0 !== (effect.tag & unmountTag)) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      0 !== (effect.tag & mountTag) &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function commitUnmount(current$$1$jscomp$0) {
   "function" === typeof onCommitFiberUnmount &&
-    onCommitFiberUnmount(current$$1);
-  switch (current$$1.tag) {
-    case 2:
-    case 3:
-      safelyDetachRef(current$$1);
-      var instance = current$$1.stateNode;
-      if ("function" === typeof instance.componentWillUnmount)
+    onCommitFiberUnmount(current$$1$jscomp$0);
+  switch (current$$1$jscomp$0.tag) {
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      var updateQueue = current$$1$jscomp$0.updateQueue;
+      if (
+        null !== updateQueue &&
+        ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
+      ) {
+        var effect = (updateQueue = updateQueue.next);
+        do {
+          var destroy = effect.destroy;
+          if (null !== destroy) {
+            var current$$1 = current$$1$jscomp$0;
+            try {
+              destroy();
+            } catch (error) {
+              captureCommitPhaseError(current$$1, error);
+            }
+          }
+          effect = effect.next;
+        } while (effect !== updateQueue);
+      }
+      break;
+    case 1:
+      safelyDetachRef(current$$1$jscomp$0);
+      updateQueue = current$$1$jscomp$0.stateNode;
+      if ("function" === typeof updateQueue.componentWillUnmount)
         try {
-          (instance.props = current$$1.memoizedProps),
-            (instance.state = current$$1.memoizedState),
-            instance.componentWillUnmount();
+          (updateQueue.props = current$$1$jscomp$0.memoizedProps),
+            (updateQueue.state = current$$1$jscomp$0.memoizedState),
+            updateQueue.componentWillUnmount();
         } catch (unmountError) {
-          captureCommitPhaseError(current$$1, unmountError);
+          captureCommitPhaseError(current$$1$jscomp$0, unmountError);
         }
       break;
-    case 7:
-      safelyDetachRef(current$$1);
+    case 5:
+      safelyDetachRef(current$$1$jscomp$0);
       break;
-    case 6:
-      unmountHostComponents(current$$1);
+    case 4:
+      unmountHostComponents(current$$1$jscomp$0);
   }
 }
 function isHostParent(fiber) {
-  return 7 === fiber.tag || 5 === fiber.tag || 6 === fiber.tag;
+  return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
 }
 function commitPlacement(finishedWork) {
   a: {
@@ -4452,15 +5031,15 @@ function commitPlacement(finishedWork) {
   }
   var isContainer = (parent = void 0);
   switch (parentFiber.tag) {
-    case 7:
+    case 5:
       parent = parentFiber.stateNode;
       isContainer = !1;
       break;
-    case 5:
+    case 3:
       parent = parentFiber.stateNode.containerInfo;
       isContainer = !0;
       break;
-    case 6:
+    case 4:
       parent = parentFiber.stateNode.containerInfo;
       isContainer = !0;
       break;
@@ -4482,11 +5061,11 @@ function commitPlacement(finishedWork) {
     parentFiber.sibling.return = parentFiber.return;
     for (
       parentFiber = parentFiber.sibling;
-      7 !== parentFiber.tag && 8 !== parentFiber.tag;
+      5 !== parentFiber.tag && 6 !== parentFiber.tag;
 
     ) {
       if (parentFiber.effectTag & 2) continue b;
-      if (null === parentFiber.child || 6 === parentFiber.tag) continue b;
+      if (null === parentFiber.child || 4 === parentFiber.tag) continue b;
       else
         (parentFiber.child.return = parentFiber),
           (parentFiber = parentFiber.child);
@@ -4497,7 +5076,7 @@ function commitPlacement(finishedWork) {
     }
   }
   for (var node = finishedWork; ; ) {
-    if (7 === node.tag || 8 === node.tag)
+    if (5 === node.tag || 6 === node.tag)
       if (parentFiber)
         if (isContainer)
           invariant(
@@ -4566,7 +5145,7 @@ function commitPlacement(finishedWork) {
                   [index.length - 1],
                   []
                 )));
-    else if (6 !== node.tag && null !== node.child) {
+    else if (4 !== node.tag && null !== node.child) {
       node.child.return = node;
       node = node.child;
       continue;
@@ -4597,15 +5176,15 @@ function unmountHostComponents(current$$1) {
           "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
         );
         switch (currentParentIsValid.tag) {
-          case 7:
+          case 5:
             currentParent = currentParentIsValid.stateNode;
             currentParentIsContainer = !1;
             break a;
-          case 5:
+          case 3:
             currentParent = currentParentIsValid.stateNode.containerInfo;
             currentParentIsContainer = !0;
             break a;
-          case 6:
+          case 4:
             currentParent = currentParentIsValid.stateNode.containerInfo;
             currentParentIsContainer = !0;
             break a;
@@ -4614,11 +5193,11 @@ function unmountHostComponents(current$$1) {
       }
       currentParentIsValid = !0;
     }
-    if (7 === node.tag || 8 === node.tag) {
+    if (5 === node.tag || 6 === node.tag) {
       a: for (var root = node, node$jscomp$0 = root; ; )
         if (
           (commitUnmount(node$jscomp$0),
-          null !== node$jscomp$0.child && 6 !== node$jscomp$0.tag)
+          null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag)
         )
           (node$jscomp$0.child.return = node$jscomp$0),
             (node$jscomp$0 = node$jscomp$0.child);
@@ -4646,7 +5225,7 @@ function unmountHostComponents(current$$1) {
         UIManager.manageChildren(root._nativeTag, [], [], [], [], [child]);
       }
     } else if (
-      (6 === node.tag
+      (4 === node.tag
         ? ((currentParent = node.stateNode.containerInfo),
           (currentParentIsContainer = !0))
         : commitUnmount(node),
@@ -4660,7 +5239,7 @@ function unmountHostComponents(current$$1) {
     for (; null === node.sibling; ) {
       if (null === node.return || node.return === current$$1) return;
       node = node.return;
-      6 === node.tag && (currentParentIsValid = !1);
+      4 === node.tag && (currentParentIsValid = !1);
     }
     node.sibling.return = node.return;
     node = node.sibling;
@@ -4668,10 +5247,15 @@ function unmountHostComponents(current$$1) {
 }
 function commitWork(current$$1, finishedWork) {
   switch (finishedWork.tag) {
-    case 2:
-    case 3:
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      commitHookEffectList(4, 8, finishedWork);
       break;
-    case 7:
+    case 1:
+      break;
+    case 5:
       var instance = finishedWork.stateNode;
       if (null != instance) {
         var newProps = finishedWork.memoizedProps;
@@ -4695,7 +5279,7 @@ function commitWork(current$$1, finishedWork) {
             ));
       }
       break;
-    case 8:
+    case 6:
       invariant(
         null !== finishedWork.stateNode,
         "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
@@ -4704,11 +5288,78 @@ function commitWork(current$$1, finishedWork) {
         text: finishedWork.memoizedProps
       });
       break;
-    case 5:
+    case 3:
       break;
-    case 15:
+    case 12:
       break;
-    case 16:
+    case 13:
+      newProps = finishedWork.memoizedState;
+      current$$1 = finishedWork;
+      null === newProps
+        ? (instance = !1)
+        : ((instance = !0),
+          (current$$1 = finishedWork.child),
+          0 === newProps.timedOutAt &&
+            (newProps.timedOutAt = requestCurrentTime()));
+      if (null !== current$$1)
+        a: for (newProps = finishedWork = current$$1; ; ) {
+          if (5 === newProps.tag)
+            if (((current$$1 = newProps.stateNode), instance)) {
+              updatePayload = current$$1.viewConfig;
+              var updatePayload$jscomp$0 = diffProperties(
+                null,
+                emptyObject,
+                { style: { display: "none" } },
+                updatePayload.validAttributes
+              );
+              UIManager.updateView(
+                current$$1._nativeTag,
+                updatePayload.uiViewClassName,
+                updatePayload$jscomp$0
+              );
+            } else {
+              current$$1 = newProps.stateNode;
+              updatePayload$jscomp$0 = newProps.memoizedProps;
+              updatePayload = current$$1.viewConfig;
+              var prevProps = Object.assign({}, updatePayload$jscomp$0, {
+                style: [updatePayload$jscomp$0.style, { display: "none" }]
+              });
+              updatePayload$jscomp$0 = diffProperties(
+                null,
+                prevProps,
+                updatePayload$jscomp$0,
+                updatePayload.validAttributes
+              );
+              UIManager.updateView(
+                current$$1._nativeTag,
+                updatePayload.uiViewClassName,
+                updatePayload$jscomp$0
+              );
+            }
+          else {
+            if (6 === newProps.tag) throw Error("Not yet implemented.");
+            if (13 === newProps.tag && null !== newProps.memoizedState) {
+              current$$1 = newProps.child.sibling;
+              current$$1.return = newProps;
+              newProps = current$$1;
+              continue;
+            } else if (null !== newProps.child) {
+              newProps.child.return = newProps;
+              newProps = newProps.child;
+              continue;
+            }
+          }
+          if (newProps === finishedWork) break a;
+          for (; null === newProps.sibling; ) {
+            if (null === newProps.return || newProps.return === finishedWork)
+              break a;
+            newProps = newProps.return;
+          }
+          newProps.sibling.return = newProps.return;
+          newProps = newProps.sibling;
+        }
+      break;
+    case 17:
       break;
     default:
       invariant(
@@ -4762,41 +5413,121 @@ function throwException(
   value,
   renderExpirationTime
 ) {
-  sourceFiber.effectTag |= 512;
+  sourceFiber.effectTag |= 1024;
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+  if (
+    null !== value &&
+    "object" === typeof value &&
+    "function" === typeof value.then
+  ) {
+    var thenable = value;
+    value = returnFiber;
+    var earliestTimeoutMs = -1,
+      startTimeMs = -1;
+    do {
+      if (13 === value.tag) {
+        var current$$1 = value.alternate;
+        if (
+          null !== current$$1 &&
+          ((current$$1 = current$$1.memoizedState), null !== current$$1)
+        ) {
+          startTimeMs = 10 * (1073741822 - current$$1.timedOutAt);
+          break;
+        }
+        current$$1 = value.pendingProps.maxDuration;
+        if ("number" === typeof current$$1)
+          if (0 >= current$$1) earliestTimeoutMs = 0;
+          else if (-1 === earliestTimeoutMs || current$$1 < earliestTimeoutMs)
+            earliestTimeoutMs = current$$1;
+      }
+      value = value.return;
+    } while (null !== value);
+    value = returnFiber;
+    do {
+      if ((current$$1 = 13 === value.tag))
+        current$$1 =
+          void 0 === value.memoizedProps.fallback
+            ? !1
+            : null === value.memoizedState;
+      if (current$$1) {
+        returnFiber = retrySuspendedRoot.bind(
+          null,
+          root,
+          value,
+          sourceFiber,
+          0 === (value.mode & 1) ? 1073741823 : renderExpirationTime
+        );
+        returnFiber = tracing.unstable_wrap(returnFiber);
+        thenable.then(returnFiber, returnFiber);
+        if (0 === (value.mode & 1)) {
+          value.effectTag |= 64;
+          sourceFiber.effectTag &= -1957;
+          1 === sourceFiber.tag &&
+            null === sourceFiber.alternate &&
+            (sourceFiber.tag = 17);
+          sourceFiber.expirationTime = renderExpirationTime;
+          return;
+        }
+        -1 === earliestTimeoutMs
+          ? (root = 1073741823)
+          : (-1 === startTimeMs &&
+              (startTimeMs =
+                10 *
+                  (1073741822 -
+                    findEarliestOutstandingPriorityLevel(
+                      root,
+                      renderExpirationTime
+                    )) -
+                5e3),
+            (root = startTimeMs + earliestTimeoutMs));
+        0 <= root &&
+          nextLatestAbsoluteTimeoutMs < root &&
+          (nextLatestAbsoluteTimeoutMs = root);
+        value.effectTag |= 2048;
+        value.expirationTime = renderExpirationTime;
+        return;
+      }
+      value = value.return;
+    } while (null !== value);
+    value = Error(
+      (getComponentName(sourceFiber.type) || "A React component") +
+        " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
+        getStackByFiberInDevAndProd(sourceFiber)
+    );
+  }
   nextRenderDidError = !0;
   value = createCapturedValue(value, sourceFiber);
   root = returnFiber;
   do {
     switch (root.tag) {
-      case 5:
-        root.effectTag |= 1024;
+      case 3:
+        sourceFiber = value;
+        root.effectTag |= 2048;
         root.expirationTime = renderExpirationTime;
         renderExpirationTime = createRootErrorUpdate(
           root,
-          value,
+          sourceFiber,
           renderExpirationTime
         );
         enqueueCapturedUpdate(root, renderExpirationTime);
         return;
-      case 2:
-      case 3:
-        returnFiber = value;
-        sourceFiber = root.type;
-        var instance = root.stateNode;
+      case 1:
         if (
+          ((sourceFiber = value),
+          (returnFiber = root.type),
+          (thenable = root.stateNode),
           0 === (root.effectTag & 64) &&
-          ("function" === typeof sourceFiber.getDerivedStateFromError ||
-            (null !== instance &&
-              "function" === typeof instance.componentDidCatch &&
-              (null === legacyErrorBoundariesThatAlreadyFailed ||
-                !legacyErrorBoundariesThatAlreadyFailed.has(instance))))
+            ("function" === typeof returnFiber.getDerivedStateFromError ||
+              (null !== thenable &&
+                "function" === typeof thenable.componentDidCatch &&
+                (null === legacyErrorBoundariesThatAlreadyFailed ||
+                  !legacyErrorBoundariesThatAlreadyFailed.has(thenable)))))
         ) {
-          root.effectTag |= 1024;
+          root.effectTag |= 2048;
           root.expirationTime = renderExpirationTime;
           renderExpirationTime = createClassErrorUpdate(
             root,
-            returnFiber,
+            sourceFiber,
             renderExpirationTime
           );
           enqueueCapturedUpdate(root, renderExpirationTime);
@@ -4808,24 +5539,14 @@ function throwException(
 }
 function unwindWork(workInProgress) {
   switch (workInProgress.tag) {
-    case 2:
+    case 1:
       isContextProvider(workInProgress.type) && popContext(workInProgress);
       var effectTag = workInProgress.effectTag;
-      return effectTag & 1024
-        ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+      return effectTag & 2048
+        ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
           workInProgress)
         : null;
     case 3:
-      return (
-        isContextProvider(workInProgress.type._reactResult) &&
-          popContext(workInProgress),
-        (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
-            workInProgress)
-          : null
-      );
-    case 5:
       return (
         popHostContainer(workInProgress),
         popTopLevelContextObject(workInProgress),
@@ -4834,41 +5555,122 @@ function unwindWork(workInProgress) {
           0 === (effectTag & 64),
           "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
         ),
-        (workInProgress.effectTag = (effectTag & -1025) | 64),
+        (workInProgress.effectTag = (effectTag & -2049) | 64),
         workInProgress
       );
-    case 7:
+    case 5:
       return popHostContext(workInProgress), null;
-    case 16:
+    case 13:
       return (
         (effectTag = workInProgress.effectTag),
-        effectTag & 1024
-          ? ((workInProgress.effectTag = (effectTag & -1025) | 64),
+        effectTag & 2048
+          ? ((workInProgress.effectTag = (effectTag & -2049) | 64),
             workInProgress)
           : null
       );
-    case 6:
+    case 4:
       return popHostContainer(workInProgress), null;
-    case 12:
+    case 10:
       return popProvider(workInProgress), null;
     default:
       return null;
   }
 }
-var Dispatcher = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [callback];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, inputs];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, inputs) {
+      useEffectImpl(516, 192, create, inputs);
+    },
+    useImperativeMethods: function(ref, create, inputs) {
+      inputs =
+        null !== inputs && void 0 !== inputs
+          ? inputs.concat([ref])
+          : [ref, create];
+      useEffectImpl(
+        4,
+        36,
+        function() {
+          if ("function" === typeof ref) {
+            var _inst = create();
+            ref(_inst);
+            return function() {
+              return ref(null);
+            };
+          }
+          if (null !== ref && void 0 !== ref)
+            return (
+              (_inst = create()),
+              (ref.current = _inst),
+              function() {
+                ref.current = null;
+              }
+            );
+        },
+        inputs
+      );
+    },
+    useLayoutEffect: function(create, inputs) {
+      useEffectImpl(4, 36, create, inputs);
+    },
+    useMemo: function(nextCreate, inputs) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      inputs = void 0 !== inputs && null !== inputs ? inputs : [nextCreate];
+      var prevState = workInProgressHook.memoizedState;
+      if (null !== prevState && areHookInputsEqual(inputs, prevState[1]))
+        return prevState[0];
+      nextCreate = nextCreate();
+      workInProgressHook.memoizedState = [nextCreate, inputs];
+      return nextCreate;
+    },
+    useMutationEffect: function(create, inputs) {
+      useEffectImpl(260, 10, create, inputs);
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
 invariant(
   null != tracing.__interactionsRef &&
     null != tracing.__interactionsRef.current,
-  "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"
+  "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"
 );
 var isWorking = !1,
   nextUnitOfWork = null,
   nextRoot = null,
   nextRenderExpirationTime = 0,
+  nextLatestAbsoluteTimeoutMs = -1,
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
+  passiveEffectCallbackHandle = null,
+  passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
 function resetStack() {
   if (null !== nextUnitOfWork)
@@ -4879,7 +5681,7 @@ function resetStack() {
     ) {
       var interruptedWork$jscomp$0 = interruptedWork;
       switch (interruptedWork$jscomp$0.tag) {
-        case 2:
+        case 1:
           var childContextTypes =
             interruptedWork$jscomp$0.type.childContextTypes;
           null !== childContextTypes &&
@@ -4887,29 +5689,23 @@ function resetStack() {
             popContext(interruptedWork$jscomp$0);
           break;
         case 3:
-          childContextTypes =
-            interruptedWork$jscomp$0.type._reactResult.childContextTypes;
-          null !== childContextTypes &&
-            void 0 !== childContextTypes &&
-            popContext(interruptedWork$jscomp$0);
-          break;
-        case 5:
           popHostContainer(interruptedWork$jscomp$0);
           popTopLevelContextObject(interruptedWork$jscomp$0);
           break;
-        case 7:
+        case 5:
           popHostContext(interruptedWork$jscomp$0);
           break;
-        case 6:
+        case 4:
           popHostContainer(interruptedWork$jscomp$0);
           break;
-        case 12:
+        case 10:
           popProvider(interruptedWork$jscomp$0);
       }
       interruptedWork = interruptedWork.return;
     }
   nextRoot = null;
   nextRenderExpirationTime = 0;
+  nextLatestAbsoluteTimeoutMs = -1;
   nextRenderDidError = !1;
   nextUnitOfWork = null;
 }
@@ -4952,30 +5748,35 @@ function commitAllHostEffects() {
 }
 function commitBeforeMutationLifecycles() {
   for (; null !== nextEffect; ) {
-    if (nextEffect.effectTag & 256) {
-      var current$$1 = nextEffect.alternate;
+    if (nextEffect.effectTag & 256)
       a: {
-        var finishedWork = nextEffect;
+        var current$$1 = nextEffect.alternate,
+          finishedWork = nextEffect;
         switch (finishedWork.tag) {
-          case 2:
-          case 3:
+          case 0:
+          case 11:
+          case 15:
+            commitHookEffectList(2, 0, finishedWork);
+            break a;
+          case 1:
             if (finishedWork.effectTag & 256 && null !== current$$1) {
               var prevProps = current$$1.memoizedProps,
                 prevState = current$$1.memoizedState;
               current$$1 = finishedWork.stateNode;
-              current$$1.props = finishedWork.memoizedProps;
-              current$$1.state = finishedWork.memoizedState;
               finishedWork = current$$1.getSnapshotBeforeUpdate(
-                prevProps,
+                finishedWork.elementType === finishedWork.type
+                  ? prevProps
+                  : resolveDefaultProps(finishedWork.type, prevProps),
                 prevState
               );
               current$$1.__reactInternalSnapshotBeforeUpdate = finishedWork;
             }
             break a;
+          case 3:
           case 5:
-          case 7:
-          case 8:
           case 6:
+          case 4:
+          case 17:
             break a;
           default:
             invariant(
@@ -4984,7 +5785,6 @@ function commitBeforeMutationLifecycles() {
             );
         }
       }
-    }
     nextEffect = nextEffect.nextEffect;
   }
 }
@@ -5000,47 +5800,48 @@ function commitAllLifeCycles(
         finishedWork = nextEffect,
         committedExpirationTime = committedExpirationTime$jscomp$0;
       switch (finishedWork.tag) {
-        case 2:
-        case 3:
+        case 0:
+        case 11:
+        case 15:
+          commitHookEffectList(16, 32, finishedWork);
+          break;
+        case 1:
           finishedRoot = finishedWork.stateNode;
           if (finishedWork.effectTag & 4)
-            if (null === current$$1)
-              (finishedRoot.props = finishedWork.memoizedProps),
-                (finishedRoot.state = finishedWork.memoizedState),
-                finishedRoot.componentDidMount();
+            if (null === current$$1) finishedRoot.componentDidMount();
             else {
-              var prevProps = current$$1.memoizedProps;
-              current$$1 = current$$1.memoizedState;
-              finishedRoot.props = finishedWork.memoizedProps;
-              finishedRoot.state = finishedWork.memoizedState;
+              var prevProps =
+                finishedWork.elementType === finishedWork.type
+                  ? current$$1.memoizedProps
+                  : resolveDefaultProps(
+                      finishedWork.type,
+                      current$$1.memoizedProps
+                    );
               finishedRoot.componentDidUpdate(
                 prevProps,
-                current$$1,
+                current$$1.memoizedState,
                 finishedRoot.__reactInternalSnapshotBeforeUpdate
               );
             }
           current$$1 = finishedWork.updateQueue;
           null !== current$$1 &&
-            ((finishedRoot.props = finishedWork.memoizedProps),
-            (finishedRoot.state = finishedWork.memoizedState),
             commitUpdateQueue(
               finishedWork,
               current$$1,
               finishedRoot,
               committedExpirationTime
-            ));
+            );
           break;
-        case 5:
+        case 3:
           current$$1 = finishedWork.updateQueue;
           if (null !== current$$1) {
             finishedRoot = null;
             if (null !== finishedWork.child)
               switch (finishedWork.child.tag) {
-                case 7:
+                case 5:
                   finishedRoot = finishedWork.child.stateNode;
                   break;
-                case 2:
-                case 3:
+                case 1:
                   finishedRoot = finishedWork.child.stateNode;
               }
             commitUpdateQueue(
@@ -5051,13 +5852,13 @@ function commitAllLifeCycles(
             );
           }
           break;
-        case 7:
-          break;
-        case 8:
+        case 5:
           break;
         case 6:
           break;
-        case 15:
+        case 4:
+          break;
+        case 12:
           committedExpirationTime = finishedWork.memoizedProps.onRender;
           committedExpirationTime(
             finishedWork.memoizedProps.id,
@@ -5069,7 +5870,9 @@ function commitAllLifeCycles(
             finishedRoot.memoizedInteractions
           );
           break;
-        case 16:
+        case 13:
+          break;
+        case 17:
           break;
         default:
           invariant(
@@ -5079,17 +5882,44 @@ function commitAllLifeCycles(
       }
     }
     effectTag & 128 &&
-      ((effectTag = nextEffect.ref),
-      null !== effectTag &&
-        ((finishedWork = nextEffect.stateNode),
-        "function" === typeof effectTag
-          ? effectTag(finishedWork)
-          : (effectTag.current = finishedWork)));
-    effectTag = nextEffect.nextEffect;
-    nextEffect.nextEffect = null;
-    nextEffect = effectTag;
+      ((finishedWork = nextEffect.ref),
+      null !== finishedWork &&
+        ((committedExpirationTime = nextEffect.stateNode),
+        "function" === typeof finishedWork
+          ? finishedWork(committedExpirationTime)
+          : (finishedWork.current = committedExpirationTime)));
+    effectTag & 512 && (rootWithPendingPassiveEffects = finishedRoot$jscomp$0);
+    nextEffect = nextEffect.nextEffect;
   }
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(128, 0, finishedWork);
+        commitHookEffectList(0, 64, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
+function flushPassiveEffects() {
+  null !== passiveEffectCallback &&
+    (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
+    passiveEffectCallback());
+}
 function commitRoot(root, finishedWork) {
   isCommitting$1 = isWorking = !0;
   invariant(
@@ -5106,9 +5936,7 @@ function commitRoot(root, finishedWork) {
     childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
   markCommittedPriorityLevels(
     root,
-    0 === updateExpirationTimeBeforeCommit ||
-    (0 !== childExpirationTimeBeforeCommit &&
-      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit)
+    childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit
       ? childExpirationTimeBeforeCommit
       : updateExpirationTimeBeforeCommit
   );
@@ -5158,29 +5986,42 @@ function commitRoot(root, finishedWork) {
   }
   root.current = finishedWork;
   for (nextEffect = childExpirationTimeBeforeCommit; null !== nextEffect; ) {
-    childExpirationTimeBeforeCommit = !1;
-    didError = void 0;
+    didError = !1;
+    error$jscomp$0 = void 0;
     try {
       commitAllLifeCycles(root, committedExpirationTime);
     } catch (e) {
-      (childExpirationTimeBeforeCommit = !0), (didError = e);
+      (didError = !0), (error$jscomp$0 = e);
     }
-    childExpirationTimeBeforeCommit &&
+    didError &&
       (invariant(
         null !== nextEffect,
         "Should have next effect. This error is likely caused by a bug in React. Please file an issue."
       ),
-      captureCommitPhaseError(nextEffect, didError),
+      captureCommitPhaseError(nextEffect, error$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== childExpirationTimeBeforeCommit &&
+    null !== rootWithPendingPassiveEffects &&
+    ((childExpirationTimeBeforeCommit = commitPassiveEffects.bind(
+      null,
+      root,
+      childExpirationTimeBeforeCommit
+    )),
+    (childExpirationTimeBeforeCommit = tracing.unstable_wrap(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallback = childExpirationTimeBeforeCommit));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork.stateNode);
   childExpirationTimeBeforeCommit = finishedWork.expirationTime;
   finishedWork = finishedWork.childExpirationTime;
   var earliestRemainingTimeAfterCommit =
-    0 === childExpirationTimeBeforeCommit ||
-    (0 !== finishedWork && finishedWork < childExpirationTimeBeforeCommit)
+    finishedWork > childExpirationTimeBeforeCommit
       ? finishedWork
       : childExpirationTimeBeforeCommit;
   0 === earliestRemainingTimeAfterCommit &&
@@ -5205,21 +6046,18 @@ function commitRoot(root, finishedWork) {
       scheduledInteractions,
       scheduledExpirationTime
     ) {
-      if (
-        0 === earliestRemainingTimeAfterCommit ||
-        scheduledExpirationTime < earliestRemainingTimeAfterCommit
-      )
-        pendingInteractionMap.delete(scheduledExpirationTime),
-          scheduledInteractions.forEach(function(interaction) {
-            interaction.__count--;
-            if (null !== subscriber && 0 === interaction.__count)
-              try {
-                subscriber.onInteractionScheduledWorkCompleted(interaction);
-              } catch (error) {
-                hasUnhandledError ||
-                  ((hasUnhandledError = !0), (unhandledError = error));
-              }
-          });
+      scheduledExpirationTime > earliestRemainingTimeAfterCommit &&
+        (pendingInteractionMap.delete(scheduledExpirationTime),
+        scheduledInteractions.forEach(function(interaction) {
+          interaction.__count--;
+          if (null !== subscriber && 0 === interaction.__count)
+            try {
+              subscriber.onInteractionScheduledWorkCompleted(interaction);
+            } catch (error) {
+              hasUnhandledError ||
+                ((hasUnhandledError = !0), (unhandledError = error));
+            }
+        }));
     });
   }
 }
@@ -5228,228 +6066,225 @@ function completeUnitOfWork(workInProgress) {
     var current$$1 = workInProgress.alternate,
       returnFiber = workInProgress.return,
       siblingFiber = workInProgress.sibling;
-    if (0 === (workInProgress.effectTag & 512)) {
+    if (0 === (workInProgress.effectTag & 1024)) {
+      nextUnitOfWork = workInProgress;
       if (workInProgress.mode & 4) {
         var fiber = workInProgress;
         profilerStartTime = now$1();
         0 > fiber.actualStartTime && (fiber.actualStartTime = now$1());
       }
-      var current = current$$1;
-      current$$1 = workInProgress;
-      fiber = current$$1.pendingProps;
-      switch (current$$1.tag) {
-        case 0:
-        case 1:
-          break;
-        case 2:
-          isContextProvider(current$$1.type) && popContext(current$$1);
-          break;
-        case 3:
-          isContextProvider(current$$1.type._reactResult) &&
-            popContext(current$$1);
-          break;
-        case 5:
-          popHostContainer(current$$1);
-          popTopLevelContextObject(current$$1);
-          fiber = current$$1.stateNode;
-          fiber.pendingContext &&
-            ((fiber.context = fiber.pendingContext),
-            (fiber.pendingContext = null));
-          if (null === current || null === current.child)
-            current$$1.effectTag &= -3;
-          updateHostContainer(current$$1);
-          break;
-        case 7:
-          popHostContext(current$$1);
-          var rootContainerInstance = requiredContext(
+      a: {
+        var current = current$$1;
+        current$$1 = workInProgress;
+        var renderExpirationTime = nextRenderExpirationTime;
+        fiber = current$$1.pendingProps;
+        switch (current$$1.tag) {
+          case 2:
+            break;
+          case 16:
+            break;
+          case 15:
+          case 0:
+            break;
+          case 1:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          case 3:
+            popHostContainer(current$$1);
+            popTopLevelContextObject(current$$1);
+            fiber = current$$1.stateNode;
+            fiber.pendingContext &&
+              ((fiber.context = fiber.pendingContext),
+              (fiber.pendingContext = null));
+            if (null === current || null === current.child)
+              current$$1.effectTag &= -3;
+            updateHostContainer(current$$1);
+            break;
+          case 5:
+            popHostContext(current$$1);
+            renderExpirationTime = requiredContext(
               rootInstanceStackCursor.current
-            ),
-            type = current$$1.type;
-          if (null !== current && null != current$$1.stateNode)
-            updateHostComponent$1(
-              current,
-              current$$1,
-              type,
-              fiber,
-              rootContainerInstance
-            ),
-              current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
-          else if (fiber) {
-            current = requiredContext(contextStackCursor$1.current);
-            var internalInstanceHandle = current$$1,
-              tag = allocateTag(),
-              viewConfig = ReactNativeViewConfigRegistry.get(type);
-            invariant(
-              "RCTView" !== type || !current.isInAParentText,
-              "Nesting of <View> within <Text> is not currently supported."
-            );
-            var updatePayload = diffProperties(
-              null,
-              emptyObject,
-              fiber,
-              viewConfig.validAttributes
-            );
-            UIManager.createView(
-              tag,
-              viewConfig.uiViewClassName,
-              rootContainerInstance,
-              updatePayload
-            );
-            viewConfig = new ReactNativeFiberHostComponent(tag, viewConfig);
-            instanceCache[tag] = internalInstanceHandle;
-            instanceProps[tag] = fiber;
-            a: for (
-              internalInstanceHandle = viewConfig,
-                tag = current$$1,
-                updatePayload = tag.child;
-              null !== updatePayload;
-
-            ) {
-              if (7 === updatePayload.tag || 8 === updatePayload.tag)
-                internalInstanceHandle._children.push(updatePayload.stateNode);
-              else if (
-                6 !== updatePayload.tag &&
-                null !== updatePayload.child
-              ) {
-                updatePayload.child.return = updatePayload;
-                updatePayload = updatePayload.child;
-                continue;
-              }
-              if (updatePayload === tag) break;
-              for (; null === updatePayload.sibling; ) {
-                if (
-                  null === updatePayload.return ||
-                  updatePayload.return === tag
-                )
-                  break a;
-                updatePayload = updatePayload.return;
-              }
-              updatePayload.sibling.return = updatePayload.return;
-              updatePayload = updatePayload.sibling;
-            }
-            finalizeInitialChildren(
-              viewConfig,
-              type,
-              fiber,
-              rootContainerInstance,
-              current
-            ) && (current$$1.effectTag |= 4);
-            current$$1.stateNode = viewConfig;
-            null !== current$$1.ref && (current$$1.effectTag |= 128);
-          } else
-            invariant(
-              null !== current$$1.stateNode,
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
             );
-          break;
-        case 8:
-          current && null != current$$1.stateNode
-            ? updateHostText$1(
+            var type = current$$1.type;
+            if (null !== current && null != current$$1.stateNode)
+              updateHostComponent$1(
                 current,
                 current$$1,
-                current.memoizedProps,
-                fiber
-              )
-            : ("string" !== typeof fiber &&
+                type,
+                fiber,
+                renderExpirationTime
+              ),
+                current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
+            else if (fiber) {
+              current = requiredContext(contextStackCursor$1.current);
+              var internalInstanceHandle = current$$1,
+                tag = allocateTag(),
+                viewConfig = ReactNativeViewConfigRegistry.get(type);
+              invariant(
+                "RCTView" !== type || !current.isInAParentText,
+                "Nesting of <View> within <Text> is not currently supported."
+              );
+              var updatePayload = diffProperties(
+                null,
+                emptyObject,
+                fiber,
+                viewConfig.validAttributes
+              );
+              UIManager.createView(
+                tag,
+                viewConfig.uiViewClassName,
+                renderExpirationTime,
+                updatePayload
+              );
+              viewConfig = new ReactNativeFiberHostComponent(tag, viewConfig);
+              instanceCache[tag] = internalInstanceHandle;
+              instanceProps[tag] = fiber;
+              appendAllChildren(viewConfig, current$$1, !1, !1);
+              finalizeInitialChildren(
+                viewConfig,
+                type,
+                fiber,
+                renderExpirationTime,
+                current
+              ) && (current$$1.effectTag |= 4);
+              current$$1.stateNode = viewConfig;
+              null !== current$$1.ref && (current$$1.effectTag |= 128);
+            } else
+              invariant(
+                null !== current$$1.stateNode,
+                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+              );
+            break;
+          case 6:
+            current && null != current$$1.stateNode
+              ? updateHostText$1(
+                  current,
+                  current$$1,
+                  current.memoizedProps,
+                  fiber
+                )
+              : ("string" !== typeof fiber &&
+                  invariant(
+                    null !== current$$1.stateNode,
+                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                  ),
+                (current = requiredContext(rootInstanceStackCursor.current)),
+                (type = requiredContext(contextStackCursor$1.current)),
+                (renderExpirationTime = current$$1),
                 invariant(
-                  null !== current$$1.stateNode,
-                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                  type.isInAParentText,
+                  "Text strings must be rendered within a <Text> component."
                 ),
-              (current = requiredContext(rootInstanceStackCursor.current)),
-              (type = requiredContext(contextStackCursor$1.current)),
-              (rootContainerInstance = current$$1),
-              invariant(
-                type.isInAParentText,
-                "Text strings must be rendered within a <Text> component."
-              ),
-              (type = allocateTag()),
-              UIManager.createView(type, "RCTRawText", current, {
-                text: fiber
-              }),
-              (instanceCache[type] = current$$1),
-              (rootContainerInstance.stateNode = type));
-          break;
-        case 13:
-        case 14:
-          break;
-        case 16:
-          break;
-        case 9:
-          break;
-        case 10:
-          break;
-        case 15:
-          break;
-        case 6:
-          popHostContainer(current$$1);
-          updateHostContainer(current$$1);
-          break;
-        case 12:
-          popProvider(current$$1);
-          break;
-        case 11:
-          break;
-        case 17:
-        case 18:
-          break;
-        case 4:
-          invariant(
-            !1,
-            "An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue."
-          );
-        default:
-          invariant(
-            !1,
-            "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
-          );
+                (type = allocateTag()),
+                UIManager.createView(type, "RCTRawText", current, {
+                  text: fiber
+                }),
+                (instanceCache[type] = current$$1),
+                (renderExpirationTime.stateNode = type));
+            break;
+          case 11:
+            break;
+          case 13:
+            fiber = current$$1.memoizedState;
+            if (0 !== (current$$1.effectTag & 64)) {
+              current$$1.expirationTime = renderExpirationTime;
+              nextUnitOfWork = current$$1;
+              break a;
+            }
+            fiber = null !== fiber;
+            renderExpirationTime =
+              null !== current && null !== current.memoizedState;
+            null !== current &&
+              !fiber &&
+              renderExpirationTime &&
+              ((type = current.child.sibling),
+              null !== type &&
+                ((current = current$$1.firstEffect),
+                null !== current
+                  ? ((current$$1.firstEffect = type),
+                    (type.nextEffect = current))
+                  : ((current$$1.firstEffect = current$$1.lastEffect = type),
+                    (type.nextEffect = null)),
+                (type.effectTag = 8)));
+            if (
+              fiber !== renderExpirationTime ||
+              (0 === (current$$1.effectTag & 1) && fiber)
+            )
+              current$$1.effectTag |= 4;
+            break;
+          case 7:
+            break;
+          case 8:
+            break;
+          case 12:
+            break;
+          case 4:
+            popHostContainer(current$$1);
+            updateHostContainer(current$$1);
+            break;
+          case 10:
+            popProvider(current$$1);
+            break;
+          case 9:
+            break;
+          case 14:
+            break;
+          case 17:
+            isContextProvider(current$$1.type) && popContext(current$$1);
+            break;
+          default:
+            invariant(
+              !1,
+              "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
+        nextUnitOfWork = null;
       }
-      nextUnitOfWork = null;
       workInProgress.mode & 4 &&
         stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !1);
       current$$1 = workInProgress;
       if (
-        1073741823 === nextRenderExpirationTime ||
-        1073741823 !== current$$1.childExpirationTime
+        1 === nextRenderExpirationTime ||
+        1 !== current$$1.childExpirationTime
       ) {
         fiber = 0;
         if (current$$1.mode & 4) {
-          rootContainerInstance = current$$1.actualDuration;
+          renderExpirationTime = current$$1.actualDuration;
           type = current$$1.selfBaseDuration;
           current =
             null === current$$1.alternate ||
             current$$1.child !== current$$1.alternate.child;
-          for (viewConfig = current$$1.child; null !== viewConfig; ) {
-            internalInstanceHandle = viewConfig.expirationTime;
-            tag = viewConfig.childExpirationTime;
-            if (
-              0 === fiber ||
-              (0 !== internalInstanceHandle && internalInstanceHandle < fiber)
-            )
-              fiber = internalInstanceHandle;
-            if (0 === fiber || (0 !== tag && tag < fiber)) fiber = tag;
-            current && (rootContainerInstance += viewConfig.actualDuration);
-            type += viewConfig.treeBaseDuration;
-            viewConfig = viewConfig.sibling;
-          }
-          current$$1.actualDuration = rootContainerInstance;
+          for (
+            internalInstanceHandle = current$$1.child;
+            null !== internalInstanceHandle;
+
+          )
+            (tag = internalInstanceHandle.expirationTime),
+              (viewConfig = internalInstanceHandle.childExpirationTime),
+              tag > fiber && (fiber = tag),
+              viewConfig > fiber && (fiber = viewConfig),
+              current &&
+                (renderExpirationTime += internalInstanceHandle.actualDuration),
+              (type += internalInstanceHandle.treeBaseDuration),
+              (internalInstanceHandle = internalInstanceHandle.sibling);
+          current$$1.actualDuration = renderExpirationTime;
           current$$1.treeBaseDuration = type;
         } else
           for (
-            rootContainerInstance = current$$1.child;
-            null !== rootContainerInstance;
+            renderExpirationTime = current$$1.child;
+            null !== renderExpirationTime;
 
-          ) {
-            type = rootContainerInstance.expirationTime;
-            current = rootContainerInstance.childExpirationTime;
-            if (0 === fiber || (0 !== type && type < fiber)) fiber = type;
-            if (0 === fiber || (0 !== current && current < fiber))
-              fiber = current;
-            rootContainerInstance = rootContainerInstance.sibling;
-          }
+          )
+            (type = renderExpirationTime.expirationTime),
+              (current = renderExpirationTime.childExpirationTime),
+              type > fiber && (fiber = type),
+              current > fiber && (fiber = current),
+              (renderExpirationTime = renderExpirationTime.sibling);
         current$$1.childExpirationTime = fiber;
       }
+      if (null !== nextUnitOfWork) return nextUnitOfWork;
       null !== returnFiber &&
-        0 === (returnFiber.effectTag & 512) &&
+        0 === (returnFiber.effectTag & 1024) &&
         (null === returnFiber.firstEffect &&
           (returnFiber.firstEffect = workInProgress.firstEffect),
         null !== workInProgress.lastEffect &&
@@ -5462,23 +6297,19 @@ function completeUnitOfWork(workInProgress) {
             : (returnFiber.firstEffect = workInProgress),
           (returnFiber.lastEffect = workInProgress)));
     } else {
-      workInProgress.mode & 4 &&
+      if (workInProgress.mode & 4) {
         stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !1);
-      workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
-      if (null !== workInProgress) {
-        if (workInProgress.mode & 4) {
-          returnFiber = workInProgress.actualDuration;
-          for (siblingFiber = workInProgress.child; null !== siblingFiber; )
-            (returnFiber += siblingFiber.actualDuration),
-              (siblingFiber = siblingFiber.sibling);
-          workInProgress.actualDuration = returnFiber;
-        }
-        workInProgress.effectTag &= 511;
-        return workInProgress;
+        current$$1 = workInProgress.actualDuration;
+        for (fiber = workInProgress.child; null !== fiber; )
+          (current$$1 += fiber.actualDuration), (fiber = fiber.sibling);
+        workInProgress.actualDuration = current$$1;
       }
+      workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
+      if (null !== workInProgress)
+        return (workInProgress.effectTag &= 1023), workInProgress;
       null !== returnFiber &&
         ((returnFiber.firstEffect = returnFiber.lastEffect = null),
-        (returnFiber.effectTag |= 512));
+        (returnFiber.effectTag |= 1024));
     }
     if (null !== siblingFiber) return siblingFiber;
     if (null !== returnFiber) workInProgress = returnFiber;
@@ -5493,17 +6324,19 @@ function performUnitOfWork(workInProgress) {
     0 > workInProgress.actualStartTime &&
       (workInProgress.actualStartTime = now$1()));
   current$$1 = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
+  workInProgress.memoizedProps = workInProgress.pendingProps;
   workInProgress.mode & 4 &&
     stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !0);
   null === current$$1 && (current$$1 = completeUnitOfWork(workInProgress));
   ReactCurrentOwner$2.current = null;
   return current$$1;
 }
-function renderRoot(root, isYieldy, isExpired) {
+function renderRoot(root, isYieldy) {
   invariant(
     !isWorking,
     "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
+  flushPassiveEffects();
   isWorking = !0;
   ReactCurrentOwner$2.currentDispatcher = Dispatcher;
   var expirationTime = root.nextExpirationTimeToWorkOn;
@@ -5526,7 +6359,7 @@ function renderRoot(root, isYieldy, isExpired) {
       scheduledInteractions,
       scheduledExpirationTime
     ) {
-      scheduledExpirationTime <= expirationTime &&
+      scheduledExpirationTime >= expirationTime &&
         scheduledInteractions.forEach(function(interaction) {
           return interactions.add(interaction);
         });
@@ -5552,15 +6385,21 @@ function renderRoot(root, isYieldy, isExpired) {
   do {
     try {
       if (isYieldy)
-        for (; null !== nextUnitOfWork && !shouldYield(); )
+        for (; null !== nextUnitOfWork && !shouldYieldToRenderer(); )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
       else
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (null === nextUnitOfWork)
+      if (
+        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
+        resetHooks(),
+        null === nextUnitOfWork)
+      )
         (threadID = !0), onUncaughtError(thrownValue);
       else {
+        nextUnitOfWork.mode & 4 &&
+          stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, !0);
         invariant(
           null !== nextUnitOfWork,
           "Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it."
@@ -5586,134 +6425,162 @@ function renderRoot(root, isYieldy, isExpired) {
   tracing.__interactionsRef.current = subscriber;
   isWorking = !1;
   lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
+  resetHooks();
   if (threadID) (nextRoot = null), (root.finishedWork = null);
   else if (null !== nextUnitOfWork) root.finishedWork = null;
   else {
-    isYieldy = root.current.alternate;
+    subscriber = root.current.alternate;
     invariant(
-      null !== isYieldy,
+      null !== subscriber,
       "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue."
     );
     nextRoot = null;
     if (nextRenderDidError) {
       if (hasLowerPriorityWork(root, expirationTime)) {
         markSuspendedPriorityLevel(root, expirationTime);
-        onSuspend(root, isYieldy, expirationTime, root.expirationTime, -1);
+        onSuspend(root, subscriber, expirationTime, root.expirationTime, -1);
         return;
       }
-      if (!root.didError && !isExpired) {
+      if (!root.didError && isYieldy) {
         root.didError = !0;
-        isExpired = root.nextExpirationTimeToWorkOn = expirationTime;
-        subscriber = root.expirationTime = 1;
-        onSuspend(root, isYieldy, isExpired, subscriber, -1);
+        isYieldy = root.nextExpirationTimeToWorkOn = expirationTime;
+        threadID = root.expirationTime = 1073741823;
+        onSuspend(root, subscriber, isYieldy, threadID, -1);
         return;
       }
     }
-    onComplete(root, isYieldy, expirationTime);
+    isYieldy && -1 !== nextLatestAbsoluteTimeoutMs
+      ? (markSuspendedPriorityLevel(root, expirationTime),
+        (isYieldy =
+          10 *
+          (1073741822 -
+            findEarliestOutstandingPriorityLevel(root, expirationTime))),
+        isYieldy < nextLatestAbsoluteTimeoutMs &&
+          (nextLatestAbsoluteTimeoutMs = isYieldy),
+        (isYieldy = 10 * (1073741822 - requestCurrentTime())),
+        (isYieldy = nextLatestAbsoluteTimeoutMs - isYieldy),
+        onSuspend(
+          root,
+          subscriber,
+          expirationTime,
+          root.expirationTime,
+          0 > isYieldy ? 0 : isYieldy
+        ))
+      : onComplete(root, subscriber, expirationTime);
   }
 }
-function captureCommitPhaseError(fiber, error) {
-  var JSCompiler_inline_result;
-  a: {
-    invariant(
-      !isWorking || isCommitting$1,
-      "dispatch: Cannot dispatch during the render phase."
-    );
-    for (
-      JSCompiler_inline_result = fiber.return;
-      null !== JSCompiler_inline_result;
-
-    ) {
-      switch (JSCompiler_inline_result.tag) {
-        case 2:
-        case 3:
-          var instance = JSCompiler_inline_result.stateNode;
-          if (
-            "function" ===
-              typeof JSCompiler_inline_result.type.getDerivedStateFromError ||
-            ("function" === typeof instance.componentDidCatch &&
-              (null === legacyErrorBoundariesThatAlreadyFailed ||
-                !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
-          ) {
-            fiber = createCapturedValue(error, fiber);
-            fiber = createClassErrorUpdate(JSCompiler_inline_result, fiber, 1);
-            enqueueUpdate(JSCompiler_inline_result, fiber);
-            scheduleWork(JSCompiler_inline_result, 1);
-            JSCompiler_inline_result = void 0;
-            break a;
-          }
-          break;
-        case 5:
-          fiber = createCapturedValue(error, fiber);
-          fiber = createRootErrorUpdate(JSCompiler_inline_result, fiber, 1);
-          enqueueUpdate(JSCompiler_inline_result, fiber);
-          scheduleWork(JSCompiler_inline_result, 1);
-          JSCompiler_inline_result = void 0;
-          break a;
-      }
-      JSCompiler_inline_result = JSCompiler_inline_result.return;
+function captureCommitPhaseError(sourceFiber, value) {
+  for (var fiber = sourceFiber.return; null !== fiber; ) {
+    switch (fiber.tag) {
+      case 1:
+        var instance = fiber.stateNode;
+        if (
+          "function" === typeof fiber.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValue(value, sourceFiber);
+          sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
+          enqueueUpdate(fiber, sourceFiber);
+          scheduleWork(fiber, 1073741823);
+          return;
+        }
+        break;
+      case 3:
+        sourceFiber = createCapturedValue(value, sourceFiber);
+        sourceFiber = createRootErrorUpdate(fiber, sourceFiber, 1073741823);
+        enqueueUpdate(fiber, sourceFiber);
+        scheduleWork(fiber, 1073741823);
+        return;
     }
-    5 === fiber.tag &&
-      ((JSCompiler_inline_result = createCapturedValue(error, fiber)),
-      (JSCompiler_inline_result = createRootErrorUpdate(
-        fiber,
-        JSCompiler_inline_result,
-        1
-      )),
-      enqueueUpdate(fiber, JSCompiler_inline_result),
-      scheduleWork(fiber, 1));
-    JSCompiler_inline_result = void 0;
+    fiber = fiber.return;
   }
-  return JSCompiler_inline_result;
+  3 === sourceFiber.tag &&
+    ((fiber = createCapturedValue(value, sourceFiber)),
+    (fiber = createRootErrorUpdate(sourceFiber, fiber, 1073741823)),
+    enqueueUpdate(sourceFiber, fiber),
+    scheduleWork(sourceFiber, 1073741823));
 }
 function computeExpirationForFiber(currentTime, fiber) {
   isWorking
-    ? (currentTime = isCommitting$1 ? 1 : nextRenderExpirationTime)
+    ? (currentTime = isCommitting$1 ? 1073741823 : nextRenderExpirationTime)
     : fiber.mode & 1
       ? ((currentTime = isBatchingInteractiveUpdates
-          ? 2 + 10 * ((((currentTime - 2 + 15) / 10) | 0) + 1)
-          : 2 + 25 * ((((currentTime - 2 + 500) / 25) | 0) + 1)),
+          ? 1073741822 - 10 * ((((1073741822 - currentTime + 15) / 10) | 0) + 1)
+          : 1073741822 -
+            25 * ((((1073741822 - currentTime + 500) / 25) | 0) + 1)),
         null !== nextRoot &&
           currentTime === nextRenderExpirationTime &&
-          (currentTime += 1))
-      : (currentTime = 1);
+          --currentTime)
+      : (currentTime = 1073741823);
   isBatchingInteractiveUpdates &&
-    currentTime > lowestPriorityPendingInteractiveExpirationTime &&
+    (0 === lowestPriorityPendingInteractiveExpirationTime ||
+      currentTime < lowestPriorityPendingInteractiveExpirationTime) &&
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
+function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
+  var retryTime = root.earliestSuspendedTime;
+  var latestSuspendedTime = root.latestSuspendedTime;
+  if (
+    0 !== retryTime &&
+    suspendedTime <= retryTime &&
+    suspendedTime >= latestSuspendedTime
+  ) {
+    latestSuspendedTime = retryTime = suspendedTime;
+    root.didError = !1;
+    var latestPingedTime = root.latestPingedTime;
+    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
+      root.latestPingedTime = latestSuspendedTime;
+    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
+  } else
+    (retryTime = requestCurrentTime()),
+      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
+      markPendingPriorityLevel(root, retryTime);
+  0 !== (boundaryFiber.mode & 1) &&
+    root === nextRoot &&
+    nextRenderExpirationTime === suspendedTime &&
+    (nextRoot = null);
+  scheduleWorkToRoot(boundaryFiber, retryTime);
+  0 === (boundaryFiber.mode & 1) &&
+    (scheduleWorkToRoot(sourceFiber, retryTime),
+    1 === sourceFiber.tag &&
+      null !== sourceFiber.stateNode &&
+      ((boundaryFiber = createUpdate(retryTime)),
+      (boundaryFiber.tag = 2),
+      enqueueUpdate(sourceFiber, boundaryFiber)));
+  sourceFiber = root.expirationTime;
+  0 !== sourceFiber && requestWork(root, sourceFiber);
+}
 function scheduleWorkToRoot(fiber, expirationTime) {
-  if (0 === fiber.expirationTime || fiber.expirationTime > expirationTime)
-    fiber.expirationTime = expirationTime;
+  fiber.expirationTime < expirationTime &&
+    (fiber.expirationTime = expirationTime);
   var alternate = fiber.alternate;
   null !== alternate &&
-    (0 === alternate.expirationTime ||
-      alternate.expirationTime > expirationTime) &&
+    alternate.expirationTime < expirationTime &&
     (alternate.expirationTime = expirationTime);
   var node = fiber.return,
     root = null;
-  if (null === node && 5 === fiber.tag) root = fiber.stateNode;
+  if (null === node && 3 === fiber.tag) root = fiber.stateNode;
   else
     for (; null !== node; ) {
       alternate = node.alternate;
-      if (
-        0 === node.childExpirationTime ||
-        node.childExpirationTime > expirationTime
-      )
-        node.childExpirationTime = expirationTime;
+      node.childExpirationTime < expirationTime &&
+        (node.childExpirationTime = expirationTime);
       null !== alternate &&
-        (0 === alternate.childExpirationTime ||
-          alternate.childExpirationTime > expirationTime) &&
+        alternate.childExpirationTime < expirationTime &&
         (alternate.childExpirationTime = expirationTime);
-      if (null === node.return && 5 === node.tag) {
+      if (null === node.return && 3 === node.tag) {
         root = node.stateNode;
         break;
       }
       node = node.return;
     }
-  if (null === root) return null;
-  fiber = tracing.__interactionsRef.current;
-  if (0 < fiber.size) {
+  if (
+    null !== root &&
+    ((fiber = tracing.__interactionsRef.current), 0 < fiber.size)
+  ) {
     alternate = root.pendingInteractionMap;
     var pendingInteractions = alternate.get(expirationTime);
     null != pendingInteractions
@@ -5736,46 +6603,20 @@ function scheduleWorkToRoot(fiber, expirationTime) {
 }
 function scheduleWork(fiber, expirationTime) {
   fiber = scheduleWorkToRoot(fiber, expirationTime);
-  if (null !== fiber) {
-    !isWorking &&
+  null !== fiber &&
+    (!isWorking &&
       0 !== nextRenderExpirationTime &&
-      expirationTime < nextRenderExpirationTime &&
-      resetStack();
-    markPendingPriorityLevel(fiber, expirationTime);
-    if (!isWorking || isCommitting$1 || nextRoot !== fiber) {
-      expirationTime = fiber.expirationTime;
-      if (null === fiber.nextScheduledRoot)
-        (fiber.expirationTime = expirationTime),
-          null === lastScheduledRoot
-            ? ((firstScheduledRoot = lastScheduledRoot = fiber),
-              (fiber.nextScheduledRoot = fiber))
-            : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = fiber),
-              (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot));
-      else {
-        var remainingExpirationTime = fiber.expirationTime;
-        if (
-          0 === remainingExpirationTime ||
-          expirationTime < remainingExpirationTime
-        )
-          fiber.expirationTime = expirationTime;
-      }
-      isRendering ||
-        (isBatchingUpdates
-          ? isUnbatchingUpdates &&
-            ((nextFlushedRoot = fiber),
-            (nextFlushedExpirationTime = 1),
-            performWorkOnRoot(fiber, 1, !0))
-          : 1 === expirationTime
-            ? performWork(1, null)
-            : scheduleCallbackWithExpirationTime(fiber, expirationTime));
-    }
+      expirationTime > nextRenderExpirationTime &&
+      resetStack(),
+    markPendingPriorityLevel(fiber, expirationTime),
+    (isWorking && !isCommitting$1 && nextRoot === fiber) ||
+      requestWork(fiber, fiber.expirationTime),
     nestedUpdateCount > NESTED_UPDATE_LIMIT &&
       ((nestedUpdateCount = 0),
       invariant(
         !1,
         "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
-      ));
-  }
+      )));
 }
 var firstScheduledRoot = null,
   lastScheduledRoot = null,
@@ -5785,27 +6626,25 @@ var firstScheduledRoot = null,
   nextFlushedRoot = null,
   nextFlushedExpirationTime = 0,
   lowestPriorityPendingInteractiveExpirationTime = 0,
-  deadlineDidExpire = !1,
   hasUnhandledError = !1,
   unhandledError = null,
-  deadline = null,
   isBatchingUpdates = !1,
   isUnbatchingUpdates = !1,
   isBatchingInteractiveUpdates = !1,
   completedBatches = null,
   originalStartTimeMs = now$1(),
-  currentRendererTime = ((originalStartTimeMs / 10) | 0) + 2,
+  currentRendererTime = 1073741822 - ((originalStartTimeMs / 10) | 0),
   currentSchedulerTime = currentRendererTime,
   NESTED_UPDATE_LIMIT = 50,
   nestedUpdateCount = 0,
-  lastCommittedRootDuringThisBatch = null,
-  timeHeuristicForUnitOfWork = 1;
+  lastCommittedRootDuringThisBatch = null;
 function recomputeCurrentRendererTime() {
-  currentRendererTime = (((now$1() - originalStartTimeMs) / 10) | 0) + 2;
+  currentRendererTime =
+    1073741822 - (((now$1() - originalStartTimeMs) / 10) | 0);
 }
 function scheduleCallbackWithExpirationTime(root, expirationTime) {
   if (0 !== callbackExpirationTime) {
-    if (expirationTime > callbackExpirationTime) return;
+    if (expirationTime < callbackExpirationTime) return;
     null !== callbackID &&
       ((root = callbackID), (scheduledCallback = null), clearTimeout(root));
   }
@@ -5826,13 +6665,29 @@ function onSuspend(
   msUntilTimeout
 ) {
   root.expirationTime = rootExpirationTime;
-  0 < msUntilTimeout &&
-    (root.timeoutHandle = scheduleTimeout(
-      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
-      msUntilTimeout
-    ));
+  0 !== msUntilTimeout || shouldYieldToRenderer()
+    ? 0 < msUntilTimeout &&
+      (root.timeoutHandle = scheduleTimeout(
+        onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
+        msUntilTimeout
+      ))
+    : ((root.pendingCommitExpirationTime = suspendedExpirationTime),
+      (root.finishedWork = finishedWork));
+}
+function onTimeout(root, finishedWork, suspendedExpirationTime) {
+  root.pendingCommitExpirationTime = suspendedExpirationTime;
+  root.finishedWork = finishedWork;
+  recomputeCurrentRendererTime();
+  currentSchedulerTime = currentRendererTime;
+  invariant(
+    !isRendering,
+    "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method."
+  );
+  nextFlushedRoot = root;
+  nextFlushedExpirationTime = suspendedExpirationTime;
+  performWorkOnRoot(root, suspendedExpirationTime, !1);
+  performWork(1073741823, !1);
 }
-function onTimeout() {}
 function onCommit(root, expirationTime) {
   root.expirationTime = expirationTime;
   root.finishedWork = null;
@@ -5840,14 +6695,31 @@ function onCommit(root, expirationTime) {
 function requestCurrentTime() {
   if (isRendering) return currentSchedulerTime;
   findHighestPriorityRoot();
-  if (
-    0 === nextFlushedExpirationTime ||
-    1073741823 === nextFlushedExpirationTime
-  )
+  if (0 === nextFlushedExpirationTime || 1 === nextFlushedExpirationTime)
     recomputeCurrentRendererTime(),
       (currentSchedulerTime = currentRendererTime);
   return currentSchedulerTime;
 }
+function requestWork(root, expirationTime) {
+  null === root.nextScheduledRoot
+    ? ((root.expirationTime = expirationTime),
+      null === lastScheduledRoot
+        ? ((firstScheduledRoot = lastScheduledRoot = root),
+          (root.nextScheduledRoot = root))
+        : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root),
+          (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot)))
+    : expirationTime > root.expirationTime &&
+      (root.expirationTime = expirationTime);
+  isRendering ||
+    (isBatchingUpdates
+      ? isUnbatchingUpdates &&
+        ((nextFlushedRoot = root),
+        (nextFlushedExpirationTime = 1073741823),
+        performWorkOnRoot(root, 1073741823, !1))
+      : 1073741823 === expirationTime
+        ? performWork(1073741823, !1)
+        : scheduleCallbackWithExpirationTime(root, expirationTime));
+}
 function findHighestPriorityRoot() {
   var highestPriorityWork = 0,
     highestPriorityRoot = null;
@@ -5881,14 +6753,11 @@ function findHighestPriorityRoot() {
             (root.nextScheduledRoot = null);
         root = previousScheduledRoot.nextScheduledRoot;
       } else {
-        if (
-          0 === highestPriorityWork ||
-          remainingExpirationTime < highestPriorityWork
-        )
-          (highestPriorityWork = remainingExpirationTime),
-            (highestPriorityRoot = root);
+        remainingExpirationTime > highestPriorityWork &&
+          ((highestPriorityWork = remainingExpirationTime),
+          (highestPriorityRoot = root));
         if (root === lastScheduledRoot) break;
-        if (1 === highestPriorityWork) break;
+        if (1073741823 === highestPriorityWork) break;
         previousScheduledRoot = root;
         root = root.nextScheduledRoot;
       }
@@ -5896,38 +6765,44 @@ function findHighestPriorityRoot() {
   nextFlushedRoot = highestPriorityRoot;
   nextFlushedExpirationTime = highestPriorityWork;
 }
-function performAsyncWork(dl) {
-  if (dl.didTimeout && null !== firstScheduledRoot) {
-    recomputeCurrentRendererTime();
-    var root = firstScheduledRoot;
-    do {
-      var expirationTime = root.expirationTime;
-      0 !== expirationTime &&
-        currentRendererTime >= expirationTime &&
-        (root.nextExpirationTimeToWorkOn = currentRendererTime);
-      root = root.nextScheduledRoot;
-    } while (root !== firstScheduledRoot);
+var didYield = !1;
+function shouldYieldToRenderer() {
+  return didYield ? !0 : frameDeadline <= now$1() ? (didYield = !0) : !1;
+}
+function performAsyncWork() {
+  try {
+    if (!shouldYieldToRenderer() && null !== firstScheduledRoot) {
+      recomputeCurrentRendererTime();
+      var root = firstScheduledRoot;
+      do {
+        var expirationTime = root.expirationTime;
+        0 !== expirationTime &&
+          currentRendererTime <= expirationTime &&
+          (root.nextExpirationTimeToWorkOn = currentRendererTime);
+        root = root.nextScheduledRoot;
+      } while (root !== firstScheduledRoot);
+    }
+    performWork(0, !0);
+  } finally {
+    didYield = !1;
   }
-  performWork(0, dl);
 }
-function performWork(minExpirationTime, dl) {
-  deadline = dl;
+function performWork(minExpirationTime, isYieldy) {
   findHighestPriorityRoot();
-  if (null !== deadline)
+  if (isYieldy)
     for (
       recomputeCurrentRendererTime(),
         currentSchedulerTime = currentRendererTime;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime) &&
-      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime &&
+      !(didYield && currentRendererTime > nextFlushedExpirationTime);
 
     )
       performWorkOnRoot(
         nextFlushedRoot,
         nextFlushedExpirationTime,
-        currentRendererTime >= nextFlushedExpirationTime
+        currentRendererTime > nextFlushedExpirationTime
       ),
         findHighestPriorityRoot(),
         recomputeCurrentRendererTime(),
@@ -5937,29 +6812,28 @@ function performWork(minExpirationTime, dl) {
       ;
       null !== nextFlushedRoot &&
       0 !== nextFlushedExpirationTime &&
-      (0 === minExpirationTime ||
-        minExpirationTime >= nextFlushedExpirationTime);
+      minExpirationTime <= nextFlushedExpirationTime;
 
     )
-      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !0),
+      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !1),
         findHighestPriorityRoot();
-  null !== deadline && ((callbackExpirationTime = 0), (callbackID = null));
+  isYieldy && ((callbackExpirationTime = 0), (callbackID = null));
   0 !== nextFlushedExpirationTime &&
     scheduleCallbackWithExpirationTime(
       nextFlushedRoot,
       nextFlushedExpirationTime
     );
-  deadline = null;
-  deadlineDidExpire = !1;
   nestedUpdateCount = 0;
   lastCommittedRootDuringThisBatch = null;
   if (null !== completedBatches)
     for (
-      minExpirationTime = completedBatches, completedBatches = null, dl = 0;
-      dl < minExpirationTime.length;
-      dl++
+      minExpirationTime = completedBatches,
+        completedBatches = null,
+        isYieldy = 0;
+      isYieldy < minExpirationTime.length;
+      isYieldy++
     ) {
-      var batch = minExpirationTime[dl];
+      var batch = minExpirationTime[isYieldy];
       try {
         batch._onComplete();
       } catch (error) {
@@ -5973,39 +6847,45 @@ function performWork(minExpirationTime, dl) {
     (hasUnhandledError = !1),
     minExpirationTime);
 }
-function performWorkOnRoot(root, expirationTime, isExpired) {
+function performWorkOnRoot(root, expirationTime, isYieldy) {
   invariant(
     !isRendering,
     "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue."
   );
   isRendering = !0;
-  if (null === deadline || isExpired) {
-    var finishedWork = root.finishedWork;
-    null !== finishedWork
-      ? completeRoot(root, finishedWork, expirationTime)
+  if (isYieldy) {
+    var _finishedWork = root.finishedWork;
+    null !== _finishedWork
+      ? completeRoot(root, _finishedWork, expirationTime)
       : ((root.finishedWork = null),
-        renderRoot(root, !1, isExpired),
-        (finishedWork = root.finishedWork),
-        null !== finishedWork &&
-          completeRoot(root, finishedWork, expirationTime));
+        (_finishedWork = root.timeoutHandle),
+        -1 !== _finishedWork &&
+          ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+        renderRoot(root, isYieldy),
+        (_finishedWork = root.finishedWork),
+        null !== _finishedWork &&
+          (shouldYieldToRenderer()
+            ? (root.finishedWork = _finishedWork)
+            : completeRoot(root, _finishedWork, expirationTime)));
   } else
-    (finishedWork = root.finishedWork),
-      null !== finishedWork
-        ? completeRoot(root, finishedWork, expirationTime)
+    (_finishedWork = root.finishedWork),
+      null !== _finishedWork
+        ? completeRoot(root, _finishedWork, expirationTime)
         : ((root.finishedWork = null),
-          renderRoot(root, !0, isExpired),
-          (finishedWork = root.finishedWork),
-          null !== finishedWork &&
-            (shouldYield()
-              ? (root.finishedWork = finishedWork)
-              : completeRoot(root, finishedWork, expirationTime)));
+          (_finishedWork = root.timeoutHandle),
+          -1 !== _finishedWork &&
+            ((root.timeoutHandle = -1), cancelTimeout(_finishedWork)),
+          renderRoot(root, isYieldy),
+          (_finishedWork = root.finishedWork),
+          null !== _finishedWork &&
+            completeRoot(root, _finishedWork, expirationTime));
   isRendering = !1;
 }
 function completeRoot(root, finishedWork, expirationTime) {
   var firstBatch = root.firstBatch;
   if (
     null !== firstBatch &&
-    firstBatch._expirationTime <= expirationTime &&
+    firstBatch._expirationTime >= expirationTime &&
     (null === completedBatches
       ? (completedBatches = [firstBatch])
       : completedBatches.push(firstBatch),
@@ -6021,13 +6901,6 @@ function completeRoot(root, finishedWork, expirationTime) {
     : ((lastCommittedRootDuringThisBatch = root), (nestedUpdateCount = 0));
   commitRoot(root, finishedWork);
 }
-function shouldYield() {
-  return deadlineDidExpire
-    ? !0
-    : null === deadline || deadline.timeRemaining() > timeHeuristicForUnitOfWork
-      ? !1
-      : (deadlineDidExpire = !0);
-}
 function onUncaughtError(error) {
   invariant(
     null !== nextFlushedRoot,
@@ -6036,55 +6909,6 @@ function onUncaughtError(error) {
   nextFlushedRoot.expirationTime = 0;
   hasUnhandledError || ((hasUnhandledError = !0), (unhandledError = error));
 }
-function getContextForSubtree(parentComponent) {
-  if (!parentComponent) return emptyContextObject;
-  parentComponent = parentComponent._reactInternalFiber;
-  a: {
-    invariant(
-      2 === isFiberMountedImpl(parentComponent) &&
-        (2 === parentComponent.tag || 3 === parentComponent.tag),
-      "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-    );
-    var parentContext = parentComponent;
-    do {
-      switch (parentContext.tag) {
-        case 5:
-          parentContext = parentContext.stateNode.context;
-          break a;
-        case 2:
-          if (isContextProvider(parentContext.type)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-          break;
-        case 3:
-          if (isContextProvider(parentContext.type._reactResult)) {
-            parentContext =
-              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
-            break a;
-          }
-      }
-      parentContext = parentContext.return;
-    } while (null !== parentContext);
-    invariant(
-      !1,
-      "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-    );
-    parentContext = void 0;
-  }
-  if (2 === parentComponent.tag) {
-    var Component = parentComponent.type;
-    if (isContextProvider(Component))
-      return processChildContext(parentComponent, Component, parentContext);
-  } else if (
-    3 === parentComponent.tag &&
-    ((Component = parentComponent.type._reactResult),
-    isContextProvider(Component))
-  )
-    return processChildContext(parentComponent, Component, parentContext);
-  return parentContext;
-}
 function findHostInstance$1(component) {
   var fiber = component._reactInternalFiber;
   void 0 === fiber &&
@@ -6103,7 +6927,48 @@ function updateContainer(element, container, parentComponent, callback) {
     currentTime = requestCurrentTime();
   current$$1 = computeExpirationForFiber(currentTime, current$$1);
   currentTime = container.current;
-  parentComponent = getContextForSubtree(parentComponent);
+  a: if (parentComponent) {
+    parentComponent = parentComponent._reactInternalFiber;
+    b: {
+      invariant(
+        2 === isFiberMountedImpl(parentComponent) && 1 === parentComponent.tag,
+        "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
+      );
+      var parentContext = parentComponent;
+      do {
+        switch (parentContext.tag) {
+          case 3:
+            parentContext = parentContext.stateNode.context;
+            break b;
+          case 1:
+            if (isContextProvider(parentContext.type)) {
+              parentContext =
+                parentContext.stateNode
+                  .__reactInternalMemoizedMergedChildContext;
+              break b;
+            }
+        }
+        parentContext = parentContext.return;
+      } while (null !== parentContext);
+      invariant(
+        !1,
+        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
+      );
+      parentContext = void 0;
+    }
+    if (1 === parentComponent.tag) {
+      var Component = parentComponent.type;
+      if (isContextProvider(Component)) {
+        parentComponent = processChildContext(
+          parentComponent,
+          Component,
+          parentContext
+        );
+        break a;
+      }
+    }
+    parentComponent = parentContext;
+  } else parentComponent = emptyContextObject;
   null === container.context
     ? (container.context = parentComponent)
     : (container.pendingContext = parentComponent);
@@ -6112,6 +6977,7 @@ function updateContainer(element, container, parentComponent, callback) {
   callback.payload = { element: element };
   container = void 0 === container ? null : container;
   null !== container && (callback.callback = container);
+  flushPassiveEffects();
   enqueueUpdate(currentTime, callback);
   scheduleWork(currentTime, current$$1);
   return current$$1;
@@ -6171,13 +7037,13 @@ _batchedUpdatesImpl = function(fn, a) {
   } finally {
     (isBatchingUpdates = previousIsBatchingUpdates) ||
       isRendering ||
-      performWork(1, null);
+      performWork(1073741823, !1);
   }
 };
 _flushInteractiveUpdatesImpl = function() {
   isRendering ||
     0 === lowestPriorityPendingInteractiveExpirationTime ||
-    (performWork(lowestPriorityPendingInteractiveExpirationTime, null),
+    (performWork(lowestPriorityPendingInteractiveExpirationTime, !1),
     (lowestPriorityPendingInteractiveExpirationTime = 0));
 };
 var roots = new Map(),
@@ -6259,7 +7125,7 @@ var roots = new Map(),
       if (!root) {
         root = 0;
         isDevToolsPresent && (root |= 4);
-        root = new FiberNode(5, null, null, root);
+        root = createFiber(3, null, null, root);
         var root$jscomp$0 = {
           current: root,
           containerInfo: containerTag,
@@ -6290,7 +7156,7 @@ var roots = new Map(),
       updateContainer(element, root, null, callback);
       a: if (((element = root.current), element.child))
         switch (element.child.tag) {
-          case 7:
+          case 5:
             element = element.child.stateNode;
             break a;
           default:
@@ -6397,7 +7263,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromTag,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.5.2",
+  version: "16.6.1",
   rendererPackageName: "react-native-renderer"
 });
 var ReactNativeRenderer$2 = { default: ReactNativeRenderer },
--- a/node_modules/react-native/Libraries/Renderer/shims/ReactTypes.js
+++ b/node_modules/react-native/Libraries/Renderer/shims/ReactTypes.js
@@ -54,12 +54,12 @@ export type ReactContext<T> = {
   $$typeof: Symbol | number,
   Consumer: ReactContext<T>,
   Provider: ReactProviderType<T>,
-  unstable_read: () => T,
 
   _calculateChangedBits: ((a: T, b: T) => number) | null,
 
   _currentValue: T,
   _currentValue2: T,
+  _threadCount: number,
 
   // DEV only
   _currentRenderer?: Object | null,
